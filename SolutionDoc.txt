Question #2:

a) The addtion operation where we add our multiplication from u[i] * v[i] to 
   our temporary register sum. The reason this operation cannot be parallelized
   is because it requires the previous value that we stored in "sum" in order 
   to perform the += operation to add our product back into sum.

b) As it is currently written, the best-case CPE for our function is 5. This is
   because our function is dependent upon running one floating point 
   multiplication per clock cycle and we know that the latency for a floating
   point multiplication is 5. Thus our best-case CPE is 5. Note that within
   the loop we also have the addition call. However, floating point addition
   only has a CPE of 3, which means that the speed of our function will only
   be dependent upon the float multiplication.

c) Inner2() function is most definitely faster. The function call in most cases 
   takes roughly 2/3 the time of the inner() function call. 

   Graph: