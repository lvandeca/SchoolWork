An
Actor
Language
The
Cache
demonstrated
cite
Koliousis
2012
DEBS
Redundant
here
that
an
embedded
stateful
language
could
support
concise
understandable
processing
of
complex
events
combining
advantages
of
temporal
databases
and
pub
sub
middleware
systems
with
far
better
performance
than
other
implementations
of
either
cite
Sventek
2012
UPS
Even
with
on
the
fly
translation
to
a
simple
interpreted
stack
machine
code
the
Cache
with
GAPL
outperformed
other
pub
sub
systems
by
avoiding
heavyweight
process
context
changes
efficiently
running
automata
in
threads
within
a
single
Unix
process
GAPL
programs
were
more
concise
and
readable
than
complex
non
procedural
temporal
database
code
for
complex
events
while
still
providing
the
essential
capability
of
accessing
a
sliding
window
of
past
events
The
success
of
the
Cache
with
GAPL
inspired
us
to
extend
and
adapt
this
approach
for
embedded
systems
including
robotics
An
actor
language
informed
by
experience
with
GAPL
is
a
central
component
of
our
approach
Our
actor
language
under
development
is
conservative
in
many
respects
borrowing
approaches
from
contemporary
languages
e
g
type
inference
as
in
Kotlin
Swift
and
other
recent
languages
to
provide
strong
static
typing
without
excessive
declaration
verbiage
and
innovating
only
where
there
is
a
clear
benefit
to
our
goal
of
supporting
embedded
system
development
Key
attributes
of
our
language
include
begin
bullets
begin
itemize
noitemsep
topsep
0pt
item
As
in
GAPL
the
key
role
of
an
actor
automaton
in
GAPL
is
to
statefully
react
to
each
message
on
a
given
pub
sub
topic
Actors
can
be
initialized
before
receiving
the
first
message
and
thereafter
can
maintain
local
state
from
message
to
message
They
can
publish
zero
or
more
messages
on
each
response
cycle
Actors
have
access
to
a
sliding
window
of
past
messages
as
in
a
temporal
database
item
The
actor
language
is
designed
to
be
both
interpreted
for
quickest
experimentation
in
the
development
environment
and
translated
to
native
code
for
higher
performance
Translation
options
include
a
kind
of
inlining
that
elides
communication
removing
the
performance
penalty
for
writing
very
modular
actors
that
perform
simple
event
filtering
and
aggregation
item
pub
sub
message
schemas
are
statically
typed
although
the
new
schemas
can
be
introduced
interactively
in
the
development
environment
The
simple
type
system
can
be
viewed
as
data
only
classes
with
a
typical
subtype
relation
The
language
ensures
shared
nothing
semantics
despite
actors
executing
in
a
shared
address
space
item
Actor
code
is
also
statically
and
strongly
typed
Simple
type
inference
as
in
many
contemporary
languages
allows
static
typing
without
burdensome
declarations
for
most
local
variables
Note
that
statically
typed
messages
are
unusual
in
pub
sub
systems
and
reflect
the
domains
that
we
address
as
well
as
the
kinds
of
support
we
intend
to
provide
in
the
development
environment
Messages
transmitted
within
a
single
cache
in
one
Unix
process
do
not
require
marshalling
and
unmarshalling
of
data
and
the
cost
of
remapping
is
very
small
in
the
case
of
interpreted
code
to
nonexistant
when
an
actor
is
optimized
for
a
known
topology
item
A
foreign
function
interface
for
code
following
C
linkage
conventions
permits
reuse
of
large
amounts
of
pre
existing
code
from
existing
robotics
and
embedded
ecosystems
e
g
Arduino
and
ROS
One
could
write
large
complex
actors
but
typically
actor
code
will
be
primarily
concerned
with
communication
and
state
management
Foreign
functions
could
in
principle
violate
the
shared
nothing
semantics
of
actors
but
only
by
violating
API
usage
rules
item
The
actor
language
includes
a
module
interconnection
language
to
control
instantiation
and
connection
of
actors
While
loose
coupling
is
seen
as
an
advantage
of
pub
sub
systems
in
practice
they
can
develop
implicit
dependency
Explicit
conversions
between
unrelated
but
compatible
schemas
are
possible
in
module
connections
to
prevents
brittleness
and
facilitate
some
simple
pipe
fitting
By
default
topics
and
field
names
are
mapped
to
themselves
to
avoid
unnecessary
verbiage
end
bullets
end
itemize
The
small
example
in
Figure
ref
fig
actor
position
illustrates
the
basic
structure
of
an
actor
that
converts
a
stream
of
WGS84
latitude
and
longitude
records
to
UTM
meters
east
and
north
of
a
reference
point
The
actual
calculations
are
performed
by
C
functions
that
may
be
reused
from
the
ROS
geodesey
library
and
Arduino
GPS
access
libraries
Since
UTM
coordinates
are
only
useful
within
a
fixed
region
and
all
participants
in
a
computation
must
share
the
reference
region
the
UTM
zone
and
band
are
parameters
provided
at
instantiation
The
main
loop
of
the
actor
receives
messages
topics
nmea
rmc
and
nmea
gga
associated
with
message
schemas
that
share
a
set
of
subfields
in
nmea
basic
Figure
ref
fig
nmea
and
those
fields
are
visible
within
the
main
response
loop
of
the
actor
After
dropping
readings
of
insufficient
quality
the
remaining
readings
are
converted
to
UTM
in
the
selected
region
and
republished
on
topic
utm
pos
begin
figure
scriptsize
begin
verbatim
import
C
gps
configure
import
C
latlon
to
utm
lat
lon
float
zone
int
band
char
easting
northing
float
import
nmea
actor
position
observer
utm
zone
int
utm
band
char
subscribes
nmea
rmc
nmea
gga
publishes
utm
pos
obsv
time
time
easting
northing
float
zone
int
band
char
gps
down
gps
up
bare
events
just
timestamps
initially
up
true
bad
count
0
each
nmea
rmc
nmea
gga
as
msg
if
msg
good
if
not
up
publish
gps
up
up
true
utm
latlon
to
utm
msg
latitude
msg
longitude
utm
zone
utm
band
publish
utm
pos
msg
time
of
fix
utm
easting
utm
northing
utm
zone
utm
band
else
bad
count
1
if
bad
count
10
and
up
up
false
publish
gps
down
end
verbatim
scriptsize
vskip
2em
caption
small
Example
actor
definition
label
fig
actor
position
end
figure
begin
figure
scriptsize
begin
lstlisting
begin
verbatim
schema
nmea
basic
msg
time
of
fix
time
Distinct
from
implicit
field
time
good
boolean
Combine
fix
and
dilution
latitude
float64
WGS
84
signed
longitude
float64
WGS
84
signed
schema
nmea
rmc
msg
nmea
basic
msg
meters
sec
float
from
speed
over
ground
course
float
degrees
from
true
north
def
nmea
rmc
topic
nmea
rmc
msg
def
nmea
gga
topic
extends
nmea
basic
msg
n
satellites
int
h
dilution
int
1
2
excellent
2
5
good
5
10
fair
precision
end
verbatim
scriptsize
vskip
1em
caption
small
Schema
definitions
for
example
actor
vspace
10pt
label
fig
nmea
end
figure
Subsubsec
Compiling
Actors
label
sec
compilingactors
The
GAPL
actor
language
of
the
original
Cache
is
translated
on
the
fly
into
bytecode
for
a
virtual
stack
machine
An
external
registering
process
which
could
be
a
component
process
a
console
or
a
more
complete
development
environment
transmits
source
code
to
the
cache
process
and
receives
in
return
either
a
handle
for
receiving
results
or
a
description
of
errors
in
the
actor
code
A
bytecode
interpreter
is
launched
in
its
own
thread
with
the
Cache
process
thus
in
a
shared
memory
space
with
the
possibility
of
parallelism
on
a
multi
core
processor
but
without
the
expense
of
full
process
context
switches
The
savings
in
context
switch
overhead
far
outweighs
the
cost
of
interpretation
We
will
support
just
in
time
and
ahead
of
time
translation
of
automata
to
native
code
as
well
as
integration
of
other
trusted
native
code
modules
Dynamic
composition
of
components
in
a
pub
sub
system
has
advantages
in
development
such
as
capturing
event
streams
and
replaying
them
for
regression
tests
so
we
will
retain
that
fundamental
capability
We
will
also
supporting
sealing
of
selected
modules
to
permit
greater
optimization
e
g
optimizing
away
communication
and
thread
switches
The
programming
model
will
be
identical
for
dynamically
configured
modules
and
those
that
are
baked
in
to
a
Cache
process
the
observable
differences
will
be
in
the
time
required
to
modify
the
configuration
fastest
for
interpreted
automata
slower
for
compiled
automata
slowest
for
those
that
have
been
baked
into
the
system
and
their
run
time
performance
fastest
for
baked
in
slowest
for
interpreted
automata
Subsubsec
Actor
Inlining
While
dynamic
establishment
of
communication
speeds
development
additional
optimizations
become
possible
when
the
communication
topology
is
fixed
The
module
interconnection
language
permits
specifying
that
a
topic
is
sealed
off
meaning
that
no
additional
actors
may
subscribe
or
publish
to
it
Sealing
topics
enables
some
additional
optimizations
the
most
important
of
which
is
that
some
actors
can
be
effectively
inlined
in
others
eliminating
some
communication
and
thread
switches
entirely
footnote
The
extreme
case
of
inlining
or
flattening
concurrent
processes
is
a
so
called
synchronous
language
like
Esterel
Signal
or
Lustre
Although
we
do
not
aim
for
complete
flattening
the
synchrony
hypothesis
that
the
time
taken
for
one
cycle
of
an
actor
is
small
relative
to
event
inter
arrival
time
is
relevant
Figure
ref
fig
actor
inline
illustrates
the
basic
idea
with
the
simplest
case
in
which
a
single
actor
here
gps
reader
published
to
a
topic
and
a
single
actor
here
position
observer
from
Figure
ref
fig
actor
position
subscribes
to
the
channel
Parameters
of
the
inlined
actor
become
parameters
of
the
publisher
initialization
sections
are
merged
and
the
subscriber
is
incorporated
at
the
point
of
communication
all
with
subscriber
variables
renamed
to
avoid
clashes
begin
figure
scriptsize
begin
lstlisting
begin
verbatim
a
before
inlining
actor
gps
reader
gps
port
addr
int64
subscribes
tick
Frequency
is
set
in
MIL
part
of
program
publishes
nmea
gga
initially
configure
gps
gps
port
addr
nmea
gga
each
tick
nmea
sentence
gps
read
gps
port
addr
publish
nmea
gga
nmea
sentence
b
after
inlining
position
listener
conceptually
inlining
will
be
performed
on
internal
rep
not
source
text
actor
gps
reader
gps
port
addr
int64
utm
zone
1
int
utm
band
1
char
subscribes
tick
Frequency
is
set
in
MIL
part
of
program
publishes
utm
pos
obsv
time
time
easting
northing
float
zone
int
band
char
gps
down
bare
event
just
a
timestamp
gps
up
initially
configure
gps
gps
port
addr
nmea
gga
up
1
true
bad
count
1
0
each
tick
nmea
sentence
gps
read
gps
port
addr
subscriber
event
handler
inserted
here
msg
1
nmea
sentence
local
variables
renamed
if
msg
1
good
if
not
up
1
publish
gps
up
up
1
true
utm
1
latlon
to
utm
msg
1
latitude
msg
1
longitude
utm
zone
1
utm
band
1
publish
utm
pos
msg
1
time
of
fix
utm
1
easting
utm
1
northing
utm
zone
1
utm
band
1
else
bad
count
1
1
if
bad
count
1
10
and
up
1
up
1
false
publish
gps
down
end
verbatim
scriptsize
end
lstlisting
vskip
1em
caption
Inlining
an
actor
small
Inlining
an
actor
for
the
simplest
case
in
which
a
topic
here
nmea
gga
is
published
by
exactly
one
actor
and
subscribed
by
exactly
one
actor
a
Publisher
before
inlining
b
Publisher
after
inlining
subscriber
Note
additional
parameters
and
initialization
actions
as
well
as
actions
in
the
event
loop
all
with
renamed
local
variables
vspace
10pt
label
fig
actor
inline
end
figure
Assuming
f
involves
no
blocking
communication
we
might
ascertain
that
enqueuing
a
messsage
for
this
simple
actor
and
triggering
its
thread
is
more
expensive
than
the
actual
computation
of
f
It
would
be
profitable
to
simply
incorporate
the
body
of
this
actor
where
events
on
topic
A
are
produced
This
is
almost
identical
to
procedure
inlining
if
events
on
topic
A
are
produced
by
only
one
other
actor
in
the
same
Cache
In
that
case
it
requires
only
renaming
local
variables
of
the
subscriber
process
which
may
retain
state
between
message
receipts
and
replacing
the
message
transmission
by
an
assignment
We
must
ascertain
that
the
subscriber
does
reliably
execute
quickly
enough
that
incoporating
it
into
the
publisher
will
not
cause
the
publisher
to
miss
deadlines
Subsubsec
Module
Interconnection
Software
engineering
researchers
have
long
argued
for
describing
module
connections
separately
from
describing
module
contents
or
interfaces
cite
DeRemer1976
usually
in
a
emph
module
interconnection
language
MIL
separate
from
the
programming
language
s
used
to
describe
module
behavior
An
initial
burst
of
work
in
module
interconnection
languages
cite
Prieto
Diaz1986
led
to
the
development
of
richer
architecture
description
languages
and
frameworks
cite
Dashofy2002
While
this
work
supports
effective
description
and
analysis
of
complex
software
artifacts
it
does
not
sufficiently
decouple
modules
as
either
the
service
provider
or
the
service
user
must
explicitly
name
the
other
and
know
details
of
its
interface
complex
dependency
injection
patterns
have
been
devised
as
unsatisfactory
workarounds
Pub
sub
architectures
ameliorate
dependency
as
neither
the
producer
of
an
event
nor
the
subscriber
to
an
event
need
be
aware
of
the
other
so
long
as
both
agree
on
a
topic
which
essentially
serves
as
a
channel
name
and
a
schema
for
event
descriptions
Essentially
pub
sub
architectures
achieve
a
particular
kind
of
dependency
injection
for
free
with
topics
and
schemas
serving
as
interfaces
While
there
may
be
no
explicit
MIL
notation
it
is
possible
to
extract
a
representation
of
event
flow
from
the
connection
topology
as
ROS
development
tools
do
for
example
In
practice
though
the
endpoints
of
a
communication
may
still
be
excessively
coupled
A
consumer
of
some
set
of
events
must
be
aware
of
the
topic
and
schemas
published
by
its
producer
and
a
different
producer
may
be
substituted
only
if
it
uses
the
same
topic
and
schema
e
g
referring
to
the
same
ROS
msg
spec
Thus
even
though
neither
producer
nor
consumer
explicitly
refers
to
the
other
in
practice
they
may
develop
fragile
dependencies
Our
actor
language
will
provide
module
interconnection
notation
to
further
reduce
coupling
among
components
Contrary
to
the
original
MILs
and
later
architecture
description
languages
our
MIL
will
be
part
of
the
actor
language
Module
interconnection
descriptions
can
still
be
distinct
and
separate
from
modules
and
interface
details
but
processing
interconnections
in
the
language
is
a
key
enabler
to
making
modularity
cheap
In
particular
explicit
connection
descriptions
in
the
language
and
as
importantly
ability
to
recognize
when
no
more
modules
will
be
connected
to
a
topic
is
necessary
to
enable
effective
inlining
of
actors
as
described
above
Two
key
constraints
on
the
MIL
notation
in
our
actor
language
are
that
it
be
suitable
for
dynamic
interactive
use
making
and
breaking
connections
from
the
console
of
a
development
environment
as
well
as
in
translation
and
that
it
not
impose
burdensome
verbiage
on
developers
We
will
satisfy
these
constraints
by
making
module
interconnection
a
mapping
with
the
identity
relation
as
default
That
is
if
we
create
an
instance
of
an
actor
that
subscribes
to
topic
x
then
by
default
the
topic
known
to
that
actor
as
x
is
in
fact
the
topic
known
to
the
Cache
as
x
exactly
as
in
typical
topic
based
pub
sub
systems
However
the
instantiation
operation
may
optionally
map
x
as
seen
by
the
actor
to
a
topic
y
and
may
at
the
same
time
map
names
of
fields
in
the
schema
without
violating
the
strong
static
typing
of
the
language
Figure
ref
fig
actor
mil
illustrates
Overhead
for
mapping
names
is
very
small
for
interpreted
actors
and
can
be
reduced
to
nothing
for
actors
compiled
to
native
code
begin
figure
scriptsize
begin
tabular
p
0
4
textwidth
p
0
5
textwidth
begin
verbatim
a
Instantiating
an
actor
with
all
defaults
create
position
observer
end
verbatim
begin
verbatim
b
Remapping
the
actor
name
topics
and
selected
fields
of
the
schema
create
posn
position
observer
nmea
rmc
gps
1
nmea
nmea
gga
none
latitude
lat
longitude
lng
end
verbatim
end
tabular
caption
small
Connecting
actors
with
defaults
a
and
with
explicit
mapping
b
vspace
10pt
label
fig
actor
mil
end
figure
chapter
C
programming
on
Linux
section
The
edit
compile
link
execute
ECLE
cycle
index
ECLE
cycle
Python
is
an
interpreted
language
You
present
blocks
written
in
Python
to
the
interpreter
it
interprets
the
code
executing
as
it
goes
along
C
and
many
other
programming
languages
are
emph
not
interpreted
A
programmer
using
these
languages
must
perform
the
following
steps
begin
itemize
noitemsep
item
use
an
textbf
e
ditor
or
other
tools
to
generate
one
or
more
files
containing
program
fragments
in
that
language
these
are
called
emph
source
files
item
textbf
c
ompile
transform
each
of
these
files
from
source
to
a
more
binary
representation
the
tool
used
to
perform
this
transformation
is
called
a
emph
compiler
and
the
binary
representation
for
each
source
file
is
called
an
emph
object
file
item
textbf
l
ink
together
each
of
the
object
files
along
with
any
code
needed
from
system
libraries
into
a
single
executable
program
file
and
finally
item
textbf
e
xecute
the
program
file
with
suitable
arguments
and
inputs
to
see
if
it
performs
correctly
end
itemize
If
the
program
does
not
execute
correctly
you
will
need
to
edit
one
or
more
of
the
source
files
compile
link
and
execute
again
Do
this
until
the
program
executes
correctly
thus
the
emph
ECLE
cycle
subsection
texttt
gcc
the
C
compiler
on
Linux
The
GNU
Compiler
Collection
is
a
compilation
system
that
enables
you
to
compile
source
files
written
in
index
commands
textbf
commands
gcc
C
C
Objective
C
Fortran
Ada
and
Go
This
system
has
been
adopted
as
part
of
Linux
verb
gcc
is
the
name
of
the
C
compiler
on
Linux
verb
gcc
has
a
large
number
of
flags
only
a
few
of
which
we
will
cover
in
this
book
Suppose
we
have
a
source
file
named
verb
prog
c
that
we
have
created
using
our
favorite
editor
Note
that
by
convention
C
source
files
have
a
verb
c
extension
Now
suppose
that
we
wish
to
compile
verb
prog
c
into
a
binary
object
file
The
command
needed
to
do
so
is
begin
adjustwidth
1cm
small
verb
gcc
c
prog
c
newline
normalsize
end
adjustwidth
The
verb
c
flag
tells
verb
gcc
to
compile
only
verb
gcc
also
performs
the
link
task
if
there
are
no
errors
in
verb
prog
c
verb
gcc
will
leave
the
compilation
results
in
a
file
named
verb
prog
o
Note
that
verb
o
is
the
conventional
extension
for
an
object
file
verb
gcc
can
also
link
object
files
into
an
executable
program
Assuming
that
verb
prog
c
contains
all
of
the
user
defined
logic
needed
then
the
following
command
will
produce
an
executable
program
in
a
file
named
verb
prog
begin
adjustwidth
1cm
small
verb
gcc
o
prog
prog
o
newline
normalsize
end
adjustwidth
Finally
you
can
execute
your
program
by
typing
the
following
command
begin
adjustwidth
1cm
small
verb
prog
newline
normalsize
end
adjustwidth
You
may
wonder
why
you
have
to
type
verb
prog
Recall
that
verb
bash
uses
the
verb
PATH
environment
variable
to
find
the
executable
program
file
corresponding
to
the
command
you
have
typed
If
you
simply
typed
verb
prog
verb
bash
would
look
in
each
of
the
directories
found
in
verb
PATH
By
typing
a
command
with
a
slash
verb
in
it
verb
bash
does
not
search
through
those
directories
instead
simply
executing
the
file
as
typed
And
as
we
recall
from
the
section
ref
sec
dotanddotdot
the
directory
verb
simply
means
the
current
directory
so
verb
prog
will
cause
the
executable
file
named
verb
prog
in
the
current
directory
to
be
executed
and
the
verb
in
the
name
turns
off
the
search
by
verb
bash
Of
course
you
could
add
verb
to
the
front
of
verb
PATH
but
this
can
sometimes
cause
trouble
if
you
give
your
program
an
identical
name
to
one
of
the
standard
programs
provided
in
Linux
Having
to
invoke
verb
gcc
twice
to
build
verb
prog
may
seem
like
one
invocation
too
many
In
fact
for
simple
programs
like
verb
prog
c
it
can
all
be
done
in
one
command
as
in
begin
adjustwidth
1cm
small
verb
gcc
o
prog
prog
c
newline
normalsize
end
adjustwidth
The
presence
of
a
verb
c
file
in
the
argument
list
causes
verb
gcc
to
first
compile
it
into
an
object
file
to
then
link
that
object
file
into
the
executable
program
emph
and
to
then
delete
the
object
file
Most
programs
will
consist
of
multiple
source
files
each
providing
different
functionality
like
different
modules
used
in
a
Python
program
As
you
use
the
ECLE
cycle
to
debug
your
program
you
seldom
change
all
of
the
source
files
at
once
usually
you
need
to
change
one
source
file
to
resolve
the
current
bug
that
the
program
is
exhibiting
this
only
requires
that
you
compile
that
particular
source
file
again
and
then
link
all
of
the
object
files
together
into
your
executable
program
file
label
sec
CFLAGS
If
your
C
source
file
has
language
errors
verb
gcc
will
report
these
errors
on
standard
error
output
There
are
a
large
number
of
flags
to
verb
gcc
that
control
the
reporting
of
warnings
regarding
your
usage
of
the
C
language
some
of
these
warnings
are
indicative
of
poor
programming
practices
that
will
likely
lead
to
your
program
executing
incorrectly
Decades
of
experience
recommend
that
you
specify
verb
W
Wall
as
compilation
flags
when
compiling
your
source
files
as
these
warning
flags
will
do
a
reasonable
job
of
reporting
such
poor
programming
practices
Therefore
we
strongly
recommend
that
your
compile
command
lines
look
like
begin
adjustwidth
1cm
small
verb
gcc
c
W
Wall
prog
c
newline
normalsize
end
adjustwidth
The
next
section
describes
a
tool
to
help
you
with
the
ECLE
cycle
automating
the
necessary
recompiles
and
the
relink
of
your
program
after
you
have
made
changes
to
source
files
subsection
texttt
make
a
tool
to
help
you
with
the
ECLE
cycle
index
commands
textbf
commands
make
It
should
be
clear
that
one
can
establish
a
set
of
dependencies
between
the
files
that
make
up
your
executable
program
The
executable
program
file
depends
upon
the
constituent
object
files
if
one
of
them
changes
then
the
program
file
must
be
regenerated
by
relinking
the
object
files
Likewise
each
object
file
depends
upon
its
source
file
if
the
source
file
has
changed
then
the
object
file
must
be
recreated
by
recompiling
the
source
file
since
the
object
file
is
now
changed
the
executable
program
file
must
be
recreated
Clearly
a
tool
that
keeps
track
of
these
and
other
dependencies
and
what
actions
are
required
to
recreate
a
file
that
depends
upon
a
file
that
has
changed
will
be
extremely
useful
verb
make
is
such
a
tool
verb
make
requires
that
you
specify
the
dependencies
between
your
files
It
also
requires
that
you
specify
what
action
to
take
to
recreate
a
dependent
file
when
one
of
the
files
upon
which
it
depends
has
changed
Finally
it
has
built
in
rules
for
the
most
common
types
of
actions
e
g
going
from
a
verb
c
to
a
verb
o
How
can
verb
make
possibly
work
Recall
from
Chapter
2
that
the
file
system
keeps
metadata
about
each
file
and
that
one
such
piece
of
metadata
was
the
modification
date
time
for
the
file
Given
a
specification
of
the
dependencies
between
your
files
verb
make
can
determine
if
a
dependent
file
needs
to
be
recreated
if
the
modification
date
of
any
of
the
files
upon
which
the
dependent
file
depends
has
a
later
modification
date
than
the
dependent
file
Upon
detection
of
such
a
situation
it
then
applies
the
action
that
you
have
specified
for
recreating
the
dependent
file
or
applies
one
of
the
built
in
implicit
rules
to
recreate
the
dependent
file
which
will
of
course
now
have
a
modification
date
later
than
any
of
the
files
upon
which
it
depends
By
convention
we
keep
all
source
files
for
a
related
set
of
programs
in
a
separate
directory
In
that
directory
a
file
named
verb
Makefile
contains
the
specification
of
the
file
dependencies
index
make
textbf
make
Makefile
and
the
actions
that
should
be
taken
Let
s
look
at
an
example
verb
Makefile
for
verb
prog
begin
adjustwidth
1cm
small
verb
CFLAGS
W
Wall
newline
verb
OBJECTS
prog
o
newline
verb
newline
verb
prog
OBJECTS
newline
verb
gcc
o
prog
OBJECTS
newline
verb
newline
verb
prog
o
prog
c
newline
normalsize
end
adjustwidth
What
does
this
mean
Let
s
look
at
each
line
in
turn
begin
itemize
noitemsep
item
verb
CFLAGS
W
Wall
newline
index
make
textbf
make
CFLAGS
variable
The
built
in
rules
for
converting
from
a
C
source
file
to
a
C
object
file
knows
to
look
for
a
variable
named
verb
CFLAGS
if
this
is
defined
it
will
use
it
in
the
verb
gcc
command
to
compile
a
source
file
into
its
object
file
item
verb
OBJECTS
prog
o
newline
index
make
textbf
make
OBJECTS
variable
It
is
good
practice
to
create
a
variable
named
verb
OBJECTS
for
all
of
the
object
files
that
must
be
linked
together
to
create
our
program
In
this
case
there
is
only
one
if
there
had
been
other
files
the
entire
set
would
have
been
listed
as
part
of
the
definition
of
verb
OBJECTS
with
the
files
separated
by
blanks
item
verb
prog
OBJECTS
newline
verb
gcc
o
prog
OBJECTS
newline
The
first
line
says
that
verb
prog
depends
upon
the
definition
of
verb
OBJECTS
since
verb
OBJECTS
is
defined
as
verb
prog
o
this
means
that
verb
prog
depends
upon
verb
prog
o
verb
make
checks
the
modification
date
for
verb
prog
o
if
the
file
does
not
exist
it
looks
for
a
rule
in
the
Makefile
to
see
how
to
create
verb
prog
o
and
executes
that
rule
Armed
with
the
modification
date
for
verb
prog
o
it
compares
it
to
the
modification
date
for
verb
prog
and
if
it
is
newer
executes
the
second
line
which
is
the
rule
used
to
update
verb
prog
Note
that
the
action
lines
must
be
indented
by
a
TAB
character
there
can
be
multiple
action
lines
each
indented
by
a
TAB
an
empty
line
indicates
the
end
of
the
action
lines
associated
with
that
rule
item
verb
prog
o
prog
c
newline
This
indicates
that
verb
prog
o
depends
upon
verb
prog
c
The
absence
of
a
rule
for
updating
verb
prog
o
tells
verb
make
to
use
its
built
in
rule
index
make
textbf
make
built
in
rules
end
itemize
The
lines
starting
with
verb
prog
and
verb
prog
o
define
emph
targets
index
make
textbf
make
target
You
can
ask
verb
make
to
make
one
of
the
targets
defined
in
a
verb
Makefile
by
typing
the
following
command
to
verb
bash
begin
adjustwidth
1cm
small
verb
make
name
of
target
newline
normalsize
end
adjustwidth
In
our
particular
case
we
could
type
any
of
the
following
commands
begin
adjustwidth
1cm
small
verb
make
prog
o
newline
verb
make
prog
newline
verb
make
newline
normalsize
end
adjustwidth
The
first
command
asks
verb
make
to
compile
verb
prog
c
to
produce
verb
prog
o
if
verb
prog
c
is
newer
than
verb
prog
o
The
second
command
asks
verb
make
to
link
verb
prog
o
to
produce
verb
prog
if
verb
prog
o
is
newer
than
verb
prog
as
a
side
effect
if
verb
prog
c
is
newer
than
verb
prog
o
verb
make
would
compile
verb
prog
c
first
and
then
would
have
to
recreate
verb
prog
since
verb
prog
o
has
to
be
newer
than
verb
prog
in
that
case
The
third
command
asks
verb
make
to
produce
the
first
target
that
it
finds
top
to
bottom
in
verb
Makefile
in
this
case
it
would
recreate
verb
prog
if
necessary
If
all
of
our
programs
were
just
a
single
source
file
like
verb
prog
verb
make
might
seem
like
overkill
Usually
your
programs
will
consists
of
several
source
files
and
need
to
link
to
special
libraries
in
such
cases
capturing
the
knowledge
of
the
dependencies
between
files
and
the
actions
to
take
to
update
a
target
if
it
is
older
than
any
of
the
files
upon
which
it
depends
in
a
verb
Makefile
and
using
verb
make
to
make
sure
our
targets
are
up
to
date
is
a
definite
benefit
Let
s
assume
that
the
code
in
verb
prog
c
refers
to
functions
defined
in
verb
a
c
and
verb
b
c
Furthermore
let
s
assume
that
some
global
definitions
needed
by
verb
a
c
and
verb
b
c
are
in
verb
globals
h
footnote
We
will
see
later
how
source
code
can
include
information
from
another
file
thus
establishing
a
dependency
of
the
compiled
object
file
upon
the
included
file
This
yields
the
following
dependency
graph
between
source
files
object
files
and
program
files
begin
center
includegraphics
scale
0
3
c
depgraph
end
center
The
following
verb
Makefile
captures
this
dependency
graph
along
with
any
non
built
in
rules
needed
to
update
a
target
if
it
is
older
than
any
of
its
dependencies
begin
adjustwidth
1cm
small
verb
CFLAGS
W
Wall
newline
verb
OBJECTS
prog
o
a
o
b
o
newline
verb
newline
verb
prog
OBJECTS
newline
verb
gcc
o
prog
OBJECTS
newline
verb
newline
verb
prog
o
prog
c
newline
verb
a
o
a
c
globals
h
newline
verb
b
o
b
c
globals
h
newline
normalsize
end
adjustwidth
What
has
changed
from
our
previous
verb
Makefile
We
have
augmented
the
definition
for
verb
OBJECTS
to
include
verb
a
o
and
verb
b
o
and
we
have
added
dependencies
for
these
two
additional
object
files
Let
s
summarize
what
we
have
learned
so
far
begin
itemize
noitemsep
item
we
store
all
of
the
source
object
and
program
files
for
a
particular
program
in
its
own
directory
item
we
create
a
file
named
verb
Makefile
that
captures
the
dependencies
between
source
object
and
program
files
and
provides
custom
rules
needed
to
update
a
target
if
it
needs
to
be
updated
item
we
define
a
variable
named
verb
CFLAGS
at
the
top
of
the
makefile
to
specify
some
of
the
command
arguments
needed
when
compiling
a
C
source
file
to
its
object
file
item
we
define
a
variable
named
verb
OBJECTS
at
the
top
of
the
makefile
to
collect
together
the
object
file
names
needed
to
build
our
program
item
the
first
target
shows
the
dependency
of
our
program
file
upon
the
objects
and
provides
the
appropriate
verb
gcc
command
to
link
those
together
to
create
our
program
file
item
this
is
followed
by
a
dependency
line
for
each
object
file
showing
the
dependency
upon
the
relevant
source
file
emph
and
any
files
included
by
that
source
file
item
we
do
not
provide
rules
to
perform
the
compilation
instead
relying
upon
the
built
in
rule
within
verb
make
for
compiling
C
source
files
end
itemize
There
are
many
other
things
one
can
specify
in
the
verb
Makefile
which
are
beyond
the
scope
of
this
book
This
final
section
describes
a
couple
of
the
more
common
things
you
will
see
in
makefiles
and
which
you
are
encouraged
to
add
to
your
makefiles
when
appropriate
As
with
our
previous
discussion
we
will
motivate
the
discussion
with
an
example
verb
Makefile
begin
adjustwidth
1cm
small
verb
CFLAGS
W
Wall
newline
verb
OBJECTS
a
o
b
o
newline
verb
PROGRAMS
prog1
prog2
newline
verb
newline
verb
all
PROGRAMS
newline
verb
newline
verb
prog1
prog1
o
OBJECTS
newline
verb
gcc
o
prog1
prog1
o
OBJECTS
newline
verb
newline
verb
prog2
prog2
o
OBJECTS
newline
verb
gcc
o
prog2
prog2
o
OBJECTS
newline
verb
newline
verb
prog1
o
prog1
c
newline
verb
prog2
o
prog2
c
newline
verb
a
o
a
c
globals
h
newline
verb
b
o
b
c
globals
h
newline
verb
newline
verb
clean
newline
verb
rm
f
prog1
o
prog2
o
OBJECTS
PROGRAMS
newline
normalsize
end
adjustwidth
This
is
a
slightly
more
complicated
use
case
we
have
two
programs
verb
prog1
and
verb
prog2
that
use
functions
defined
in
verb
a
c
and
verb
b
c
It
makes
sense
to
build
both
programs
in
the
same
directory
Thus
we
have
made
the
following
changes
to
the
previous
verb
Makefile
begin
itemize
noitemsep
item
verb
OBJECTS
a
o
b
o
newline
we
have
removed
verb
prog
o
from
the
variable
verb
OBJECTS
as
we
only
want
to
capture
here
those
object
files
needed
by
both
programs
index
make
textbf
make
PROGRAMS
variable
item
verb
PROGRAMS
prog1
prog2
newline
we
have
added
a
variable
named
verb
PROGRAMS
in
which
we
can
record
all
of
the
programs
that
can
be
built
by
this
verb
Makefile
we
didn
t
have
to
do
this
but
it
is
good
practice
especially
as
in
the
future
there
is
every
likelihood
that
you
will
add
one
or
more
new
programs
to
this
set
index
make
textbf
make
all
target
item
verb
all
PROGRAMS
newline
we
define
the
first
target
to
be
dependent
upon
all
programs
emph
without
an
update
rule
if
you
type
verb
make
or
verb
make
all
this
will
cause
verb
make
to
check
that
all
of
the
programs
are
up
to
date
and
if
not
bring
them
up
to
date
item
verb
prog1
prog1
o
OBJECTS
newline
verb
gcc
o
prog1
prog1
o
OBJECTS
newline
the
old
dependency
and
rule
for
verb
prog
is
modified
to
build
verb
prog1
note
that
since
we
removed
verb
prog
o
from
verb
OBJECTS
we
have
to
include
verb
prog1
o
in
the
dependency
line
and
the
rule
we
also
add
an
equivalent
target
and
rule
for
verb
prog2
item
verb
prog1
o
prog1
c
newline
verb
prog2
o
prog2
c
newline
we
obviously
need
to
replace
the
old
target
for
verb
prog
o
by
equivalent
targets
for
verb
prog1
o
and
verb
prog2
o
item
verb
clean
newline
index
make
textbf
make
clean
target
verb
rm
f
prog1
o
prog2
o
OBJECTS
PROGRAMS
newline
finally
it
is
common
to
add
a
target
named
verb
clean
when
you
invoke
verb
make
clean
it
executes
the
verb
rm
command
to
remove
all
of
the
object
files
and
the
program
files
leaving
only
the
source
files
and
the
makefile
note
the
verb
f
flag
to
verb
rm
this
has
the
effect
of
preventing
verb
rm
from
asking
you
if
you
are
really
sure
about
removing
the
specified
files
it
also
prevents
it
from
warning
you
if
any
of
the
specified
files
are
not
found
end
itemize
Finally
there
is
often
an
verb
install
target
in
makefiles
we
will
revisit
this
at
the
end
of
this
chapter
index
make
textbf
make
install
target
section
A
simple
example
program
label
sec
approxpi
Recall
that
in
section
3
1
we
introduced
a
simple
program
that
approximates
pi
as
a
truncated
infinite
series
The
code
below
is
a
C
version
of
this
program
index
C
textbf
C
pi
computation
example
begin
adjustwidth
1cm
small
verbatiminput
c
approx
pi
c
normalsize
end
adjustwidth
As
you
can
see
there
are
a
number
of
similarities
between
the
Python
and
C
source
files
as
well
as
a
number
of
differences
The
following
describes
these
similarities
and
differences
begin
itemize
noitemsep
item
The
beginning
of
the
program
is
devoted
to
accessing
functions
and
values
from
other
files
modules
Python
requires
you
to
verb
import
math
in
order
to
access
the
square
root
function
the
floating
point
absolute
value
function
and
the
value
of
pi
it
also
requires
you
to
verb
import
sys
in
order
to
access
the
command
arguments
C
requires
you
to
verb
include
math
h
in
order
to
access
the
square
root
function
the
floating
point
absolute
value
function
and
the
value
of
pi
denoted
verb
M
PI
C
does
not
have
a
syntactic
representation
for
exponentiation
so
verb
math
h
also
defines
a
function
verb
double
pow
double
x
double
y
which
raises
verb
x
to
the
verb
y
textsuperscript
th
power
returning
it
as
a
verb
double
Note
that
in
C
verb
double
is
the
default
representation
of
a
floating
point
number
C
does
not
require
a
special
include
to
access
arguments
since
the
signature
for
verb
main
has
the
number
of
arguments
and
the
arguments
themselves
passed
in
as
values
the
verb
char
argv
argument
simply
states
that
verb
argv
is
a
list
of
character
strings
just
as
verb
sys
argv
is
in
Python
C
also
requires
you
to
verb
include
stdlib
h
in
order
to
access
the
verb
atoi
function
this
converts
a
string
representation
of
a
number
into
an
integer
just
as
the
verb
int
built
in
function
does
in
Python
Finally
C
requires
you
to
verb
include
stdio
h
in
order
to
access
the
verb
printf
function
unlike
index
C
textbf
C
stdio
printf
Python
C
does
not
have
a
built
in
function
to
print
data
on
standard
output
Additionally
verb
printf
acts
like
a
combination
of
Python
s
verb
print
function
and
the
verb
format
method
on
a
string
item
C
requires
that
the
return
type
of
a
function
be
defined
in
its
signature
additionally
sound
use
of
C
demands
that
you
provide
the
type
of
each
argument
to
a
function
Unlike
Python
where
all
lines
of
a
block
must
be
at
the
same
indentation
level
C
uses
curly
braces
verb
to
delimit
a
block
Thus
the
entire
body
of
verb
approx
pi
is
within
a
pair
of
curly
braces
the
body
of
the
verb
for
loop
in
the
function
is
also
within
a
nested
pair
of
curly
braces
C
requires
that
all
variables
be
declared
before
use
Thus
immediately
after
the
signature
line
for
verb
approx
pi
we
declare
variables
named
verb
sum
which
is
a
verb
double
emph
and
initialized
to
verb
0
0
and
verb
i
which
is
an
verb
int
Note
that
immediately
after
the
verb
for
statement
we
also
declare
verb
di
which
is
a
verb
double
and
is
assigned
the
value
of
verb
i
converted
to
a
verb
double
Explicit
casts
from
one
type
to
another
are
done
as
shown
verb
di
is
only
defined
in
the
body
of
the
verb
for
loop
not
outside
of
it
The
computation
of
verb
sum
is
identical
to
our
Python
code
except
that
each
occurrence
of
verb
x
y
had
to
be
converted
to
an
invocation
of
verb
pow
x
y
The
verb
return
is
also
identical
Note
that
each
statement
in
the
function
is
terminated
by
a
semicolon
verb
This
is
because
C
allows
statements
to
span
multiple
lines
as
well
as
allowing
multiple
statements
to
be
placed
on
a
single
line
item
verb
main
is
very
similar
between
the
two
languages
Of
course
in
C
we
need
to
declare
each
variable
before
use
The
call
to
verb
printf
looks
a
bit
strange
the
first
argument
is
like
the
string
template
upon
index
C
textbf
C
stdio
printf
which
we
invoked
the
verb
format
method
in
our
Python
code
although
verb
printf
uses
percent
signs
to
specify
where
an
argument
value
should
be
placed
unlike
the
curly
braces
used
in
Python
Another
difference
is
that
there
is
no
format
specifier
equivalent
to
verb
thus
we
had
to
multiply
the
fractional
difference
by
verb
100
finally
since
verb
is
the
special
character
in
the
format
string
for
verb
printf
we
had
to
double
it
in
order
for
it
to
print
out
a
percent
sign
end
itemize
subsection
Do
they
give
the
same
results
First
let
s
build
a
verb
Makefile
to
construct
our
verb
approx
pi
executable
begin
adjustwidth
1cm
small
verb
CFLAGS
W
Wall
newline
verb
OBJECTS
approx
pi
o
newline
verb
LIBRARIES
lm
newline
verb
newline
verb
approx
pi
OBJECTS
newline
verb
gcc
o
approx
pi
OBJECTS
LIBRARIES
newline
verb
newline
verb
approx
pi
o
approx
pi
c
newline
verb
newline
verb
clean
newline
verb
rm
f
approx
pi
OBJECTS
newline
normalsize
end
adjustwidth
Note
that
we
have
added
another
variable
verb
LIBRARIES
to
the
index
make
textbf
make
LIBRARIES
variable
makefile
To
access
the
library
of
math
routines
one
must
add
verb
lm
to
the
verb
gcc
command
that
builds
verb
approx
pi
By
defining
it
as
a
variable
at
the
top
of
the
makefile
it
is
easy
for
you
to
remember
which
libraries
you
are
using
and
for
you
to
add
additional
libraries
easily
if
your
code
grows
to
use
other
libraries
Routines
accessed
from
verb
stdio
h
and
verb
stdlib
h
are
resolved
from
the
default
system
library
that
verb
gcc
consults
whenever
it
is
linking
together
a
program
Now
let
s
build
verb
approx
pi
and
then
compare
its
output
with
the
output
from
verb
approx
pi
py
begin
adjustwidth
1cm
small
verb
make
newline
verb
cc
W
Wall
c
o
approx
pi
o
approx
pi
c
newline
verb
gcc
o
approx
pi
approx
pi
o
lm
newline
verb
ls
l
approx
pi
newline
verb
rwxr
xr
x
1
me
me
8360
Jul
30
11
49
approx
pi
newline
verb
python3
approx
pi
py
5
newline
verb
pi
5
3
1426047456630846
error
0
03222
newline
verb
approx
pi
5
newline
verb
pi
5
3
1426047456630846
error
0
03222
newline
normalsize
end
adjustwidth
While
these
look
the
same
we
can
use
a
pipeline
and
verb
diff
to
be
completely
sure
as
in
the
following
begin
adjustwidth
1cm
small
verb
python3
approx
pi
py
5
tmp
out
newline
verb
approx
pi
5
diff
tmp
out
newline
verb
rm
f
tmp
out
newline
normalsize
end
adjustwidth
Here
we
have
captured
the
output
from
the
Python
script
into
verb
tmp
out
The
subsequent
pipeline
executes
verb
approx
pi
with
the
same
number
of
terms
of
the
summation
piping
the
output
to
verb
diff
The
bare
hyphen
verb
as
an
argument
to
verb
diff
tells
it
to
use
its
standard
input
thus
verb
diff
compares
its
standard
input
to
verb
tmp
out
The
lack
of
output
from
verb
diff
indicates
that
the
two
files
are
exactly
the
same
We
then
remove
verb
tmp
out
as
good
file
system
hygiene
section
Variables
types
operators
and
expressions
subsection
Variable
names
index
C
textbf
C
variables
index
C
textbf
C
variables
names
The
names
of
variables
in
C
are
made
up
of
alphabetic
letters
digits
and
the
underscore
verb
character
The
first
character
of
a
name
must
be
a
letter
or
an
underscore
you
are
urged
emph
not
to
begin
variable
names
with
an
underscore
as
system
library
routines
often
use
the
underscore
as
the
first
letter
to
avoid
collisions
with
names
you
define
Upper
and
lower
case
letters
are
distinct
Conventional
practice
is
to
use
all
upper
case
for
defined
symbolic
constants
e
g
verb
BUFFER
SIZE
Conventions
for
variables
vary
begin
itemize
noitemsep
item
all
lower
case
in
this
situation
if
you
have
a
variable
name
with
two
or
more
words
use
the
underscore
to
separate
the
words
e
g
verb
modification
time
item
mixed
case
start
lower
for
single
word
variable
names
all
lower
case
for
multi
word
variable
names
use
camel
case
i
e
capitalize
the
first
letter
of
the
2
textsuperscript
nd
and
subsequent
words
e
g
verb
modificationTime
item
mixed
case
start
upper
as
we
shall
see
in
the
next
chapter
we
will
capitalize
the
first
letter
of
each
word
in
the
name
for
an
abstract
data
type
e
g
verb
PriorityQueue
end
itemize
At
least
the
first
31
characters
of
a
variable
name
are
significant
more
on
Linux
but
if
you
are
going
to
port
your
programs
to
other
C
compilers
on
other
operating
systems
the
language
standard
only
guarantees
31
Keywords
in
the
language
such
as
verb
if
verb
else
verb
int
verb
float
are
reserved
words
and
must
be
in
lower
case
In
this
book
we
will
use
mixed
case
start
lower
and
mixed
case
start
upper
in
our
examples
Variables
must
be
declared
before
they
are
used
unlike
in
Python
In
order
to
declare
variables
we
first
need
to
understand
the
data
types
that
C
supports
subsection
Basic
data
types
index
C
textbf
C
data
types
index
C
textbf
C
basic
data
types
C
has
only
a
few
basic
data
types
begin
itemize
noitemsep
item
verb
char
this
is
a
single
byte
capable
of
holding
one
character
in
the
local
character
set
index
C
textbf
C
basic
data
types
char
item
verb
int
this
is
an
integer
typically
reflecting
the
natural
size
of
integers
on
the
machine
index
C
textbf
C
basic
data
types
int
item
verb
float
single
precision
floating
point
index
C
textbf
C
basic
data
types
float
item
verb
double
double
precision
floating
point
index
C
textbf
C
basic
data
types
double
end
itemize
verb
short
and
verb
long
qualifiers
apply
to
integers
for
example
verb
short
int
i
or
index
C
textbf
C
basic
data
types
short
qualifier
verb
long
int
counter
or
even
verb
long
long
int
packetCount
note
that
these
examples
index
C
textbf
C
basic
data
types
long
qualifier
show
how
one
declares
the
type
of
a
variable
in
your
program
The
name
verb
int
can
be
omitted
when
using
the
verb
short
or
verb
long
qualifiers
As
described
above
the
actual
precision
for
an
verb
int
can
vary
from
machine
to
machine
thus
making
it
hard
to
write
completely
portable
source
code
Thus
the
standard
has
specified
that
the
following
are
true
begin
itemize
noitemsep
item
verb
short
int
is
at
least
16
bits
of
precision
item
verb
long
int
is
at
least
32
bits
of
precision
item
verb
long
long
int
is
at
least
64
bits
of
precision
end
itemize
verb
signed
and
verb
unsigned
qualifiers
can
be
applied
to
verb
char
or
any
integer
type
index
C
textbf
C
basic
data
types
signed
qualifier
index
C
textbf
C
basic
data
types
unsigned
qualifier
begin
itemize
noitemsep
item
unsigned
numbers
are
always
positive
or
zero
obeying
the
laws
of
arithmetic
modulo
2
n
where
n
is
the
number
of
bits
in
the
type
item
signed
numbers
vary
from
2
n
1
to
2
n
1
1
obeying
the
laws
of
2s
complement
arithmetic
end
itemize
verb
long
double
specifies
extended
precision
floating
point
it
is
not
often
used
and
will
not
be
used
in
this
book
There
are
standard
header
files
verb
limits
h
and
verb
float
h
that
contain
symbolic
constants
for
all
of
these
sizes
along
with
other
properties
of
the
machine
and
compiler
subsection
Structured
types
index
C
textbf
C
structured
data
types
index
C
textbf
C
structured
data
types
arrays
label
sec
arraytype
C
supports
the
creation
of
arrays
of
a
given
type
accessed
via
indexing
For
example
one
would
declare
an
array
of
texttt
25
integers
as
follows
begin
adjustwidth
1cm
small
verb
int
myArray
25
newline
normalsize
end
adjustwidth
Arrays
indices
start
at
verb
0
thus
the
legal
indices
for
verb
myArray
above
are
verb
0
24
One
refers
to
the
element
at
index
verb
10
as
verb
myArray
10
C
does
emph
not
have
a
special
built
in
type
for
emph
strings
index
C
textbf
C
structured
data
types
strings
Instead
a
emph
string
is
an
array
of
characters
as
in
begin
adjustwidth
1cm
small
verb
char
buf
1024
newline
normalsize
end
adjustwidth
We
will
discuss
strings
in
more
detail
later
in
the
chapter
C
also
supports
the
definition
of
emph
structures
similar
to
data
only
classes
in
Python
We
will
discuss
structures
later
in
this
chapter
subsection
Constants
literals
You
will
need
to
be
able
to
use
literal
values
for
different
types
in
your
program
these
are
usually
index
C
textbf
C
constants
index
C
textbf
C
literals
termed
emph
constants
in
C
The
following
table
indicates
how
to
express
constant
integer
values
for
different
integer
types
begin
center
begin
tabular
l
l
l
hline
signed
integer
texttt
int
texttt
1234
signed
long
integer
texttt
long
texttt
1234L
signed
long
long
integer
texttt
long
long
texttt
1234LL
unsigned
integer
texttt
unsigned
texttt
1234U
unsigned
long
integer
texttt
unsigned
long
texttt
1234UL
unsigned
long
long
integer
texttt
unsigned
long
long
texttt
1234ULL
hline
end
tabular
end
center
Floating
point
constants
contain
a
decimal
point
or
an
exponent
or
both
the
type
of
the
constant
is
verb
double
unless
a
suffix
is
provided
begin
center
begin
tabular
l
l
l
l
l
hline
single
precision
floating
point
texttt
float
texttt
123
4f
texttt
1e
2f
texttt
1
2e7f
double
precision
floating
point
texttt
double
texttt
123
4
texttt
1e
2
texttt
1
2e7
extended
precision
floating
point
texttt
long
double
texttt
123
4L
texttt
1e
2L
texttt
1
2e7L
hline
end
tabular
end
center
subsection
Character
and
string
constants
A
character
constant
is
an
integer
written
as
a
single
character
within
single
quotes
such
as
verb
x
Escape
sequences
such
as
verb
n
are
character
constants
The
following
table
shows
the
legal
escape
sequence
character
constants
begin
center
begin
tabular
l
l
l
l
hline
texttt
textbackslash
a
alert
bell
texttt
textbackslash
b
backspace
texttt
textbackslash
f
formfeed
texttt
textbackslash
n
newline
end
of
line
texttt
textbackslash
r
carriage
return
texttt
textbackslash
t
horizontal
tab
texttt
textbackslash
v
vertical
tab
texttt
textbackslash
textbackslash
backslash
texttt
textbackslash
question
mark
texttt
textbackslash
single
quote
texttt
textbackslash
double
quote
texttt
textbackslash
0
null
end
of
string
hline
end
tabular
end
center
A
string
constant
literal
is
a
sequence
of
0
or
more
characters
surrounded
by
double
quotes
verb
the
quotes
are
emph
not
part
of
the
string
only
serving
to
delimit
the
string
contents
As
described
previously
a
string
is
an
array
of
characters
a
string
constant
is
just
such
an
array
of
characters
with
a
null
character
verb
0
at
the
end
It
is
important
to
understand
the
difference
between
character
and
string
literals
verb
x
is
an
integer
representing
the
numerical
value
of
the
letter
verb
x
in
the
machine
s
character
set
verb
x
is
an
array
of
characters
2
characters
long
consisting
of
verb
x
followed
by
verb
0
Given
what
we
have
seen
so
far
we
can
write
a
simple
function
that
calculates
the
length
of
a
string
begin
adjustwidth
1cm
small
verb
int
strlen
char
s
newline
verb
int
i
len
newline
verb
newline
verb
len
0
newline
verb
for
i
0
s
i
0
i
i
1
newline
verb
len
1
newline
verb
newline
verb
return
len
newline
verb
newline
normalsize
end
adjustwidth
You
should
convince
yourself
that
this
function
works
correctly
if
passed
an
empty
string
i
e
verb
The
production
version
of
verb
strlen
along
with
many
other
useful
index
C
textbf
C
string
functions
strlen
string
manipulation
functions
are
defined
in
verb
string
h
and
can
be
used
if
you
verb
include
string
h
in
your
source
files
subsection
Variable
declarations
index
C
textbf
C
variables
declarations
All
variables
must
be
declared
before
use
Each
declaration
specifies
a
type
and
associates
one
or
more
variable
names
with
that
type
for
example
begin
adjustwidth
1cm
small
verb
int
first
last
step
newline
verb
char
c
buf
1024
newline
normalsize
end
adjustwidth
A
variable
may
be
initialized
in
its
declaration
as
in
index
C
textbf
C
variables
initialization
begin
adjustwidth
1cm
small
verb
int
formatChar
newline
verb
int
bufferSize
MAXBUF
1
newline
verb
char
keyword
expedite
newline
normalsize
end
adjustwidth
The
last
example
above
shows
that
one
does
not
need
to
specify
the
size
of
a
character
array
if
you
are
initializing
it
with
a
string
literal
subsection
Variable
scope
index
C
textbf
C
variables
scope
Variables
can
be
declared
outside
of
any
function
definition
in
which
case
they
are
referred
to
as
emph
external
variables
index
C
textbf
C
variables
scope
external
External
variables
can
be
accessed
by
emph
any
code
in
any
function
in
any
source
file
that
is
linked
together
with
the
file
that
declares
that
external
variable
For
external
variables
initialization
is
done
only
once
before
the
program
starts
to
execute
as
a
result
the
initializer
must
be
a
constant
expression
If
an
external
variable
is
not
explicitly
initialized
it
is
initialized
to
zero
by
default
Variables
declared
at
the
top
of
a
block
after
an
opening
left
curly
brace
verb
are
referred
to
as
emph
automatic
variables
index
C
textbf
C
variables
scope
automatic
An
explicitly
initialized
automatic
variable
is
initialized
each
time
the
defining
block
is
entered
the
initializer
can
be
any
expression
An
automatic
variable
for
which
there
is
no
explicit
initializer
has
an
undefined
value
The
qualifier
verb
const
can
be
applied
to
the
declaration
of
any
variable
to
index
C
textbf
C
variables
const
indicated
that
its
value
will
not
change
as
in
begin
adjustwidth
1cm
small
verb
const
char
errmsg
processing
error
newline
normalsize
end
adjustwidth
verb
const
can
also
be
used
with
arguments
to
functions
to
indicate
that
the
function
does
not
change
that
argument
as
in
begin
adjustwidth
1cm
small
verb
int
strlen
const
char
str
newline
normalsize
end
adjustwidth
subsection
Arithmetic
operators
index
C
textbf
C
arithmetic
operators
The
binary
operators
verb
verb
verb
and
verb
are
defined
for
both
integer
and
floating
point
types
the
modulus
operator
verb
is
also
defined
for
integer
types
For
integers
x
and
y
verb
x
y
yields
the
integral
number
of
times
that
verb
y
goes
into
verb
x
while
verb
x
y
yields
the
remainder
from
that
division
Or
more
succinctly
verb
y
x
y
x
y
is
identical
to
verb
x
subsection
Relational
and
logical
operators
index
C
textbf
C
relational
operators
index
C
textbf
C
logical
operators
C
does
not
possess
a
Boolean
type
C
interprets
an
integer
value
of
0
as
false
and
any
integer
value
that
is
emph
not
0
as
true
The
relational
and
logical
operators
described
below
return
1
when
the
result
is
true
0
when
false
The
following
comparison
operators
when
used
with
numeric
types
generate
boolean
values
begin
center
begin
tabular
l
l
hline
texttt
x
textless
y
x
is
strictly
less
than
y
texttt
x
textless
y
x
is
less
than
or
equal
to
y
texttt
x
textgreater
y
x
is
strictly
greater
than
y
texttt
x
textgreater
y
x
is
greater
than
or
equal
to
y
texttt
x
y
x
is
equal
to
y
texttt
x
y
x
is
not
equal
to
y
hline
end
tabular
end
center
Boolean
values
can
be
combined
using
the
usual
boolean
operators
begin
center
begin
tabular
c
l
p
6cm
hline
texttt
x
y
if
x
is
texttt
False
then
y
else
x
y
is
only
evaluated
if
x
is
texttt
False
texttt
x
y
if
x
is
texttt
False
then
x
else
y
y
is
only
evaluated
if
x
is
texttt
True
texttt
x
if
x
is
texttt
False
then
texttt
True
else
texttt
False
has
lower
priority
than
non
Boolean
operators
so
texttt
a
b
is
interpreted
as
texttt
a
b
hline
end
tabular
end
center
subsection
Type
conversions
label
typeconversions
index
C
textbf
C
type
conversions
When
an
operator
has
operands
of
different
types
they
are
converted
to
a
common
type
according
to
a
small
number
of
rules
In
general
the
only
automatic
conversions
are
those
that
convert
a
narrower
operand
into
a
wider
one
without
losing
information
such
as
converting
an
integer
to
floating
point
in
an
expression
like
verb
f
i
Expressions
that
do
not
make
sense
like
using
a
floating
point
value
as
an
index
into
an
array
are
illegal
and
will
generate
compiler
errors
Expressions
that
might
lose
information
such
as
assigning
a
wider
integer
type
to
a
narrower
one
are
emph
not
illegal
but
will
generate
a
warning
from
the
compiler
to
alert
you
to
the
potential
danger
in
doing
so
Of
particular
importance
is
to
note
that
a
verb
char
is
just
a
small
integer
so
as
unusual
as
it
may
seem
verb
char
variables
and
constants
may
be
freely
used
in
arithmetic
expressions
One
must
exercise
caution
though
as
many
such
uses
make
assumptions
about
contiguity
of
sequences
of
digits
or
letters
or
about
the
relationship
between
lower
and
upper
case
letters
It
is
much
safer
to
rely
upon
functions
in
verb
ctype
h
for
performing
such
manipulations
verb
isalnum
verb
isalpha
verb
iscntrl
verb
isdigit
verb
isgraph
verb
islower
verb
isprint
verb
ispunct
verb
isspace
verb
isupper
verb
isxdigit
verb
tolower
and
verb
toupper
If
a
binary
operator
has
operands
of
different
types
the
narrower
type
is
promoted
to
the
wider
type
before
the
operation
proceeds
and
the
result
is
of
the
wider
type
If
there
are
no
unsigned
operands
the
following
informal
rules
are
followed
begin
adjustwidth
1cm
small
verb
if
either
operand
is
long
double
newline
verb
convert
the
other
to
long
double
newline
verb
else
if
either
operand
is
double
newline
verb
convert
the
other
to
double
newline
verb
else
if
either
operand
is
float
newline
verb
convert
the
other
to
float
newline
verb
else
newline
verb
convert
char
and
short
to
int
newline
verb
if
either
operand
is
long
long
newline
verb
convert
the
other
to
long
long
newline
verb
else
if
either
operand
is
long
newline
verb
convert
the
other
to
long
newline
normalsize
end
adjustwidth
Conversions
take
place
across
assignments
the
value
of
the
right
hand
side
is
converted
to
the
type
of
the
left
hand
side
which
is
the
type
of
the
result
wider
integers
are
converted
to
narrower
ones
by
dropping
the
excess
high
order
bits
Floating
point
to
integer
conversions
cause
truncation
of
any
fractional
part
You
can
avoid
depending
upon
implicit
conversions
by
explicitly
coercing
the
result
of
an
expression
using
a
emph
cast
these
are
of
the
form
verb
textit
type
name
verb
textit
expression
The
result
of
textit
expression
is
converted
to
textit
type
name
using
the
type
conversions
rules
For
example
given
an
integer
verb
N
we
take
its
square
root
by
invoking
verb
sqrt
double
N
In
this
case
the
compiler
converts
the
integral
value
of
verb
N
to
a
verb
double
before
invoking
verb
sqrt
The
cast
produces
the
value
of
verb
N
of
the
proper
type
verb
N
itself
is
not
altered
subsection
Increment
and
decrement
operators
index
C
textbf
C
variables
increment
operator
index
C
textbf
C
variables
decrement
operator
Incrementing
and
decrementing
variables
happens
so
often
in
C
programs
that
there
is
special
syntax
for
it
begin
center
begin
tabular
l
l
hline
texttt
x
adds
texttt
1
to
texttt
x
before
returning
its
value
texttt
x
adds
texttt
1
to
texttt
x
after
returning
its
value
texttt
textminus
textminus
x
subtracts
texttt
1
from
texttt
x
before
returning
its
value
texttt
x
textminus
textminus
subtracts
texttt
1
from
texttt
x
after
returning
its
value
hline
end
tabular
end
center
Consider
the
following
code
fragment
begin
adjustwidth
1cm
small
verb
int
x
y
n
5
newline
verb
newline
verb
x
n
newline
verb
y
n
newline
verb
printf
d
d
d
n
n
x
y
newline
normalsize
end
adjustwidth
What
do
you
think
will
be
printed
out
verb
n
starts
out
as
verb
5
verb
x
n
says
to
assign
the
current
value
of
verb
n
to
verb
x
then
increment
verb
n
this
leaves
verb
x
with
a
value
of
verb
5
and
verb
n
with
a
value
of
verb
6
verb
y
n
says
to
increment
verb
n
and
then
assign
the
value
of
verb
n
to
verb
y
this
leaves
verb
n
with
a
value
of
verb
7
and
verb
y
with
a
value
of
verb
7
Thus
when
verb
printf
is
invoked
we
should
see
the
following
on
standard
index
C
textbf
C
stdio
printf
output
begin
adjustwidth
1cm
small
verb
7
5
7
newline
normalsize
end
adjustwidth
Postfix
autoincrement
verb
x
is
often
used
when
assembling
strings
in
a
character
array
as
in
begin
adjustwidth
1cm
small
verb
if
c
n
newline
verb
buf
i
c
newline
normalsize
end
adjustwidth
It
is
also
used
with
pointers
which
will
be
discussed
later
in
this
chapter
subsection
Assignments
and
assignment
operators
index
C
textbf
C
variables
assignments
Assignment
of
the
value
of
an
expression
to
a
variable
has
the
same
syntax
as
for
Python
except
for
the
required
semicolon
at
the
end
begin
adjustwidth
1cm
small
verb
variable
expression
newline
normalsize
end
adjustwidth
The
entire
assignment
statement
is
also
an
expression
and
returns
a
value
i
e
the
value
that
was
assigned
to
the
variable
As
a
result
the
following
types
of
statements
are
not
only
legal
are
are
examples
of
efficient
and
elegant
C
source
begin
adjustwidth
1cm
small
verb
var1
var2
expression
newline
verb
if
status
fetch
EOF
newline
normalsize
end
adjustwidth
The
first
example
above
simply
shows
that
one
can
assign
the
same
value
to
several
variables
in
a
single
line
this
statement
is
processed
right
to
left
i
e
verb
expression
is
evaluated
and
assigned
to
verb
var2
The
value
of
that
assignment
is
the
value
of
verb
expression
and
this
value
is
assigned
to
verb
var1
The
second
example
shows
invocation
of
the
function
verb
fetch
assigning
its
returned
value
to
verb
status
the
value
of
this
assignment
is
then
compared
to
verb
EOF
to
conditionally
execute
the
body
of
the
verb
if
statement
Besides
normal
assignment
it
is
often
the
case
that
one
wants
to
evaluate
an
expression
then
perform
a
binary
operation
between
a
variable
and
that
expression
and
reassign
the
result
of
that
binary
operation
to
the
variable
We
have
seen
this
in
Python
with
the
verb
syntax
index
C
textbf
C
variables
assignment
operators
C
has
very
rich
support
for
these
emph
assignment
operators
all
of
the
form
verb
variable
op
expression
this
is
equivalent
to
verb
variable
variable
op
expression
except
that
verb
variable
is
only
evaluated
once
The
operators
verb
verb
verb
verb
and
verb
all
have
assignment
operator
forms
footnote
There
are
other
binary
operators
associated
with
bit
manipulation
which
also
have
assignment
operator
forms
Since
we
are
not
covering
bit
manipulation
in
this
book
they
have
not
been
mentioned
in
this
section
As
with
assignments
assignment
operators
have
a
value
the
final
value
of
the
variable
and
can
occur
in
expressions
For
example
begin
adjustwidth
1cm
small
verb
while
n
5
LIMIT
newline
normalsize
end
adjustwidth
subsection
Conditional
expressions
index
C
textbf
C
conditional
expressions
C
has
a
ternary
operator
that
is
useful
in
many
situations
It
has
the
form
index
C
textbf
C
ternary
operator
begin
adjustwidth
1cm
small
verb
x
expr
textsubscript
1
verb
expr
textsubscript
2
verb
expr
textsubscript
3
verb
newline
normalsize
end
adjustwidth
This
is
equivalent
to
begin
adjustwidth
1cm
small
verb
if
expr
textsubscript
1
verb
newline
verb
x
expr
textsubscript
2
verb
newline
verb
else
newline
verb
x
expr
textsubscript
3
verb
newline
verb
newline
normalsize
end
adjustwidth
except
that
it
also
returns
a
value
which
can
be
exploited
in
an
expression
just
like
assignment
and
assignment
operators
You
will
see
examples
of
its
usage
later
in
the
book
section
Control
flow
index
C
textbf
C
control
flow
subsection
Statements
and
blocks
index
C
textbf
C
statement
An
expression
becomes
a
emph
statement
when
it
is
followed
by
a
semicolon
begin
adjustwidth
1cm
small
verb
x
0
newline
verb
i
newline
verb
printf
newline
normalsize
end
adjustwidth
Unlike
some
other
languages
where
the
semicolon
is
a
statement
separator
in
C
the
semicolon
is
a
statement
terminator
index
C
textbf
C
compound
statement
index
C
textbf
C
block
Curly
braces
verb
are
used
to
group
declarations
and
statements
together
into
a
emph
compound
statement
also
known
as
a
emph
block
A
block
is
syntactically
equivalent
to
a
single
statement
subsection
Conditional
execution
texttt
if
else
index
C
textbf
C
control
flow
if
else
As
in
Python
there
are
occasions
where
you
will
want
different
bits
of
code
to
be
executed
depending
upon
the
state
of
your
program
The
syntax
for
verb
if
else
is
begin
adjustwidth
1cm
small
verb
if
expression
newline
verb
statement
textsubscript
1
newline
verb
else
newline
verb
statement
textsubscript
2
newline
normalsize
end
adjustwidth
with
the
verb
else
part
optional
verb
expression
is
evaluated
if
it
is
true
i
e
has
a
non
zero
value
verb
statement
textsubscript
1
is
executed
if
false
verb
statement
textsubscript
2
is
executed
Since
the
verb
else
part
is
optional
there
is
an
ambiguity
when
an
verb
else
is
omitted
from
a
nested
sequence
of
verb
if
s
This
ambiguity
is
resolved
by
associating
the
verb
else
with
the
closest
previous
verb
else
less
verb
if
In
Python
you
were
also
exposed
to
verb
elif
to
perform
multi
way
decisions
In
C
this
is
done
as
follows
begin
adjustwidth
1cm
small
verb
if
expression
textsubscript
1
verb
newline
verb
statement
textsubscript
1
newline
verb
else
if
expression
textsubscript
2
verb
newline
verb
statement
textsubscript
2
newline
verb
else
if
expression
textsubscript
3
verb
newline
verb
statement
textsubscript
3
newline
verb
newline
verb
else
newline
verb
statement
textsubscript
N
newline
normalsize
end
adjustwidth
The
expressions
are
evaluated
in
order
if
any
expression
is
true
the
statement
associated
with
it
is
executed
and
the
processing
of
the
entire
chain
is
terminated
Again
the
trailing
verb
else
can
be
omitted
although
this
is
not
a
particularly
good
idea
if
the
preceding
expressions
capture
all
of
the
legal
situations
then
the
verb
else
clause
can
catch
illegal
usage
of
your
code
subsection
Test
at
the
top
texttt
while
and
texttt
for
index
C
textbf
C
control
flow
while
index
C
textbf
C
control
flow
for
The
safest
way
to
loop
through
code
until
a
terminating
conditions
is
reached
is
to
test
before
entering
the
loop
each
time
Python
enables
this
through
its
verb
while
and
verb
for
statements
C
provides
a
verb
while
statement
that
is
very
similar
to
that
in
Python
C
s
verb
for
statement
on
the
other
hand
is
much
more
general
than
Python
s
begin
wrapfigure
R
0
25
textwidth
centering
includegraphics
scale
0
4
c
WhileBreakContinue
end
wrapfigure
The
syntax
for
the
verb
while
statement
is
as
follows
begin
adjustwidth
1cm
small
verb
while
expression
newline
verb
statement
newline
normalsize
end
adjustwidth
verb
expression
is
evaluated
if
it
is
non
zero
verb
statement
is
executed
and
verb
expression
is
re
evaluated
This
cycle
continues
until
verb
expression
is
zero
at
which
point
execution
resumes
emph
after
verb
statement
C
provides
a
verb
break
statement
that
enables
an
early
exit
from
a
verb
while
index
C
textbf
C
control
flow
break
loop
footnote
texttt
break
can
also
be
used
to
achieve
an
early
exit
from
texttt
for
and
texttt
switch
statements
as
well
The
verb
break
statement
in
a
verb
while
loop
causes
execution
to
resume
after
verb
statement
C
also
provides
a
verb
continue
statement
to
cause
the
next
iteration
of
the
index
C
textbf
C
control
flow
continue
verb
while
loop
in
particular
execution
will
resume
at
the
test
of
verb
expression
footnote
texttt
continue
can
also
be
used
to
cause
the
next
iteration
in
a
texttt
for
statement
as
well
begin
wrapfigure
R
0
25
textwidth
centering
includegraphics
scale
0
4
c
ForBreakContinue
end
wrapfigure
The
syntax
for
the
verb
for
statement
is
as
follows
begin
adjustwidth
1cm
small
verb
for
expr
textsubscript
1
verb
expr
textsubscript
2
verb
expr
textsubscript
3
verb
newline
verb
statement
newline
normalsize
end
adjustwidth
verb
expr
textsubscript
1
is
known
as
the
initialization
field
and
verb
expr
textsubscript
3
is
known
as
the
update
field
This
is
equivalent
to
begin
adjustwidth
1cm
small
verb
expr
textsubscript
1
verb
newline
verb
while
expr
textsubscript
2
verb
newline
verb
statement
newline
verb
expr
textsubscript
3
verb
newline
verb
newline
normalsize
end
adjustwidth
except
that
the
behavior
of
the
verb
continue
statement
differs
in
a
verb
for
loop
a
verb
continue
causes
verb
expr
textsubscript
3
to
be
executed
immediately
and
then
the
test
of
verb
expr
textsubscript
2
While
it
is
possible
to
put
any
legal
C
statements
into
verb
expr
textsubscript
1
and
verb
expr
textsubscript
3
it
is
bad
style
to
force
unrelated
computations
into
these
fields
in
a
verb
for
statement
these
are
best
reserved
for
loop
control
operations
appropriate
to
the
situation
What
happens
if
you
need
to
perform
two
or
more
statements
in
the
initialization
or
update
fields
of
a
verb
for
loop
C
provides
a
emph
comma
operator
that
enables
one
to
specify
multiple
index
C
textbf
C
control
flow
comma
operator
expressions
in
a
statement
a
pair
of
expressions
separated
by
a
comma
verb
is
evaluated
left
to
right
and
the
type
and
value
of
the
results
are
the
type
and
value
of
the
rightmost
expression
The
comma
operator
can
be
used
legally
anywhere
in
your
program
footnote
While
its
use
is
legal
anywhere
such
use
outside
of
the
initialization
and
update
fields
of
a
texttt
for
statement
should
be
avoided
as
it
leads
to
potentially
obscure
code
but
is
most
often
used
in
the
initialization
and
update
fields
of
a
verb
for
statement
as
in
begin
adjustwidth
1cm
small
verb
for
i
0
j
0
i
M
i
j
newline
verb
statement
that
refers
to
i
and
j
newline
normalsize
end
adjustwidth
subsection
Multi
way
decision
based
upon
constants
index
C
textbf
C
control
flow
switch
While
being
very
general
the
multi
way
decision
control
described
above
using
nested
verb
if
else
statements
is
not
particularly
efficient
if
one
is
attempting
to
compare
the
result
of
an
expression
against
a
set
of
constant
values
and
take
different
actions
based
upon
the
result
C
provides
the
verb
switch
statement
to
enable
an
efficient
mechanism
for
such
tests
The
syntax
for
the
verb
switch
statement
is
as
follows
begin
adjustwidth
1cm
small
verb
switch
expression
newline
verb
case
const
expr
textsubscript
1
verb
statements
textsubscript
1
newline
verb
case
const
expr
textsubscript
2
verb
statements
textsubscript
2
newline
verb
case
const
expr
textsubscript
3
verb
statements
textsubscript
3
newline
verb
newline
verb
case
default
statements
textsubscript
N
newline
verb
newline
normalsize
end
adjustwidth
In
the
switch
statement
the
cases
simply
serve
as
labels
If
the
verb
expression
matches
one
of
the
constants
in
a
particular
label
execution
starts
at
the
verb
statements
associated
with
that
verb
case
label
and
continues
emph
until
the
end
of
the
texttt
switch
statement
or
until
it
encounters
a
verb
break
statement
at
which
point
it
will
execute
the
first
statement
after
the
verb
switch
statement
faWarning
Since
the
default
semantics
continue
to
the
end
is
almost
emph
never
what
one
wants
to
happen
it
is
emph
critical
that
you
always
include
a
verb
break
statement
at
the
end
of
the
set
of
statements
associated
with
each
verb
case
label
In
other
words
this
is
how
you
should
use
it
begin
adjustwidth
1cm
small
verb
switch
expression
newline
verb
case
const
expr
textsubscript
1
verb
statements
textsubscript
1
verb
texttt
textbf
break
newline
verb
case
const
expr
textsubscript
2
verb
statements
textsubscript
2
verb
texttt
textbf
break
newline
verb
case
const
expr
textsubscript
3
verb
statements
textsubscript
3
verb
texttt
textbf
break
newline
verb
newline
verb
case
default
statements
textsubscript
N
newline
verb
newline
normalsize
end
adjustwidth
subsection
Labels
and
goto
as
a
last
resort
index
C
textbf
C
control
flow
labels
index
C
textbf
C
control
flow
goto
Most
assembly
languages
and
some
earlier
high
level
languages
support
inserting
labels
in
your
source
code
and
being
able
to
force
execution
to
continue
at
one
of
those
labels
Sound
software
engineering
principles
proscribe
use
of
the
goto
footnote
See
Edgar
Dijkstra
Go
To
Statement
Considered
Harmful
Communications
of
the
ACM
Vol
11
No
3
pp
147
148
March
1968
Unfortunately
sometimes
one
needs
to
abandon
processing
in
some
deeply
nested
control
structure
The
verb
break
statement
enables
us
to
escape
from
the
innermost
loop
or
verb
switch
but
cannot
help
us
if
we
are
several
levels
deep
Thus
labels
and
goto
are
most
commonly
used
in
such
situations
as
depicted
below
begin
adjustwidth
1cm
small
verb
for
newline
verb
for
newline
verb
newline
verb
if
disaster
newline
verb
goto
error
newline
verb
newline
verb
error
code
to
clean
up
the
mess
newline
normalsize
end
adjustwidth
A
label
has
the
same
form
as
a
variable
name
and
is
followed
by
a
colon
verb
A
label
can
be
attached
to
any
statement
emph
in
the
same
function
as
the
verb
goto
statement
The
scope
of
a
label
is
the
entire
function
section
Functions
and
program
structure
index
C
textbf
C
functions
A
C
program
is
composed
of
functions
and
global
data
One
of
the
functions
must
have
the
name
verb
main
as
the
runtime
will
call
that
function
after
index
C
textbf
C
functions
main
it
has
initialized
the
process
in
which
your
program
will
execute
subsection
Functions
Each
function
definition
has
the
following
form
begin
adjustwidth
1cm
small
index
C
textbf
C
functions
generic
signature
verb
return
type
function
name
argument
declarations
newline
verb
declarations
and
statements
newline
verb
newline
normalsize
end
adjustwidth
Various
parts
of
the
function
declaration
may
be
absent
a
minimal
function
declaration
is
begin
adjustwidth
1cm
small
verb
dummy
newline
normalsize
end
adjustwidth
This
function
does
nothing
and
returns
nothing
When
the
return
type
is
omitted
it
defaults
to
verb
int
Code
that
is
dependent
upon
this
default
behavior
is
very
dangerous
good
software
engineering
practice
dictates
that
one
must
emph
always
use
index
C
textbf
C
functions
prototypes
function
prototypes
to
declare
the
types
of
the
function
arguments
and
its
return
type
as
this
enables
the
compiler
to
make
sure
that
you
are
using
the
function
correctly
Communication
between
functions
is
via
arguments
to
and
return
values
from
a
function
functions
can
also
communicate
through
external
global
data
variables
index
C
textbf
C
functions
order
Functions
can
occur
in
any
order
in
the
source
file
and
the
source
program
can
be
split
into
multiple
files
A
single
function
must
be
completely
defined
in
a
single
source
file
i
e
it
emph
cannot
be
split
over
two
or
more
files
index
C
textbf
C
functions
pre
declaration
One
can
pre
declare
function
signatures
in
a
source
file
to
guarantee
that
their
use
in
the
source
file
are
type
correct
alternatively
the
functions
can
be
defined
in
an
order
that
guarantees
that
a
function
is
defined
prior
to
first
use
in
the
source
file
Returning
a
value
from
a
function
to
its
caller
is
achieved
via
the
verb
return
statement
index
C
textbf
C
functions
returning
function
value
begin
adjustwidth
1cm
small
verb
return
expression
newline
normalsize
end
adjustwidth
The
calling
function
is
free
to
ignore
the
returned
value
although
this
is
not
good
software
engineering
practice
footnote
If
you
are
explicitly
ignoring
the
return
value
from
a
function
you
should
indicate
this
by
casting
see
Section
ref
typeconversions
the
return
result
to
texttt
void
An
verb
expression
is
not
required
after
the
verb
return
keyword
in
such
a
situation
no
value
is
returned
to
the
caller
Control
also
returns
to
the
caller
with
no
return
value
if
execution
encounters
the
closing
verb
in
the
function
definition
It
is
not
illegal
but
most
likely
a
sign
of
trouble
if
a
function
returns
a
value
in
one
place
but
not
in
another
If
a
function
fails
to
return
a
value
its
value
if
checked
by
the
caller
is
most
definitely
garbage
subsection
An
example
program
Let
s
construct
a
program
to
print
each
line
of
standard
input
that
contains
a
particular
pattern
or
string
of
characters
a
limited
version
of
the
Linux
verb
grep
program
The
main
program
falls
neatly
into
three
pieces
begin
adjustwidth
1cm
small
textit
while
there
s
another
line
newline
verb
textit
if
the
line
contains
the
pattern
newline
verb
textit
print
the
line
newline
normalsize
end
adjustwidth
The
textit
print
the
line
is
simply
a
call
to
verb
printf
defined
in
verb
stdio
h
index
C
textbf
C
stdio
printf
The
textit
while
there
s
another
line
is
a
call
to
a
function
verb
fgets
defined
in
verb
stdio
h
index
C
textbf
C
stdio
fgets
Its
signature
is
the
following
begin
adjustwidth
1cm
small
verb
char
fgets
char
buf
int
size
FILE
stream
newline
normalsize
end
adjustwidth
You
pass
verb
fgets
a
character
array
verb
buf
the
size
of
that
array
verb
size
and
a
stream
of
characters
from
an
open
file
verb
stream
Each
time
verb
fgets
is
called
it
copies
the
next
line
of
input
from
verb
stream
into
verb
buf
and
places
verb
0
after
the
line
so
that
verb
buf
is
a
legal
string
in
C
if
it
copied
a
line
into
verb
buf
it
returns
the
address
of
verb
buf
as
its
function
value
If
there
are
no
more
lines
on
verb
stream
when
verb
fgets
is
called
it
returns
verb
NULL
as
its
function
value
and
does
nothing
to
verb
buf
verb
fgets
is
similar
to
the
verb
readline
function
in
Python
except
that
you
have
to
provide
verb
fgets
with
a
buffer
into
which
the
next
line
of
input
is
copied
Thus
our
verb
main
is
starting
to
look
as
follows
begin
adjustwidth
1cm
small
verb
include
stdio
h
newline
verb
newline
verb
define
BUFSIZE
1024
newline
verb
newline
verb
define
UNUSED
attribute
unused
newline
verb
newline
verb
int
main
UNUSED
int
argc
UNUSED
char
argv
newline
verb
char
buf
BUFSIZE
newline
verb
newline
verb
while
fgets
buf
BUFSIZE
stdin
NULL
newline
verb
textit
if
the
line
contains
the
pattern
newline
verb
printf
s
buf
newline
verb
newline
verb
newline
normalsize
end
adjustwidth
In
fact
if
you
simply
delete
the
textit
if
the
line
contains
the
pattern
from
this
program
you
will
have
a
filter
that
simply
copies
its
standard
input
to
its
standard
output
What
s
the
odd
definition
for
verb
UNUSED
and
why
do
we
use
it
in
the
signature
for
verb
main
We
previously
advised
that
the
warning
flags
to
specify
when
compiling
with
verb
gcc
are
verb
W
Wall
One
of
the
warnings
that
will
be
generated
with
these
flags
is
if
there
is
a
function
parameter
or
an
automatic
variable
that
is
emph
not
referenced
in
the
function
in
general
such
a
situation
may
be
a
strong
indication
of
a
problem
in
your
code
verb
gcc
has
provided
a
set
of
extensions
for
specifying
attributes
in
your
source
code
one
of
those
attributes
enables
you
to
indicate
that
a
particular
parameter
or
variable
is
unused
emph
on
purpose
If
you
flag
a
parameter
or
variable
with
this
attribute
verb
gcc
will
not
issue
the
corresponding
warning
since
you
have
proactively
indicated
that
it
will
not
be
used
In
our
case
we
are
not
using
the
command
arguments
so
flagging
verb
argc
and
verb
argv
as
unused
is
appropriate
So
how
do
we
determine
if
one
string
is
included
in
another
string
We
could
write
a
function
to
do
this
and
we
will
show
this
later
But
in
the
meantime
we
should
look
in
verb
string
h
to
see
if
such
a
function
has
been
supplied
by
the
runtime
system
This
can
be
easily
done
by
asking
your
search
engine
to
look
for
linux
man
string
somewhere
in
the
first
few
results
of
the
search
you
will
see
an
entry
entitled
string
3
Linux
manual
page
man7
org
A
perusal
of
that
page
will
yield
the
signature
index
C
textbf
C
string
functions
strstr
begin
adjustwidth
1cm
small
verb
char
strstr
const
char
haystack
const
char
needle
newline
normalsize
end
adjustwidth
seemingly
just
the
function
we
need
Clicking
on
the
link
for
verb
strstr
3
in
the
SEE
ALSO
section
gets
us
to
the
man
page
for
verb
strstr
which
indicates
that
it
returns
verb
NULL
if
verb
needle
is
emph
not
contained
in
verb
haystack
and
the
address
of
the
location
in
verb
haystack
where
verb
needle
is
first
found
if
it
is
Thus
our
completed
program
named
verb
find
c
looks
as
follows
begin
adjustwidth
1cm
small
verb
include
stdio
h
newline
verb
include
string
h
newline
verb
newline
verb
define
BUFSIZE
1024
newline
verb
newline
verb
define
UNUSED
attribute
unused
newline
verb
newline
verb
int
main
UNUSED
int
argc
UNUSED
char
argv
newline
verb
char
buf
BUFSIZE
newline
verb
char
pattern
ould
pattern
to
search
for
newline
verb
newline
verb
while
fgets
buf
BUFSIZE
stdin
NULL
newline
verb
if
strstr
buf
pattern
NULL
newline
verb
printf
s
buf
newline
verb
newline
verb
return
0
newline
verb
newline
normalsize
end
adjustwidth
A
program
that
has
a
static
pattern
to
search
for
is
not
particularly
useful
as
we
would
have
to
edit
and
recompile
the
program
to
search
for
other
patterns
We
will
look
at
how
to
make
the
program
more
dynamic
later
in
the
chapter
subsection
External
variables
index
C
textbf
C
variables
external
A
C
program
consists
of
a
set
of
external
objects
which
are
either
variables
or
functions
External
variables
are
defined
outside
of
any
function
and
are
thus
potentially
accessible
by
many
functions
Functions
are
emph
always
external
since
C
does
not
permit
functions
to
be
defined
inside
of
other
functions
External
variables
and
functions
have
the
property
that
all
references
to
them
using
the
same
name
even
from
functions
compiled
separately
are
references
to
the
same
thing
The
emph
scope
of
a
name
is
the
part
of
the
program
within
which
the
name
can
be
used
For
an
automatic
variable
declared
at
the
beginning
of
a
block
the
scope
is
the
block
in
which
the
name
is
declared
The
scope
of
an
external
variable
or
a
function
lasts
from
the
point
at
which
it
is
declared
to
the
end
of
the
file
being
compiled
If
an
external
variable
is
to
be
referenced
before
it
is
defined
or
it
is
defined
in
a
different
source
index
C
textbf
C
variables
external
extern
declaration
file
from
the
one
in
which
it
is
being
used
then
an
verb
extern
declaration
is
required
It
is
important
to
distinguish
between
the
emph
declaration
of
an
external
variable
and
its
index
C
textbf
C
variables
external
extern
definition
emph
definition
A
declaration
announces
the
properties
of
a
variable
primarily
its
type
a
definition
also
causes
storage
to
be
set
aside
for
the
variable
For
example
if
the
lines
begin
adjustwidth
1cm
small
verb
int
sp
newline
verb
double
val
MAXVAL
newline
normalsize
end
adjustwidth
appear
outside
of
any
function
they
define
the
external
variables
verb
sp
and
verb
val
cause
storage
to
be
set
aside
for
each
of
them
and
serve
as
a
declaration
for
the
rest
of
that
source
file
On
the
other
hand
the
lines
begin
adjustwidth
1cm
small
verb
extern
int
sp
newline
verb
extern
double
val
newline
normalsize
end
adjustwidth
declare
for
the
rest
of
the
source
file
that
verb
sp
is
an
verb
int
and
that
verb
val
is
a
verb
double
array
they
do
not
create
the
variables
or
reserve
storage
for
them
Only
one
definition
of
an
external
variable
is
allowed
among
all
of
the
files
that
make
up
a
program
initialization
is
restricted
to
that
single
definition
subsection
Static
variables
index
C
textbf
C
variables
static
index
C
textbf
C
variables
external
static
External
variables
enable
two
types
of
access
to
named
storage
1
by
functions
within
a
source
file
and
2
by
functions
in
other
source
files
Often
we
require
external
storage
so
that
functions
within
a
file
can
share
but
wish
to
hide
that
information
from
functions
in
other
source
files
The
keyword
verb
static
if
prefixed
to
external
variable
definitions
achieves
this
level
of
hiding
i
e
all
functions
in
the
source
file
can
access
the
static
variables
but
they
are
hidden
from
functions
in
other
source
files
The
following
example
declarations
begin
adjustwidth
1cm
small
verb
static
int
sp
newline
verb
static
double
val
MAXVAL
newline
normalsize
end
adjustwidth
define
the
types
and
cause
storage
to
be
created
for
verb
sp
and
verb
val
These
variables
can
only
be
accessed
by
functions
in
the
source
file
where
these
declarations
occur
External
static
declarations
can
be
used
for
functions
as
well
index
C
textbf
C
functions
static
If
a
function
is
declared
verb
static
its
name
is
emph
invisible
outside
of
the
file
in
which
it
is
declared
We
will
exploit
verb
static
functions
in
later
chapters
when
defining
abstract
data
type
methods
Finally
verb
static
can
also
be
applied
to
variables
declared
within
functions
index
C
textbf
C
variables
automatic
static
Internal
verb
static
variables
are
only
visible
within
the
function
in
which
they
are
declared
just
as
automatic
variables
unlike
automatics
the
verb
static
variables
retain
their
values
across
calls
to
the
defining
function
The
following
example
shows
a
typical
use
of
an
internal
verb
static
variable
begin
adjustwidth
1cm
small
verb
int
someFunction
void
newline
verb
static
int
initialized
0
newline
verb
newline
verb
if
initialized
newline
verb
initialized
newline
verb
perform
required
initialization
newline
verb
newline
verb
logic
of
someFunction
newline
verb
return
appropriate
value
newline
verb
newline
normalsize
end
adjustwidth
subsection
Header
files
index
C
textbf
C
header
files
We
use
header
files
ending
in
verb
h
to
specify
types
symbolic
constants
and
function
prototypes
We
use
source
files
ending
in
verb
c
to
define
and
initialize
external
variables
and
define
index
C
textbf
C
source
files
functions
In
our
pattern
matching
program
we
included
verb
stdio
h
which
defined
the
variable
verb
stdin
and
the
functions
verb
fgets
and
verb
printf
we
also
included
verb
string
h
which
defined
index
C
textbf
C
stdio
printf
index
C
textbf
C
stdio
fgets
the
function
verb
strstr
Let
s
suppose
that
we
wish
to
replace
our
call
to
verb
strstr
by
our
own
function
with
the
signature
begin
adjustwidth
1cm
small
verb
int
isSubString
const
char
needle
const
char
haystack
newline
normalsize
end
adjustwidth
where
verb
isSubString
returns
1
true
if
verb
needle
is
contained
in
verb
haystack
and
0
false
if
not
We
will
create
two
files
verb
issubstring
h
which
defines
the
function
signature
and
verb
issubstring
c
which
implements
the
function
begin
adjustwidth
1cm
small
textbf
issubstring
h
newline
verb
int
isSubString
const
char
needle
const
char
haystack
newline
verb
newline
textbf
issubstring
c
newline
verb
include
issubstring
h
newline
verb
include
string
h
newline
verb
newline
verb
int
isSubString
const
char
needle
const
char
haystack
newline
verb
return
strstr
haystack
needle
NULL
newline
verb
newline
normalsize
end
adjustwidth
Admittedly
verb
isSubString
is
a
very
simple
function
simply
using
verb
strstr
to
do
the
hard
work
and
returning
the
correct
return
type
Note
that
our
source
file
includes
the
header
file
using
quotes
verb
around
the
name
instead
of
angle
brackets
verb
files
included
using
angle
brackets
are
searched
for
in
standard
directories
in
the
file
system
files
included
using
quotes
are
first
searched
for
in
the
current
directory
then
in
the
standard
directories
You
may
ask
why
include
the
header
file
in
the
source
This
guarantees
that
the
file
signature
defined
in
the
header
which
will
be
used
by
other
files
is
identical
to
that
defined
in
the
source
Our
main
program
verb
find
c
must
now
look
as
follows
begin
adjustwidth
1cm
small
verb
include
issubstring
h
newline
verb
include
stdio
h
newline
verb
newline
verb
define
BUFSIZE
1024
newline
verb
newline
verb
define
UNUSED
attribute
unused
newline
verb
newline
verb
int
main
UNUSED
int
argc
UNUSED
char
argv
newline
verb
char
buf
BUFSIZE
newline
verb
char
pattern
ould
pattern
to
search
for
newline
verb
newline
verb
while
fgets
buf
BUFSIZE
stdin
NULL
newline
verb
if
isSubString
pattern
buf
newline
verb
printf
s
buf
newline
verb
newline
verb
return
0
newline
verb
newline
normalsize
end
adjustwidth
We
no
longer
need
to
include
verb
string
h
here
since
this
code
does
not
use
verb
strstr
It
does
need
to
include
verb
issubstring
h
since
we
are
now
calling
that
function
And
obviously
we
replace
the
call
to
verb
strstr
with
a
call
to
verb
isSubString
All
that
is
left
to
support
ease
of
building
and
debugging
is
to
create
a
Makefile
for
our
pattern
matching
program
begin
adjustwidth
1cm
small
verb
CFLAGS
W
Wall
newline
verb
OBJECTS
find
o
issubstring
o
newline
verb
newline
verb
find
OBJECTS
newline
verb
gcc
o
find
OBJECTS
newline
verb
newline
verb
find
o
find
c
issubstring
h
newline
verb
issubstring
o
issubstring
c
issubstring
h
newline
verb
newline
verb
clean
newline
verb
rm
f
OBJECTS
find
newline
normalsize
end
adjustwidth
You
might
ask
Why
indicate
a
dependency
for
verb
find
o
upon
verb
issubstring
h
but
not
for
verb
stdio
h
The
standard
include
files
are
very
stable
and
do
not
change
Our
local
include
files
on
the
other
hand
are
likely
to
change
as
we
debug
the
program
Thus
we
want
verb
make
to
include
our
local
include
files
in
the
dependency
graph
Now
let
s
eliminate
the
dependence
of
verb
find
on
a
compiled
pattern
We
want
our
program
to
take
a
single
argument
which
is
the
pattern
we
wish
to
look
for
Here
is
the
absolute
final
version
of
verb
find
c
begin
adjustwidth
1cm
small
verb
include
issubstring
h
newline
verb
include
stdio
h
newline
verb
newline
verb
define
BUFSIZE
1024
newline
verb
newline
verb
int
main
int
argc
char
argv
newline
verb
char
buf
BUFSIZE
newline
verb
char
pattern
pattern
to
search
for
taken
from
argv
1
newline
verb
newline
verb
if
argc
2
newline
verb
printf
usage
s
pattern
n
argv
0
newline
verb
return
1
newline
verb
newline
verb
pattern
argv
1
newline
verb
while
fgets
buf
BUFSIZE
stdin
NULL
newline
verb
if
isSubString
pattern
buf
newline
verb
printf
s
buf
newline
verb
newline
verb
return
0
newline
verb
newline
normalsize
end
adjustwidth
Note
that
we
removed
the
verb
define
of
verb
UNUSED
as
well
as
application
of
that
attribute
to
verb
argc
and
verb
argv
since
we
emph
are
using
the
argument
parameters
We
first
check
that
the
user
has
provided
a
pattern
argument
by
comparing
verb
argc
with
the
value
verb
2
remember
that
verb
argv
0
is
the
command
name
specified
in
the
verb
bash
command
line
and
verb
argv
1
is
the
first
real
argument
to
the
program
If
the
user
has
either
not
specified
the
pattern
or
provided
too
many
arguments
we
remind
the
user
of
the
correct
command
line
and
return
a
non
zero
value
indicating
an
error
Otherwise
we
use
the
pattern
in
argv
1
subsection
Block
structure
While
functions
emph
cannot
be
defined
inside
of
other
functions
variables
can
be
defined
in
a
block
structured
fashion
within
a
function
Declarations
of
variables
including
initializations
can
follow
the
left
brace
verb
that
introduces
any
compound
statement
not
just
the
one
that
begins
a
function
Variables
declared
in
this
way
hide
any
identically
named
variables
in
outer
blocks
and
remain
in
existence
until
the
matching
right
brace
verb
Good
software
engineering
practice
recommends
that
you
avoid
variable
names
that
conceal
names
in
an
outer
scope
as
the
potential
for
confusion
and
error
is
too
great
Consider
the
following
example
what
number
will
be
printed
out
begin
adjustwidth
1cm
small
verb
include
stdio
h
newline
verb
newline
verb
int
number
42
newline
verb
newline
verb
int
main
int
argc
char
argv
newline
verb
int
number
10
newline
verb
int
i
j
newline
verb
newline
verb
i
5
newline
verb
j
23
newline
verb
int
number
newline
verb
newline
verb
for
number
i
number
j
number
newline
verb
newline
verb
newline
verb
printf
d
n
number
newline
verb
return
0
newline
verb
newline
normalsize
end
adjustwidth
subsection
Initialization
In
the
absence
of
explicit
initialization
external
and
static
variables
are
guaranteed
to
be
initialized
index
C
textbf
C
variables
initialization
to
zero
Automatic
variables
have
undefined
initial
value
i
e
in
the
absence
of
explicit
initialization
they
should
be
assumed
to
contain
garbage
Scalar
variables
can
be
initialized
when
they
are
defined
by
following
the
name
with
verb
and
an
expression
For
external
and
static
variables
the
initializer
emph
must
be
a
constant
expression
the
initialization
is
done
once
before
the
program
begins
execution
For
automatic
variables
the
initializer
is
not
restricted
to
being
a
constant
it
may
be
any
expression
involving
previously
defined
values
even
function
calls
the
explicit
initialization
of
automatic
variables
is
performed
each
time
the
function
or
block
is
entered
An
array
may
be
initialized
by
following
its
declaration
with
a
list
of
initializers
enclosed
in
braces
and
separated
by
commas
as
in
begin
adjustwidth
1cm
small
verb
int
days
31
28
31
30
31
30
31
31
30
31
30
31
newline
normalsize
end
adjustwidth
If
the
size
of
the
array
is
omitted
as
in
this
example
the
compiler
computes
the
length
of
the
array
from
the
number
of
initializers
If
the
size
of
array
is
specified
and
there
are
fewer
initializers
than
its
declared
size
the
missing
elements
will
be
zero
for
external
static
and
automatic
variables
If
there
are
more
initializers
than
elements
in
the
array
a
compiler
error
is
generated
C
does
not
maintain
the
length
of
an
array
at
runtime
unlike
Python
When
using
an
initialization
as
for
verb
days
above
your
code
may
need
to
know
the
number
of
elements
that
the
compiler
actually
created
There
are
two
common
ways
to
do
this
begin
itemize
noitemsep
item
you
can
append
a
value
to
the
list
of
initializers
that
is
obviously
different
from
the
others
e
g
a
verb
1
in
verb
days
such
that
at
runtime
you
can
count
the
number
of
items
in
the
array
until
hitting
the
terminating
value
such
a
value
is
called
a
emph
sentinel
or
item
a
more
C
savvy
way
to
do
this
is
to
use
the
verb
sizeof
compile
time
operator
to
define
a
index
C
textbf
C
sizeof
compile
time
operator
constant
that
is
the
length
of
the
array
verb
sizeof
type
name
is
replaced
at
compile
time
with
the
number
of
bytes
that
an
instance
of
verb
type
name
will
occupy
in
memory
verb
sizeof
variable
name
is
replaced
at
compile
time
with
the
number
of
bytes
that
the
variable
will
occupy
in
memory
the
following
code
shows
how
to
exploit
this
to
yield
a
defined
constant
that
is
the
size
of
verb
days
begin
adjustwidth
1cm
small
verb
int
days
31
28
31
30
31
30
31
31
30
31
30
31
newline
verb
define
DAYS
LENGTH
sizeof
days
sizeof
int
newline
normalsize
end
adjustwidth
Your
code
may
refer
to
verb
DAYS
LENGTH
whenever
it
needs
to
limit
its
accesses
to
the
legal
index
values
end
itemize
subsection
The
C
preprocessor
Every
C
compiler
consists
of
multiple
passes
index
C
textbf
C
preprocessor
The
preprocessor
is
the
first
pass
of
the
compiler
during
this
pass
the
preprocessor
replaces
commands
that
it
understands
with
other
text
obtained
from
other
files
or
from
symbolic
constants
The
commands
that
are
understood
are
verb
include
verb
define
verb
if
and
verb
ifdef
subsubsection
File
inclusion
index
C
textbf
C
preprocessor
include
We
have
already
encountered
this
earlier
Any
source
line
of
the
form
begin
adjustwidth
1cm
small
verb
include
filename
newline
verb
include
filename
newline
normalsize
end
adjustwidth
is
emph
replaced
by
the
contents
of
verb
filename
If
verb
filename
is
delimited
by
quotes
the
file
is
first
search
for
in
the
directory
where
the
source
file
is
found
If
it
is
not
found
there
or
if
verb
filename
is
delimited
by
angle
brackets
known
directories
are
searched
for
verb
filename
An
included
file
may
itself
contain
verb
include
lines
File
inclusion
has
very
different
semantics
from
verb
import
statements
in
Python
Python
verb
import
explicitly
brings
in
names
from
the
referenced
modules
File
inclusion
simply
replaces
each
verb
include
statement
with
the
contents
of
that
file
There
are
often
several
verb
include
lines
at
the
beginning
of
a
source
file
These
include
common
verb
define
statements
and
extern
declarations
or
access
to
function
prototype
declarations
such
as
verb
stdio
h
verb
include
is
the
preferred
way
to
tie
the
declarations
together
for
a
large
program
Note
that
when
an
included
file
is
changed
all
files
that
depend
upon
the
included
file
must
be
recompiled
subsubsection
Macro
substitution
index
C
textbf
C
preprocessor
define
A
macro
definition
has
the
form
begin
adjustwidth
1cm
small
verb
define
name
replacement
text
newline
normalsize
end
adjustwidth
Subsequent
occurrences
of
verb
name
in
the
source
file
will
be
replaced
by
verb
replacement
text
verb
name
has
the
same
form
as
a
C
variable
name
while
verb
replacement
text
is
arbitrary
Normally
verb
replacement
text
is
the
rest
of
the
macro
definition
line
a
long
definition
may
be
continued
onto
several
lines
by
placing
a
verb
at
the
end
of
each
line
to
be
continued
The
scope
of
verb
name
is
from
the
point
of
definition
to
the
end
of
the
source
file
being
compiled
A
macro
definition
may
use
previous
definitions
Substitutions
do
emph
not
take
place
within
quoted
strings
i
e
if
verb
YES
is
a
defined
macro
name
there
would
be
no
substitution
in
verb
printf
YES
or
verb
YESMAN
A
name
may
be
defined
with
absolutely
any
replacement
text
for
example
the
following
is
legal
and
often
used
begin
adjustwidth
1cm
small
verb
define
forever
for
infinite
loop
newline
normalsize
end
adjustwidth
Macros
can
be
defined
with
arguments
as
in
begin
adjustwidth
1cm
small
verb
define
max
A
B
A
B
A
B
newline
normalsize
end
adjustwidth
When
invoked
in
your
code
although
it
looks
like
a
function
call
verb
max
expands
into
in
line
code
Each
occurrence
of
a
formal
parameter
to
the
macro
is
replaced
by
the
corresponding
actual
argument
Therefore
begin
adjustwidth
1cm
small
verb
x
max
p
q
r
s
newline
newline
becomes
newline
newline
verb
x
p
q
r
s
p
q
r
s
newline
normalsize
end
adjustwidth
If
an
expression
causes
side
effects
e
g
verb
n
macros
can
give
the
wrong
results
for
example
verb
x
max
i
j
will
yield
the
wrong
results
as
the
larger
of
verb
i
or
verb
j
will
be
incremented
twice
As
you
may
have
noticed
in
our
verb
max
example
you
must
also
be
extremely
generous
with
parentheses
to
make
sure
that
the
appropriate
order
of
evaluation
is
preserved
For
example
if
we
define
begin
adjustwidth
1cm
small
verb
define
square
x
x
x
newline
newline
what
happens
if
we
invoke
newline
newline
verb
square
z
1
newline
normalsize
end
adjustwidth
begin
exercise
small
newline
Fix
the
definition
of
verb
square
in
order
to
obtain
the
correct
results
newline
Box
normalsize
end
exercise
subsubsection
Conditional
evaluation
There
are
a
number
of
statements
that
are
used
to
control
preprocessing
index
C
textbf
C
preprocessor
if
thus
providing
a
way
to
include
code
selectively
depending
upon
the
value
of
conditions
evaluated
during
compilation
verb
if
evaluates
a
constant
integer
expression
the
expression
may
emph
not
include
verb
sizeof
or
casts
index
C
textbf
C
preprocessor
endif
index
C
textbf
C
preprocessor
elif
index
C
textbf
C
preprocessor
else
If
the
expression
is
non
zero
subsequent
lines
until
an
verb
endif
or
verb
elif
or
verb
else
are
processed
if
the
expression
is
zero
begin
itemize
noitemsep
item
if
an
verb
elif
expr1
is
found
then
verb
expr1
is
evaluated
if
non
zero
subsequent
lines
until
an
verb
endif
elif
else
are
processed
if
zero
repeat
this
step
item
if
an
verb
else
is
found
then
subsequent
lines
until
an
verb
endif
are
processed
end
itemize
The
expression
verb
defined
name
is
verb
1
0
if
verb
name
is
defined
not
index
C
textbf
C
preprocessor
defined
If
the
contents
of
a
header
file
are
included
more
than
once
while
compiling
a
source
file
it
can
index
C
textbf
C
header
files
multiple
inclusion
lead
to
all
kinds
of
difficulties
To
make
sure
that
the
contents
of
a
header
file
e
g
verb
hdr
h
are
included
only
once
verb
hdr
h
surrounds
the
actual
contents
with
a
conditional
like
this
begin
adjustwidth
1cm
small
verb
if
defined
HDR
H
newline
verb
define
HDR
H
newline
newline
verb
actual
contents
of
hdr
h
go
here
newline
newline
verb
endif
HDR
H
newline
normalsize
end
adjustwidth
This
allows
header
files
to
include
all
other
header
files
upon
which
it
depends
without
having
to
worry
about
multiple
inclusions
of
some
common
header
files
All
of
the
standard
header
files
e
g
verb
stdio
h
do
this
you
should
do
this
with
your
header
files
as
well
There
is
nothing
special
about
using
verb
HDR
H
as
the
defined
symbol
to
indicate
that
the
file
has
been
included
you
just
need
to
pick
a
name
that
will
not
collide
with
other
defined
constants
Leading
and
trailing
underscores
replacing
the
verb
by
an
underscore
and
converting
all
letters
to
upper
case
is
a
common
approach
used
by
C
and
C
programmers
The
verb
elif
construct
is
to
enable
a
switch
like
choice
of
lines
to
process
as
in
begin
adjustwidth
1cm
small
verb
if
SYSTEM
OSX
newline
verb
define
HDR
osx
h
newline
verb
elif
SYSTEM
LINUX
newline
verb
define
HDR
linux
h
newline
verb
elif
SYSTEM
WINDOWS
newline
verb
define
HDR
windows
h
newline
verb
else
newline
verb
define
HDR
default
h
newline
verb
endif
SYSTEM
newline
verb
include
HDR
newline
normalsize
end
adjustwidth
Finally
verb
ifdef
name
is
a
synonym
for
verb
if
defined
name
and
index
C
textbf
C
preprocessor
ifdef
index
C
textbf
C
preprocessor
ifndef
verb
ifndef
name
is
a
synonym
for
verb
if
defined
name
section
Pointers
and
arrays
index
C
textbf
C
data
types
pointers
Up
to
this
point
it
is
not
clear
why
C
would
be
preferred
over
any
other
language
The
set
of
basic
data
types
is
sparse
and
arrays
are
the
only
structured
built
in
type
What
s
so
special
about
C
C
supports
a
pointer
data
type
a
pointer
is
a
data
variable
that
contains
the
address
of
i
e
textit
points
to
another
variable
Pointers
to
data
are
integrally
related
to
arrays
Additionally
C
supports
pointers
to
functions
a
feature
that
we
will
exploit
when
we
introduce
abstract
data
types
subsection
Pointers
to
data
begingroup
setlength
intextsep
0pt
setlength
columnsep
15pt
begin
wrapfigure
R
0
25
textwidth
centering
includegraphics
scale
0
5
c
PointerGraph
end
wrapfigure
A
typical
computer
has
an
array
of
consecutively
numbered
or
addressed
memory
cells
that
can
be
manipulated
individually
or
in
contiguous
groups
in
the
figure
to
the
right
we
are
assuming
verb
N
cells
numbered
verb
0
N
1
Now
suppose
that
we
have
a
verb
char
variable
named
verb
c
and
that
it
is
assigned
to
address
verb
7
footnote
The
linker
decides
where
to
place
variables
when
linking
the
program
together
Furthermore
we
have
a
pointer
to
a
character
verb
p
that
is
assigned
to
address
verb
N
6
The
figure
assumes
that
a
pointer
occupies
4
bytes
a
32
bit
architecture
if
we
were
on
a
64
bit
architecture
it
would
occupy
8
bytes
We
can
make
verb
p
point
to
verb
c
with
a
statement
of
the
form
verb
p
c
index
C
textbf
C
data
types
pointers
assignment
The
unary
operator
verb
gives
the
address
of
a
variable
it
is
verbalized
as
address
of
After
executing
such
a
statement
verb
p
is
said
to
point
to
verb
c
par
endgroup
verb
can
only
be
applied
to
variables
and
array
elements
it
cannot
be
applied
to
expressions
or
constants
Once
one
has
a
pointer
how
do
you
get
at
the
contents
of
the
variable
to
which
it
points
The
unary
operator
verb
is
the
indirection
or
dereferencing
operator
when
applied
to
a
pointer
it
accesses
the
object
to
which
the
pointer
points
In
our
previous
example
verb
p
would
yield
verb
a
which
is
the
character
stored
in
verb
c
The
following
artificial
sequence
of
statements
show
the
use
of
verb
and
verb
begin
adjustwidth
1cm
small
verb
int
x
1
y
2
z
10
newline
verb
int
p
q
p
and
q
are
pointers
to
an
int
newline
verb
newline
verb
p
x
point
now
points
to
x
newline
verb
y
p
y
is
now
1
newline
verb
p
0
x
is
now
0
newline
verb
q
z
0
q
now
points
to
z
0
newline
verb
p
q
p
now
points
to
z
0
newline
normalsize
end
adjustwidth
Note
that
the
declaration
for
a
pointer
to
an
verb
int
is
verb
int
p
i
e
it
indicates
that
index
C
textbf
C
data
types
pointers
declaration
the
expression
verb
p
can
be
used
anywhere
that
an
verb
int
is
legal
it
also
indicates
that
verb
p
must
be
dereferenced
to
yield
an
verb
int
i
e
verb
p
is
a
pointer
to
an
verb
int
index
C
textbf
C
data
types
pointers
dereference
Pointers
are
constrained
to
point
to
a
particular
type
of
object
in
this
case
verb
p
is
a
pointer
to
an
verb
int
subsection
Call
by
value
and
pointers
label
call
by
value
When
you
call
a
C
function
the
value
of
the
argument
is
passed
to
the
function
The
function
can
not
only
read
the
values
passed
but
can
modify
them
since
they
are
copies
the
caller
s
copies
of
those
values
emph
are
not
changed
Thus
given
call
by
value
there
is
no
direct
way
for
a
function
to
alter
a
variable
in
the
calling
function
Suppose
we
need
a
function
to
swap
two
values
as
part
of
an
algorithm
A
naive
approach
would
be
as
follows
begin
adjustwidth
1cm
small
verb
void
swap
int
x
int
y
Will
not
work
newline
verb
int
temp
newline
verb
newline
verb
temp
x
newline
verb
x
y
newline
verb
y
temp
newline
verb
newline
normalsize
end
adjustwidth
If
a
caller
invokes
verb
swap
a
b
upon
return
from
verb
swap
verb
a
and
verb
b
will
still
have
the
values
they
had
before
the
call
to
verb
swap
This
is
because
the
function
is
swapping
copies
of
the
actual
arguments
not
the
arguments
themselves
What
happens
if
we
modify
verb
swap
as
follows
begin
adjustwidth
1cm
small
verb
void
swap
int
px
int
py
swap
px
and
py
newline
verb
int
temp
newline
verb
newline
verb
temp
px
newline
verb
px
py
newline
verb
py
temp
newline
verb
newline
normalsize
end
adjustwidth
If
a
caller
now
invokes
verb
swap
a
b
upon
return
the
values
in
verb
a
and
verb
b
will
truly
be
swapped
You
saw
similar
situations
in
Python
when
you
passed
mutable
data
structures
like
lists
or
dictionaries
since
a
called
function
could
return
a
value
for
the
function
modify
a
mutable
data
structure
or
both
By
passing
pointer
parameters
to
a
function
the
function
can
modify
the
variables
to
which
the
pointers
point
index
C
textbf
C
functions
modifying
caller
s
variables
as
well
as
return
a
function
value
subsection
Pointers
and
arrays
Pointers
and
arrays
are
strongly
related
in
C
in
that
any
operation
that
can
be
achieved
by
array
subscripting
can
also
be
done
with
pointers
index
C
textbf
C
data
types
pointers
array
equivalence
Consider
the
following
declaration
begin
adjustwidth
1cm
small
verb
int
a
10
newline
normalsize
end
adjustwidth
This
defines
an
integer
array
named
verb
a
of
size
verb
10
i
e
a
block
of
verb
10
consecutive
verb
int
objects
in
memory
named
verb
a
0
verb
a
1
verb
a
9
verb
a
i
refers
to
the
verb
i
textsuperscript
th
element
of
the
array
Now
assume
that
verb
pa
is
a
pointer
to
an
integer
declared
as
begin
adjustwidth
1cm
small
verb
int
pa
newline
normalsize
end
adjustwidth
The
assignment
verb
pa
a
0
causes
verb
pa
to
point
to
element
zero
of
verb
a
i
e
verb
pa
contains
the
address
of
verb
a
0
If
verb
x
is
an
integer
the
assignment
verb
x
pa
copies
the
contents
of
verb
a
0
into
verb
x
emph
By
definition
verb
pa
1
points
to
the
next
element
past
verb
pa
verb
pa
i
points
verb
i
elements
past
verb
pa
and
verb
pa
i
points
verb
i
elements
before
verb
pa
begin
center
includegraphics
scale
0
6
c
PointerArray
end
center
The
preceding
statements
are
true
regardless
of
the
type
or
size
of
the
variables
in
the
array
verb
a
The
meaning
of
add
1
to
a
pointer
and
by
extension
all
pointer
arithmetic
is
that
verb
pa
1
index
C
textbf
C
data
types
pointers
arithmetic
points
to
the
next
object
of
that
type
beyond
verb
pa
and
that
verb
pa
i
points
to
the
verb
i
textsuperscript
th
object
of
that
type
beyond
verb
pa
The
value
of
a
variable
of
type
array
is
the
address
of
the
verb
0
textsuperscript
th
element
of
the
array
i
e
verb
a
a
0
Thus
the
following
are
equivalent
begin
adjustwidth
1cm
small
verb
pa
a
0
newline
verb
pa
a
newline
normalsize
end
adjustwidth
There
are
several
ramifications
of
this
strong
relationship
between
pointers
and
arrays
begin
itemize
noitemsep
item
a
reference
to
verb
a
i
can
be
written
as
verb
a
i
item
a
reference
to
verb
a
i
is
identical
to
verb
a
i
item
verb
pa
i
is
identical
to
verb
pa
i
item
since
a
pointer
is
a
variable
expressions
like
verb
pa
a
and
verb
pa
are
legal
item
since
an
array
name
is
not
a
variable
expressions
like
verb
a
pa
and
verb
a
are
emph
illegal
item
when
an
array
name
is
passed
as
an
argument
to
a
function
what
is
passed
is
the
address
of
the
initial
element
within
the
called
function
the
argument
is
a
local
variable
thus
an
array
name
parameter
is
a
pointer
item
as
formal
parameters
in
a
function
definition
verb
s
and
verb
s
are
equivalent
thus
if
an
array
name
has
been
passed
as
the
actual
argument
in
a
call
the
function
can
believe
that
it
has
been
handed
either
an
array
or
a
pointer
item
a
part
of
an
array
can
be
passed
to
a
function
by
passing
a
pointer
to
the
beginning
of
the
sub
array
e
g
verb
f
a
2
or
verb
f
a
2
end
itemize
subsection
Pointer
arithmetic
If
verb
p
is
a
pointer
to
some
element
of
an
array
then
verb
p
increments
verb
p
to
point
to
the
next
element
and
verb
p
i
increments
it
to
point
verb
i
elements
beyond
the
current
element
There
is
a
distinguished
pointer
value
verb
NULL
which
means
that
the
pointer
does
not
point
at
anything
valid
verb
NULL
is
defined
in
verb
stdio
h
verb
stdlib
h
and
verb
string
h
footnote
It
is
defined
in
several
places
since
it
is
used
by
functions
defined
in
each
of
these
include
files
Pointer
values
can
be
compared
using
verb
verb
verb
verb
verb
and
verb
Adding
or
subtracting
an
integer
from
a
pointer
causes
the
behavior
defined
previously
Subtracting
two
pointers
is
also
valid
if
verb
p
and
verb
q
point
to
elements
of
the
same
array
and
if
verb
p
q
then
verb
q
p
1
is
the
number
of
elements
from
verb
p
to
verb
q
inclusive
Thus
valid
pointer
arithmetic
operations
are
begin
itemize
noitemsep
item
assignment
of
pointers
of
the
same
type
item
adding
or
subtracting
a
pointer
and
an
integer
item
subtracting
or
comparing
two
pointers
to
members
of
the
same
array
item
assigning
or
comparing
to
verb
NULL
end
itemize
The
following
operations
on
pointers
are
emph
invalid
begin
itemize
noitemsep
item
add
multiply
or
divide
two
pointers
item
add
a
float
or
double
to
a
pointer
item
assign
a
pointer
of
one
type
to
a
pointer
of
another
type
footnote
It
is
possible
to
use
an
explicit
cast
to
assign
pointers
of
different
types
This
will
be
discussed
in
the
following
section
end
itemize
subsection
texttt
void
pointers
and
heap
memory
subsubsection
texttt
void
pointers
index
C
textbf
C
data
types
pointers
void
As
we
shall
see
later
in
this
chapter
pointers
to
structures
act
somewhat
like
object
references
in
object
oriented
languages
Nearly
all
object
oriented
languages
Python
included
have
a
base
class
verb
Object
from
which
all
other
classes
inherit
C
provides
a
generic
pointer
verb
void
any
pointer
can
be
cast
to
verb
void
and
back
again
without
loss
of
information
verb
void
is
used
to
construct
modules
that
provide
generic
capabilities
at
runtime
we
will
be
using
these
in
our
abstract
data
types
One
important
aspect
of
verb
void
pointers
is
that
you
emph
cannot
dereference
them
attempts
to
do
so
will
generate
a
compiler
or
a
runtime
error
The
most
common
initial
exposure
to
verb
void
pointers
is
through
the
dynamic
memory
allocation
routines
defined
in
verb
stdlib
h
subsubsection
Heap
memory
index
C
textbf
C
heap
memory
Many
of
the
data
structures
used
to
solve
problems
grow
dynamically
i
e
one
cannot
know
when
the
program
starts
how
much
memory
a
particular
data
structure
will
occupy
Languages
like
C
and
Python
provide
emph
heap
memory
that
can
be
allocated
as
a
data
structure
needs
to
grow
In
Python
every
time
you
invoke
a
constructor
e
g
verb
list
verb
dict
verb
set
or
the
constructor
for
any
class
memory
is
allocated
from
the
heap
Python
keeps
track
of
the
references
to
heap
allocated
memory
when
there
are
no
more
references
to
a
chunk
of
heap
allocated
memory
it
can
be
returned
to
the
heap
This
is
known
as
emph
garbage
collection
C
provides
a
set
of
routines
for
allocating
and
freeing
heap
memory
in
verb
stdlib
h
but
does
not
track
references
to
heap
allocated
memory
so
does
not
provide
garbage
collection
Thus
your
program
must
emph
itself
keep
track
of
references
to
heap
blocks
and
free
blocks
when
there
are
no
more
references
Failure
to
do
so
causes
emph
memory
leaks
in
your
program
which
must
be
assiduously
avoided
We
will
discuss
the
verb
valgrind
program
later
in
this
chapter
which
helps
you
find
memory
leaks
The
function
prototypes
for
the
routines
in
verb
stdlib
h
are
as
follows
begin
adjustwidth
1cm
small
verb
newline
verb
malloc
return
a
pointer
to
space
for
an
object
of
size
size
bytes
or
newline
verb
NULL
if
the
request
cannot
be
satisfied
The
space
is
uninitialized
newline
verb
newline
verb
void
malloc
size
t
size
newline
verb
newline
verb
newline
verb
free
deallocates
space
pointed
to
by
ptr
it
does
nothing
if
ptr
is
NULL
newline
verb
ptr
must
be
a
pointer
to
space
previously
allocated
by
malloc
calloc
newline
verb
or
realloc
newline
verb
newline
verb
void
free
void
ptr
newline
verb
newline
verb
newline
verb
calloc
returns
a
pointer
to
space
for
an
array
of
nmemb
elements
each
newline
verb
of
size
size
bytes
or
NULL
if
the
request
cannot
be
satisfied
newline
verb
The
space
is
initialized
to
zero
bytes
newline
verb
newline
verb
void
calloc
size
t
nmemb
size
t
size
newline
verb
newline
verb
newline
verb
realloc
adjusts
the
size
of
the
memory
block
pointed
to
by
ptr
to
size
bytes
newline
verb
returning
a
pointer
to
the
resized
block
the
contents
will
be
unchanged
newline
verb
in
the
range
from
the
start
of
the
region
up
to
the
minimum
of
the
old
and
newline
verb
new
sizes
if
the
new
size
is
larger
the
added
memory
will
not
be
newline
verb
initialized
if
a
new
block
had
to
be
allocated
a
free
ptr
was
done
newline
verb
newline
verb
void
realloc
void
ptr
size
t
size
newline
normalsize
end
adjustwidth
These
prototypes
use
a
type
verb
size
t
which
is
also
defined
in
verb
stdlib
h
Think
of
it
as
an
integer
How
do
you
know
the
number
of
bytes
that
you
need
to
ask
for
index
C
textbf
C
sizeof
compile
time
operator
We
discussed
verb
sizeof
earlier
as
this
compile
time
expression
is
replaced
by
the
number
of
bytes
needed
for
an
instance
of
a
type
or
for
a
particular
variable
When
you
invoke
verb
malloc
to
allocate
some
heap
memory
a
pointer
to
the
first
byte
in
the
block
is
returned
to
you
as
a
verb
void
Let
s
look
at
an
example
begin
adjustwidth
1cm
small
verb
include
stdlib
h
newline
verb
include
stdio
h
newline
verb
newline
verb
int
p
newline
verb
newline
verb
p
int
malloc
sizeof
int
newline
verb
if
p
NULL
newline
verb
p
42
newline
verb
other
uses
of
the
allocated
memory
newline
verb
free
p
deallocate
the
memory
when
done
newline
verb
else
newline
verb
fprintf
stderr
Error
allocating
memory
for
integer
n
newline
verb
newline
normalsize
end
adjustwidth
What
does
this
code
do
We
include
verb
stdlib
h
so
that
we
can
call
verb
malloc
and
refer
to
verb
NULL
we
also
include
verb
stdio
h
so
that
we
can
call
verb
fprintf
index
C
textbf
C
stdio
fprintf
We
declare
a
pointer
of
the
appropriate
type
We
then
call
verb
malloc
using
verb
sizeof
to
specify
the
number
of
bytes
needed
for
an
integer
We
use
the
cast
verb
int
to
explicitly
convert
from
a
verb
void
pointer
returned
by
verb
malloc
to
an
verb
int
We
check
to
see
if
the
verb
malloc
was
successful
if
so
we
use
the
allocated
memory
then
return
it
to
the
heap
if
not
we
print
an
error
message
footnote
One
does
not
usually
use
the
heap
to
allocate
temporary
basic
or
structured
data
types
for
example
for
temporary
use
of
an
texttt
int
in
your
function
you
just
declare
it
as
an
automatic
the
compiler
allocates
storage
for
it
on
the
stack
and
when
your
function
returns
that
storage
is
popped
off
the
stack
We
use
the
heap
to
allocate
data
items
that
must
survive
a
return
from
the
function
in
which
they
are
allocated
usually
arrays
and
structures
There
are
two
important
aspects
to
this
example
begin
itemize
noitemsep
item
you
should
emph
always
check
the
return
result
from
verb
malloc
or
verb
calloc
or
verb
realloc
if
the
allocation
failed
and
your
code
attempts
to
dereference
a
verb
NULL
your
program
will
abort
with
a
emph
segmentation
violation
if
the
returned
value
is
verb
NULL
your
program
needs
to
take
appropriate
action
item
the
line
begin
adjustwidth
1cm
small
verb
int
p
int
malloc
sizeof
int
newline
normalsize
end
adjustwidth
is
an
integer
specific
version
of
a
standard
pattern
that
you
will
see
in
code
that
uses
verb
malloc
for
any
given
type
verb
type
the
allocation
of
an
instance
of
that
type
will
look
as
follows
begin
adjustwidth
1cm
small
verb
type
p
type
malloc
sizeof
type
newline
normalsize
end
adjustwidth
i
e
verb
sizeof
type
is
the
argument
to
verb
malloc
the
verb
void
return
from
verb
malloc
is
cast
to
verb
type
and
the
result
is
assigned
to
a
variable
of
verb
type
item
Note
that
due
to
the
strong
association
of
pointers
and
arrays
the
pattern
to
use
for
an
array
of
verb
type
of
size
verb
N
would
be
begin
adjustwidth
1cm
small
verb
type
p
type
malloc
N
sizeof
type
newline
normalsize
end
adjustwidth
end
itemize
subsubsection
An
example
program
label
sec
exampleprogram
The
following
program
reads
up
to
the
first
100
lines
from
standard
input
stores
those
lines
in
dynamic
memory
prints
each
of
the
stored
lines
and
then
frees
the
dynamic
memory
We
use
two
functions
from
verb
string
h
verb
strlen
which
counts
the
number
of
characters
in
a
character
array
up
to
but
not
including
the
verb
0
that
terminates
the
string
and
verb
strcpy
which
copies
the
second
argument
string
into
the
first
index
C
textbf
C
string
functions
strcpy
This
example
program
also
uses
a
number
of
other
aspects
of
the
language
that
we
have
discussed
so
far
begin
adjustwidth
1cm
small
verb
include
stdio
h
newline
verb
include
stdlib
h
newline
verb
include
string
h
newline
verb
newline
verb
define
NLINES
100
newline
verb
define
MAXLINESIZE
1024
newline
verb
newline
verb
int
main
int
argc
char
argv
newline
verb
char
lines
NLINES
newline
verb
char
buf
MAXLINESIZE
newline
verb
char
p
newline
verb
int
i
newline
verb
int
nl
0
newline
verb
newline
verb
while
nl
NLINES
fgets
buf
MAXLINESIZE
stdin
NULL
newline
verb
p
char
malloc
strlen
buf
1
why
the
1
newline
verb
strcpy
p
buf
newline
verb
lines
nl
p
newline
verb
newline
verb
for
i
0
i
nl
i
newline
verb
printf
s
lines
i
newline
verb
for
i
0
i
nl
i
newline
verb
free
void
lines
i
newline
verb
return
0
newline
verb
newline
normalsize
end
adjustwidth
Why
did
we
have
to
specify
the
size
for
the
heap
buffer
as
verb
strlen
buf
1
The
value
returned
by
verb
strlen
does
not
include
the
verb
0
that
indicates
the
end
of
string
If
we
are
going
to
make
a
legal
copy
of
a
string
we
have
to
allocate
enough
bytes
to
hold
all
of
the
characters
emph
and
the
verb
0
thus
we
add
one
to
the
number
of
characters
Forgetting
to
account
for
the
terminating
0
byte
is
an
emph
exceedingly
common
error
that
students
make
In
fact
one
has
to
make
string
copies
on
the
heap
so
often
that
verb
string
h
defines
a
function
verb
char
strdup
char
str
that
allocates
the
correct
number
of
bytes
on
the
heap
copies
verb
str
into
that
block
and
returns
a
verb
char
pointer
to
the
heap
memory
You
are
encouraged
to
use
verb
strdup
for
this
very
common
operation
index
C
textbf
C
string
functions
strdup
thus
avoiding
the
memory
errors
caused
by
forgetting
to
allocate
space
for
the
verb
0
subsection
Character
pointers
and
functions
index
C
textbf
C
strings
The
most
common
pointers
that
you
will
encounter
are
pointers
to
characters
Strings
are
arrays
of
characters
with
each
character
in
the
string
occupying
one
position
in
the
array
one
additional
position
at
the
end
of
the
string
holds
the
0
byte
verb
0
to
terminate
the
string
A
string
literal
is
written
as
verb
This
is
a
string
The
literal
is
stored
as
an
array
of
characters
in
emph
read
only
memory
with
the
terminating
0
byte
When
a
string
literal
constant
is
specified
as
an
argument
to
a
function
a
verb
char
pointer
to
the
first
character
in
the
literal
is
passed
to
the
function
Note
that
C
does
emph
not
provide
any
operators
for
processing
an
entire
string
as
a
unit
Arrays
of
characters
are
used
and
a
library
of
functions
defined
in
verb
string
h
enables
typical
string
manipulation
Consider
the
following
two
declarations
begin
adjustwidth
1cm
small
verb
char
amsg
this
is
a
string
newline
verb
char
pmsg
this
is
a
string
newline
normalsize
end
adjustwidth
verb
amsg
is
an
array
just
big
enough
to
hold
the
sequence
of
characters
and
the
0
byte
this
array
is
placed
in
read
write
memory
and
the
characters
in
the
array
can
be
changed
by
subsequent
logic
verb
pmsg
is
a
pointer
and
it
points
to
the
first
character
of
an
array
in
read
only
memory
that
holds
the
sequence
of
characters
and
the
0
byte
the
characters
in
the
array
emph
cannot
be
changed
but
subsequent
logic
can
cause
verb
pmsg
to
point
to
a
different
string
in
memory
subsection
Pointer
arrays
pointers
to
pointers
index
C
textbf
C
data
types
pointers
pointers
to
Since
pointers
are
variables
themselves
they
can
be
stored
in
arrays
just
as
other
data
types
can
In
fact
we
have
seen
variables
that
are
arrays
of
pointers
earlier
in
the
chapter
verb
argv
the
argument
vector
that
is
passed
as
the
second
argument
in
the
call
to
verb
main
and
verb
lines
the
array
to
hold
lines
in
the
example
program
in
section
ref
sec
exampleprogram
As
you
may
recall
verb
argv
was
declared
as
verb
char
argv
what
does
this
mean
It
means
that
verb
argv
0
is
of
type
verb
char
thus
our
previous
assertion
that
verb
argv
is
a
list
array
of
strings
since
strings
are
arrays
of
characters
then
each
array
element
is
a
pointer
to
an
array
of
characters
i
e
points
to
the
first
character
in
the
array
Suppose
that
you
are
asked
to
write
a
program
that
acts
just
like
the
standard
verb
echo
command
Let
s
give
it
a
try
begin
adjustwidth
1cm
small
verb
include
stdio
h
so
we
can
access
printf
newline
verb
newline
verb
int
main
int
argc
char
argv
newline
verb
int
i
newline
verb
newline
verb
for
i
0
i
argc
i
newline
verb
printf
s
s
i
0
argv
i
newline
verb
newline
verb
printf
n
newline
verb
return
0
newline
verb
newline
normalsize
end
adjustwidth
Let
s
see
if
this
works
begin
adjustwidth
1cm
small
verb
gcc
W
Wall
o
myecho
myecho
c
newline
verb
echo
this
is
a
test
newline
verb
this
is
a
test
newline
verb
myecho
this
is
a
test
newline
verb
myecho
this
is
a
test
newline
normalsize
end
adjustwidth
begin
wrapfigure
R
0
35
textwidth
centering
includegraphics
scale
0
3
c
ArgvPicture
end
wrapfigure
Not
exactly
what
we
had
in
mind
it
appears
that
verb
argv
0
contains
the
command
that
you
typed
to
verb
bash
and
that
the
standard
verb
echo
command
does
not
print
that
No
big
problem
we
have
to
make
two
simple
changes
to
the
code
1
modify
the
initialization
clause
of
the
verb
for
loop
to
verb
i
1
and
2
modify
verb
i
0
in
the
first
verb
printf
invocation
to
verb
i
1
The
first
verb
printf
statement
looks
a
bit
weird
since
it
uses
the
ternary
conditional
What
exactly
is
it
doing
Let
s
deconstruct
it
piece
by
piece
begin
itemize
noitemsep
item
the
format
string
is
verb
s
s
which
means
that
two
additional
arguments
to
verb
printf
are
expected
both
strings
item
if
this
is
not
the
first
time
through
the
for
loop
verb
i
1
we
want
to
put
a
single
space
if
not
we
do
not
want
to
put
a
leading
character
the
ternary
argument
produces
verb
in
the
former
case
and
verb
in
the
latter
item
the
appropriate
verb
argv
value
which
is
a
character
pointer
is
the
final
argument
end
itemize
subsubsection
Initializing
arrays
of
pointers
Suppose
you
wanted
to
define
a
list
of
keywords
that
your
program
would
understand
as
user
commands
For
example
you
have
a
simple
image
display
program
that
supports
the
commands
verb
up
verb
down
verb
left
verb
right
verb
zoom
in
and
verb
zoom
out
You
can
declare
and
initalize
an
array
of
pointers
to
these
keywords
with
the
following
code
begin
adjustwidth
1cm
small
verb
char
keywords
newline
verb
up
newline
verb
down
newline
verb
left
newline
verb
right
newline
verb
zoom
in
newline
verb
zoom
out
newline
verb
NULL
newline
verb
newline
normalsize
end
adjustwidth
Note
the
addition
of
verb
NULL
at
the
end
of
the
array
of
pointers
we
described
earlier
how
one
can
put
a
emph
sentinel
value
at
the
end
of
a
compiler
constructed
array
so
you
know
how
big
it
is
verb
NULL
is
an
excellent
value
to
use
when
you
have
an
array
of
character
pointers
By
the
way
verb
argv
actually
is
terminated
by
verb
NULL
in
this
way
subsection
Multi
dimensional
arrays
index
C
textbf
C
data
types
multi
dimensional
arrays
C
provides
rectangular
multi
dimensional
arrays
although
in
practice
they
are
much
less
used
than
arrays
of
pointers
A
multi
dimensional
array
is
declared
as
follows
begin
adjustwidth
1cm
small
verb
int
matrix
100
50
newline
normalsize
end
adjustwidth
This
indicates
that
verb
matrix
has
100
rows
each
with
50
elements
The
value
in
verb
matrix
at
the
verb
i
textsuperscript
th
row
and
verb
j
textsuperscript
th
column
is
verb
matrix
i
j
One
can
initialize
a
multi
dimensional
array
The
following
code
shows
how
to
do
so
for
a
small
two
dimensional
array
begin
adjustwidth
1cm
small
verb
int
matrix
2
4
newline
verb
1
2
3
4
newline
verb
5
6
7
8
newline
verb
newline
normalsize
end
adjustwidth
subsection
Pointers
to
functions
index
C
textbf
C
data
types
pointers
to
functions
A
function
itself
is
not
a
variable
in
C
but
it
is
possible
to
define
pointers
to
functions
These
can
be
assigned
to
pointer
variables
placed
in
arrays
passed
as
arguments
to
functions
returned
by
functions
etc
Let
s
look
at
one
use
of
function
pointers
Consider
a
sort
program
that
sorts
strings
in
files
like
the
standard
verb
sort
program
in
Linux
Sometimes
we
want
to
sort
the
strings
lexicographically
i
e
as
character
strings
at
other
times
there
may
be
a
number
at
the
beginning
of
each
line
and
we
would
like
the
lines
to
be
sorted
numerically
according
to
the
leading
number
As
with
the
standard
verb
sort
program
the
user
should
be
able
to
choose
the
type
of
sort
by
specifying
a
flag
argument
when
invoking
the
program
The
pseudocode
for
our
verb
main
looks
something
like
the
following
begin
adjustwidth
1cm
small
textit
process
command
arguments
newline
textit
read
all
lines
of
input
newline
textit
sort
them
newline
textit
print
them
in
order
newline
normalsize
end
adjustwidth
Assuming
that
there
is
a
verb
sort
function
that
performs
the
textit
sort
them
part
of
the
pseudocode
we
need
to
have
some
way
to
inform
that
function
how
we
want
the
strings
to
be
compared
If
the
function
prototype
for
verb
sort
has
the
following
form
we
can
achieve
this
flexible
form
of
sorting
begin
adjustwidth
1cm
small
verb
void
sort
char
lines
int
left
int
right
int
comp
char
l1
char
l2
newline
normalsize
end
adjustwidth
What
does
this
prototype
tell
us
begin
itemize
noitemsep
item
verb
sort
sorts
the
array
of
pointers
to
strings
verb
lines
item
it
actually
sorts
a
slice
of
the
array
specified
by
verb
left
and
verb
right
and
item
whenever
verb
sort
needs
to
compare
two
entries
in
verb
lines
it
will
invoke
the
function
pointed
to
by
verb
comp
this
function
takes
two
verb
char
arguments
and
the
return
value
from
the
function
will
be
a
value
verb
0
if
verb
l1
l2
the
value
verb
0
if
verb
l1
l2
or
a
value
verb
0
if
verb
l1
l2
The
function
verb
strcmp
in
verb
string
h
is
exactly
such
a
function
and
compares
the
strings
lexicographically
end
itemize
Suppose
we
have
read
verb
n
lines
of
text
such
that
verb
lines
0
lines
n
1
have
valid
pointers
If
we
wanted
to
do
a
lexicographical
sort
verb
main
would
invoke
verb
sort
as
begin
adjustwidth
1cm
small
verb
include
string
h
newline
verb
newline
verb
sort
lines
0
n
1
strcmp
newline
normalsize
end
adjustwidth
Now
suppose
that
we
want
to
do
a
numeric
sort
To
do
so
we
will
have
to
define
a
numeric
compare
function
that
matches
the
prototype
for
the
function
pointer
argument
in
verb
sort
The
following
will
do
the
trick
begin
adjustwidth
1cm
small
verb
include
stdlib
h
newline
verb
newline
verb
int
numcmp
char
l1
char
l2
newline
verb
int
i1
atoi
l1
newline
verb
int
i2
atoi
l2
newline
verb
return
i1
i2
newline
verb
newline
normalsize
end
adjustwidth
and
verb
main
would
invoke
verb
sort
as
begin
adjustwidth
1cm
small
verb
sort
lines
0
n
1
numcmp
newline
normalsize
end
adjustwidth
subsubsection
Care
when
defining
function
pointers
Due
to
the
precedence
of
C
s
operators
you
have
to
be
careful
when
defining
function
pointers
For
example
consider
the
following
function
prototype
begin
adjustwidth
1cm
small
verb
int
f
void
arg
newline
normalsize
end
adjustwidth
this
defines
a
function
named
verb
f
that
returns
a
pointer
to
an
integer
while
begin
adjustwidth
1cm
small
verb
int
pf
void
arg
newline
normalsize
end
adjustwidth
defines
verb
pf
as
a
pointer
to
a
function
returning
an
integer
In
general
when
defining
a
function
pointer
you
should
always
surround
the
name
of
the
pointer
verb
name
by
parentheses
to
avoid
such
mistakes
We
will
use
function
pointers
when
constructing
abstract
data
types
in
C
so
we
will
have
plenty
of
practice
section
Structures
index
C
textbf
C
structured
data
types
structs
A
emph
structure
is
a
collection
of
one
or
more
variables
possibly
of
different
types
grouped
together
under
a
single
name
for
convenient
handling
A
structure
declaration
looks
as
follows
begin
adjustwidth
1cm
small
verb
struct
tag
newline
verb
declarations
newline
verb
newline
normalsize
end
adjustwidth
The
keyword
verb
struct
introduces
a
structure
declaration
which
is
a
list
of
variable
declarations
enclosed
in
curly
braces
the
verb
tag
is
an
optional
name
that
can
be
used
to
refer
to
this
structure
type
in
the
future
The
variables
named
in
the
declarations
within
the
braces
are
called
emph
members
A
verb
struct
declaration
defines
a
type
it
is
equivalent
to
a
Python
class
definition
for
which
there
are
no
member
functions
The
right
brace
that
terminates
the
list
of
members
may
be
followed
by
a
list
of
variable
names
as
in
begin
adjustwidth
1cm
small
verb
struct
x
y
z
newline
normalsize
end
adjustwidth
A
verb
struct
declaration
that
is
emph
not
followed
by
a
list
of
variables
reserves
no
storage
it
merely
describes
a
template
or
the
shape
of
a
structure
In
such
a
case
a
verb
tag
must
be
specified
in
order
to
define
instances
of
the
structure
later
Suppose
that
we
have
defined
the
following
verb
struct
begin
adjustwidth
1cm
small
verb
struct
point
newline
verb
int
x
newline
verb
int
y
newline
verb
newline
normalsize
end
adjustwidth
We
can
declare
an
instance
of
a
verb
point
using
begin
adjustwidth
1cm
small
verb
struct
point
pt
newline
normalsize
end
adjustwidth
We
can
initialize
a
structure
in
its
declaration
as
in
begin
adjustwidth
1cm
small
verb
struct
point
maxpt
320
200
newline
normalsize
end
adjustwidth
We
can
refer
to
a
member
of
a
particular
verb
struct
as
textit
structure
name
member
name
as
in
begin
adjustwidth
1cm
small
verb
printf
d
d
n
pt
x
pt
y
newline
normalsize
end
adjustwidth
Structures
can
be
nested
for
example
if
we
represent
a
rectangle
as
a
pair
of
points
denoting
diagonally
opposite
corners
we
can
define
begin
adjustwidth
1cm
small
verb
struct
rect
newline
verb
struct
point
ll
newline
verb
struct
point
ur
newline
verb
newline
normalsize
end
adjustwidth
If
we
declare
verb
screen
as
begin
adjustwidth
1cm
small
verb
struct
rect
screen
newline
normalsize
end
adjustwidth
then
verb
screen
ll
x
refers
to
the
verb
x
coordinate
of
the
lower
left
corner
verb
ll
of
verb
screen
subsection
Legal
operations
on
a
structure
begin
itemize
noitemsep
item
Copy
it
as
a
unit
item
Assign
to
it
as
a
unit
item
Pass
it
by
value
as
a
function
argument
item
Return
it
by
value
as
a
function
return
value
item
Takes
its
address
using
verb
item
Access
its
members
item
A
global
structure
may
be
initialized
using
a
list
of
constant
member
values
item
An
automatic
structure
may
be
initialized
using
runtime
expressions
as
with
automatic
variables
item
It
may
emph
not
be
compared
with
another
structure
using
verb
or
verb
end
itemize
subsection
Pointers
to
structures
Passing
large
structures
by
value
can
be
very
inefficient
We
can
declare
pointers
to
structures
just
as
we
do
for
built
in
data
types
as
in
begin
adjustwidth
1cm
small
verb
struct
point
pp
newline
normalsize
end
adjustwidth
This
indicates
that
verb
pp
is
a
pointer
to
structures
of
type
verb
struct
point
If
verb
pp
points
to
a
point
structure
then
verb
pp
is
the
structure
itself
and
verb
pp
x
and
verb
pp
y
are
the
members
Pointers
to
structures
are
so
frequently
used
that
an
alternative
notation
is
provided
to
access
members
If
verb
p
is
a
pointer
to
a
structure
then
verb
p
member
name
is
equivalent
to
verb
p
member
name
subsection
Arrays
of
structures
Of
course
we
can
create
an
array
of
structures
Recall
our
previous
example
of
an
array
of
keywords
Let
s
modify
it
slightly
and
show
how
it
might
be
used
begin
adjustwidth
1cm
small
verb
struct
key
newline
verb
char
word
newline
verb
int
value
newline
verb
newline
verb
newline
verb
struct
key
keywords
newline
verb
up
1
newline
verb
down
2
newline
verb
left
3
newline
verb
right
4
newline
verb
zoom
in
5
newline
verb
zoom
out
6
newline
verb
NULL
1
newline
verb
newline
verb
newline
verb
int
mapKeyword
char
word
newline
verb
int
i
newline
verb
newline
verb
for
i
0
keywords
i
word
NULL
i
newline
verb
if
strcmp
word
keywords
i
word
0
newline
verb
return
keywords
i
value
newline
verb
return
keywords
i
value
newline
verb
newline
normalsize
end
adjustwidth
The
function
verb
mapKeyword
maps
from
one
of
the
string
commands
to
an
integer
value
The
code
that
solicited
the
string
command
from
the
user
would
call
this
routine
and
then
process
the
return
value
in
a
verb
switch
statement
to
perform
the
requested
action
subsection
Self
referential
structures
As
we
shall
see
later
in
the
text
many
data
structures
that
we
use
for
common
algorithms
require
that
a
structure
contain
one
or
more
members
that
can
emph
point
at
instances
of
that
structure
e
g
linked
lists
binary
trees
For
a
singly
linked
list
of
integers
we
would
define
the
following
structure
type
for
nodes
in
the
list
begin
adjustwidth
1cm
small
verb
struct
node
newline
verb
struct
node
next
newline
verb
int
value
newline
verb
newline
normalsize
end
adjustwidth
In
C
as
soon
as
the
compiler
has
seen
verb
struct
tag
any
subsequent
code
can
refer
to
this
tag
for
members
of
that
struct
one
can
declare
pointers
to
instances
of
that
structure
It
makes
no
sense
for
a
structure
to
contain
a
member
which
is
an
instance
of
that
structure
where
would
the
recursion
end
subsection
Typedefs
index
C
textbf
C
data
types
typedefs
C
provides
a
facility
for
creating
new
data
type
emph
names
For
example
begin
adjustwidth
1cm
small
verb
typedef
int
Length
newline
normalsize
end
adjustwidth
makes
the
name
verb
Length
a
synonym
for
verb
int
The
type
name
verb
Length
can
be
used
in
declarations
casts
etc
in
exactly
the
same
way
that
verb
int
can
be
used
for
example
begin
adjustwidth
1cm
small
verb
Length
len
maxlen
newline
verb
Length
lengths
25
newline
normalsize
end
adjustwidth
We
can
use
verb
typedef
to
also
define
synonyms
for
pointers
begin
adjustwidth
1cm
small
verb
typedef
char
String
newline
normalsize
end
adjustwidth
makes
verb
String
a
synonym
for
verb
char
The
most
common
use
of
verb
typedef
is
with
respect
to
structures
Let
s
revisit
our
point
structure
and
define
a
new
type
name
for
it
begin
adjustwidth
1cm
small
verb
typedef
struct
point
newline
verb
int
x
newline
verb
int
y
newline
verb
Point
newline
normalsize
end
adjustwidth
This
particular
style
is
extremely
common
i
e
the
tag
for
the
structure
starts
with
a
lower
case
letter
while
the
synonym
starts
with
an
upper
case
letter
in
this
example
the
tag
is
verb
point
while
the
synonym
for
verb
struct
point
is
verb
Point
With
the
above
definition
of
verb
Point
our
definition
for
a
rectangle
can
become
begin
adjustwidth
1cm
small
verb
typedef
struct
rectangle
newline
verb
Point
ll
newline
verb
Point
ur
newline
verb
Rectangle
newline
normalsize
end
adjustwidth
and
we
can
declare
the
variable
verb
screen
as
verb
Rectangle
screen
Note
that
verb
typedef
does
emph
not
create
a
new
type
in
any
sense
it
merely
adds
a
synonym
for
some
existing
type
For
example
we
can
declare
variables
as
verb
struct
point
p1
or
as
verb
Point
p2
Both
declarations
achieve
the
same
goal
of
creating
a
variable
that
holds
a
verb
struct
point
i
e
both
verb
p1
and
verb
p2
have
exactly
the
same
properties
It
is
also
possible
to
create
a
synonym
for
function
pointers
For
example
begin
adjustwidth
1cm
small
verb
typedef
int
PFI
char
char
newline
normalsize
end
adjustwidth
creates
the
type
name
verb
PFI
for
pointer
to
function
of
two
texttt
char
arguments
returning
an
texttt
int
it
could
be
used
as
in
the
following
begin
adjustwidth
1cm
small
verb
PFI
strcmp
numcmp
newline
normalsize
end
adjustwidth
subsection
Structs
and
the
heap
The
verb
sizeof
compile
time
operator
works
with
verb
struct
s
just
like
it
does
for
built
in
types
This
enables
us
to
create
instances
of
our
structures
on
the
heap
using
verb
malloc
Consider
the
following
example
begin
adjustwidth
1cm
small
verb
typedef
struct
node
newline
verb
struct
node
next
newline
verb
int
val
newline
verb
Node
newline
verb
newline
verb
Node
head
NULL
head
of
singly
linked
list
newline
verb
Node
tail
NULL
tail
of
singly
linked
list
newline
verb
newline
verb
int
addNode
int
value
add
node
to
tail
of
list
newline
verb
Node
n
Node
malloc
sizeof
Node
newline
verb
newline
verb
if
n
NULL
newline
verb
n
val
value
newline
verb
n
next
NULL
newline
verb
if
head
NULL
newline
verb
head
n
newline
verb
else
newline
verb
tail
next
n
newline
verb
tail
n
newline
verb
return
1
return
success
indication
newline
verb
else
newline
verb
return
0
return
failure
indication
newline
verb
newline
verb
newline
normalsize
end
adjustwidth
The
call
to
verb
malloc
looks
just
like
those
we
have
seen
before
Through
the
cast
we
have
a
pointer
to
our
structure
and
can
manipulate
the
members
of
the
allocated
structure
This
example
is
for
a
singly
linked
list
which
we
will
see
later
in
the
textbook
subsection
Unions
index
C
textbf
C
data
types
unions
A
emph
union
is
a
variable
that
may
hold
at
different
times
objects
of
different
types
and
sizes
with
the
compiler
keeping
track
of
size
and
alignment
requirements
Unions
enable
the
manipulation
of
different
kinds
of
data
in
a
single
area
of
storage
without
embedding
any
machine
dependent
information
in
your
program
Consider
the
symbol
table
for
a
compiler
the
program
could
have
integer
floating
point
or
character
string
literals
we
would
like
to
define
a
single
structure
type
for
a
literal
in
our
symbol
table
The
value
of
a
particular
literal
must
be
stored
in
a
variable
of
the
appropriate
type
but
it
is
most
convenient
for
table
management
if
the
value
occupies
the
same
amount
of
storage
and
is
stored
in
the
same
place
regardless
of
its
type
The
syntax
is
similar
to
that
for
structures
For
this
symbol
table
application
begin
adjustwidth
1cm
small
verb
union
literalValue
newline
verb
int
ival
newline
verb
double
dval
newline
verb
char
sval
newline
verb
u
newline
normalsize
end
adjustwidth
defines
a
variable
named
verb
u
which
at
different
times
can
hold
an
integer
a
double
precision
floating
point
number
or
a
pointer
to
a
character
array
The
tag
identifier
in
this
case
verb
literalValue
is
optional
verb
u
will
be
large
enough
to
hold
the
largest
of
the
three
types
Any
one
of
these
types
may
be
assigned
to
verb
u
and
then
used
in
expressions
Of
course
your
program
must
have
some
way
to
keep
track
of
what
type
of
value
the
verb
union
currently
holds
One
normally
creates
a
structure
called
a
emph
discriminated
union
which
consists
of
a
member
for
keeping
track
of
the
type
of
value
in
the
verb
union
and
a
member
which
is
the
union
Given
the
definition
of
verb
literalValue
above
begin
adjustwidth
1cm
small
verb
define
INTVALUE
1
newline
verb
define
DOUBLEVALUE
2
newline
verb
define
STRINGVALUE
3
newline
verb
newline
verb
struct
sTableEntry
newline
verb
int
uType
newline
verb
union
literalValue
u
newline
verb
s
newline
normalsize
end
adjustwidth
Suppose
that
our
program
had
read
the
integer
constant
verb
42
in
its
input
and
needed
to
place
that
information
in
verb
s
declared
above
The
following
two
lines
would
do
the
trick
begin
adjustwidth
1cm
small
verb
s
uType
INTVALUE
newline
verb
s
u
ival
42
newline
normalsize
end
adjustwidth
Given
the
definition
of
verb
sTableEntry
above
the
following
code
would
display
the
current
value
in
verb
s
on
standard
output
begin
adjustwidth
1cm
small
verb
switch
s
uType
newline
verb
case
INTVALUE
printf
d
n
s
u
ival
break
newline
verb
case
DOUBLEVALUE
printf
f
n
s
u
dval
break
newline
verb
case
STRINGVALUE
printf
s
n
s
u
sval
break
newline
verb
default
printf
illegal
discriminator
value
d
n
s
uType
newline
verb
newline
normalsize
end
adjustwidth
As
with
structures
pointers
to
unions
can
be
created
used
and
verb
malloc
can
be
used
to
dynamically
allocate
a
union
on
the
heap
section
Input
and
output
index
C
textbf
C
stdio
Input
and
output
facilities
are
not
part
of
the
C
language
itself
The
standard
I
O
library
defined
in
verb
stdio
h
provides
the
ANSI
standard
library
of
I
O
functions
A
program
comes
to
life
with
standard
input
verb
stdin
standard
output
verb
stdout
and
standard
error
output
verb
stderr
predefined
By
default
verb
stdin
is
associated
with
your
keyboard
and
verb
stdout
and
verb
stderr
are
associated
with
your
terminal
window
If
the
program
was
invoked
with
I
O
redirection
in
the
command
line
the
associated
standard
streams
will
point
to
the
file
or
pipe
specified
subsection
Single
character
input
and
output
The
simplest
input
mechanism
is
to
read
one
character
at
a
time
from
verb
stdin
using
verb
getchar
index
C
textbf
C
stdio
getchar
begin
adjustwidth
1cm
small
verb
int
getchar
void
newline
normalsize
end
adjustwidth
verb
getchar
returns
the
next
input
character
from
verb
stdin
each
time
it
is
called
or
verb
EOF
when
it
encounters
the
end
of
file
The
function
index
C
textbf
C
stdio
putchar
begin
adjustwidth
1cm
small
verb
int
putchar
int
ch
newline
normalsize
end
adjustwidth
puts
the
character
verb
ch
onto
verb
stdout
We
have
previously
seen
that
verb
printf
also
prints
its
output
on
verb
stdout
index
C
textbf
C
stdio
printf
Calls
to
verb
putchar
and
verb
printf
can
be
interleaved
output
appears
in
the
order
in
which
the
calls
were
made
subsection
Formatted
input
texttt
scanf
index
C
textbf
C
stdio
scanf
The
function
verb
scanf
is
the
input
analog
to
verb
printf
providing
many
of
the
same
conversion
facilities
in
the
opposite
direction
begin
adjustwidth
1cm
small
verb
int
scanf
char
format
newline
normalsize
end
adjustwidth
verb
scanf
reads
characters
from
standard
input
interprets
them
according
to
the
specification
in
verb
format
and
stores
the
results
in
the
remaining
arguments
Note
that
all
of
the
arguments
into
which
verb
scanf
stores
the
results
emph
must
be
pointers
as
we
discussed
in
section
ref
call
by
value
verb
scanf
stops
when
it
reaches
the
end
of
the
format
string
or
when
some
input
fails
to
match
the
control
specification
in
the
format
string
verb
scanf
returns
as
its
value
the
number
of
successfully
matched
and
assigned
input
items
If
an
end
of
file
is
detected
while
scanning
verb
EOF
is
returned
The
next
call
to
verb
scanf
resumes
scanning
standard
input
immediately
after
the
last
character
scanned
in
the
current
call
The
verb
scanf
format
string
usually
contains
conversion
specifications
which
are
used
to
control
conversion
of
input
It
may
contain
begin
itemize
noitemsep
item
blanks
or
tabs
which
are
ignored
item
ordinary
characters
not
verb
which
are
expected
to
match
the
next
non
white
space
character
of
the
input
stream
item
conversion
specifications
consisting
of
the
character
verb
an
optional
assignment
suppression
character
verb
an
optional
number
specifying
a
maximum
field
width
an
optional
verb
h
verb
l
or
verb
L
indicating
the
width
of
the
target
and
a
conversion
character
end
itemize
The
basic
verb
scanf
conversions
are
shown
in
the
following
table
begin
center
small
begin
tabular
c
p
4cm
l
p
6cm
hline
textbf
character
textbf
input
data
textbf
argument
textbf
comment
textbf
type
hline
texttt
d
decimal
integer
texttt
int
texttt
ld
texttt
long
texttt
Ld
texttt
long
long
hline
texttt
i
integer
texttt
int
the
integer
may
be
in
octal
leading
0
or
hexadecimal
leading
0x
or
0X
same
texttt
l
and
texttt
L
modifiers
as
for
decimal
integer
hline
texttt
o
octal
integer
texttt
int
with
or
without
leading
0
texttt
lL
modifiers
as
for
decimal
integer
hline
texttt
u
unsigned
decimal
integer
texttt
unsigned
texttt
lu
texttt
unsigned
long
texttt
Lu
texttt
unsigned
long
long
hline
texttt
x
hexadecimal
integer
texttt
int
with
or
without
leading
0x
0X
texttt
lL
modifiers
as
for
decimal
integer
hline
texttt
c
character
texttt
char
the
next
input
character
is
copied
the
normal
skip
over
white
space
is
suppressed
hline
texttt
s
unquoted
character
string
texttt
char
address
of
an
array
of
characters
large
enough
for
the
string
and
a
terminating
texttt
textbackslash
0
hline
texttt
e
f
g
floating
point
number
texttt
float
with
optional
sign
optional
decimal
point
and
optional
exponent
texttt
lf
texttt
double
texttt
Lf
texttt
long
double
hline
texttt
literal
no
assignment
hline
end
tabular
normalsize
end
center
Here
are
a
couple
of
examples
begin
itemize
noitemsep
item
Suppose
we
want
to
read
input
lines
that
contain
dates
of
the
form
dd
Month
yyyy
begin
adjustwidth
1cm
small
verb
int
day
year
newline
verb
char
monthname
20
newline
verb
newline
verb
if
scanf
d
s
d
day
monthname
year
3
newline
verb
printf
input
was
not
in
the
form
dd
Month
yyyy
n
newline
verb
newline
normalsize
end
adjustwidth
item
Now
suppose
that
the
required
format
is
mm
dd
yyyy
begin
adjustwidth
1cm
small
verb
int
day
month
year
newline
verb
newline
verb
if
scanf
d
d
d
month
day
year
3
newline
verb
printf
input
was
not
in
the
form
mm
dd
yyyy
n
newline
verb
newline
normalsize
end
adjustwidth
end
itemize
subsection
File
access
Given
the
name
of
a
file
as
a
string
one
can
open
it
for
reading
writing
read
from
it
or
write
to
it
and
close
it
verb
stdio
h
defines
a
stream
type
verb
FILE
a
successful
file
open
returns
one
of
these
streams
the
I
O
routines
and
the
close
routine
take
one
of
these
streams
as
an
argument
verb
stdio
h
defines
verb
stdin
verb
stdout
and
verb
stderr
as
instances
of
a
verb
FILE
The
function
prototypes
are
as
follow
index
C
textbf
C
stdio
fopen
index
C
textbf
C
stdio
getc
index
C
textbf
C
stdio
putc
index
C
textbf
C
stdio
fclose
index
C
textbf
C
stdio
fscanf
index
C
textbf
C
stdio
fprintf
index
C
textbf
C
stdio
fgets
index
C
textbf
C
stdio
fputs
index
C
textbf
C
stdio
scanf
index
C
textbf
C
stdio
sprintf
begin
center
small
begin
tabular
l
p
7cm
hline
textbf
prototype
textbf
comment
hline
texttt
FILE
fopen
char
name
char
mode
most
common
mode
values
are
texttt
r
to
open
for
reading
texttt
w
to
open
for
writing
overwriting
any
existing
contents
and
texttt
a
to
open
for
appending
hline
texttt
int
getc
FILE
fp
return
next
character
from
stream
returning
texttt
EOF
if
end
of
file
hline
texttt
int
putc
int
c
FILE
fp
write
character
to
stream
hline
texttt
int
fclose
FILE
fp
close
stream
hline
texttt
int
fscanf
FILE
fp
char
format
scan
stream
according
to
texttt
format
hline
texttt
int
fprintf
FILE
fp
char
format
output
values
to
stream
according
to
texttt
format
hline
texttt
char
fgets
char
buf
int
size
FILE
fp
fetch
next
line
including
texttt
textbackslash
n
into
buf
returning
texttt
buf
if
successful
texttt
NULL
if
end
of
file
hline
texttt
int
fputs
char
buf
FILE
fp
output
characters
in
texttt
buf
to
stream
hline
end
tabular
normalsize
end
center
There
are
also
versions
of
verb
scanf
and
verb
printf
that
work
with
characters
buffers
instead
of
verb
FILE
streams
begin
adjustwidth
1cm
small
verb
int
sscanf
char
buf
char
format
newline
verb
int
sprintf
char
buf
char
format
newline
normalsize
end
adjustwidth
Finally
while
functions
in
the
verb
scanf
family
return
the
number
of
conversions
that
were
successfully
completed
the
functions
in
the
verb
printf
family
return
the
number
of
characters
written
to
the
stream
buffer
verb
sprintf
always
writes
a
terminating
0
byte
but
does
not
include
it
in
the
returned
count
Thus
the
following
pattern
is
sometimes
seen
in
code
that
is
constructing
a
complex
string
in
a
buffer
begin
adjustwidth
1cm
small
verb
char
p
buf
4096
newline
verb
newline
verb
p
buf
newline
verb
p
sprintf
p
format1
v1
v2
vn
newline
verb
p
sprintf
p
format2
w1
w2
wm
newline
verb
p
sprintf
p
format3
x1
x2
xo
newline
verb
newline
verb
buf
contains
the
concatenated
formatted
outputs
newline
normalsize
end
adjustwidth
section
Environment
variable
command
argument
conventions
There
are
a
variety
of
ways
for
providing
information
to
programs
that
you
invoke
in
verb
bash
begin
itemize
noitemsep
item
A
program
can
indicate
that
it
will
obtain
the
value
of
an
environment
variable
if
it
is
defined
for
example
verb
make
will
obtain
the
value
of
an
environment
variable
verb
CFLAGS
if
it
is
defined
in
its
environment
and
will
use
that
value
unless
verb
CFLAGS
is
explicitly
defined
in
the
makefile
In
this
latter
case
it
will
use
the
value
defined
in
the
makefile
footnote
You
are
strongly
advised
to
emph
NOT
define
texttt
CFLAGS
in
the
environment
and
to
emph
ALWAYS
define
texttt
CFLAGS
at
the
top
of
each
Makefile
From
personal
experience
you
will
forget
that
you
have
defined
texttt
CFLAGS
in
the
environment
when
you
port
your
code
to
another
system
and
spend
quite
a
bit
of
time
figuring
out
what
is
wrong
item
A
program
can
indicate
that
it
will
change
its
functionality
if
particular
flags
are
specified
in
the
command
line
These
flags
come
in
two
flavors
begin
itemize
label
star
item
short
flags
these
are
of
the
form
verb
character
where
verb
character
is
replaced
by
a
single
letter
the
man
page
for
the
program
will
tell
you
how
the
program
interprets
such
an
argument
By
convention
an
argument
of
this
form
indicates
to
the
program
that
you
are
selecting
a
particular
way
that
the
program
should
perform
its
function
For
example
verb
ls
without
a
flag
indicates
that
verb
ls
should
list
the
names
of
the
files
in
the
current
working
directory
verb
ls
l
on
the
other
hand
indicates
that
verb
ls
should
display
a
emph
long
listing
of
each
file
in
the
current
working
directory
one
per
line
Most
commands
permit
one
to
specify
several
short
flag
characters
in
a
single
argument
consider
verb
ls
lrt
The
verb
l
flag
indicates
that
one
should
do
a
long
listing
the
verb
r
flag
indicates
that
it
should
reverse
the
order
of
the
presentation
and
the
verb
t
flag
indicates
that
the
files
should
be
ordered
by
modification
time
It
is
perfectly
legal
to
invoke
this
as
verb
ls
l
r
t
but
users
require
compounding
individual
flags
so
often
that
by
convention
most
programs
support
this
approach
Sometimes
an
argument
of
this
type
requires
an
additional
piece
of
information
For
example
verb
ls
w
50
indicates
that
verb
ls
should
restrict
its
output
to
50
columns
on
the
output
The
number
of
columns
verb
50
must
follow
the
verb
w
immediately
on
the
command
line
as
a
separate
argument
to
the
command
When
a
short
flag
requires
additional
information
it
cannot
be
combined
with
other
short
flags
emph
unless
it
is
the
last
short
flag
as
in
verb
ls
lw
65
item
long
flags
such
flags
are
introduced
by
two
hyphens
as
in
verb
all
or
verb
ls
width
50
In
such
cases
the
flag
text
verb
width
and
its
value
verb
50
are
a
single
string
argument
as
seen
by
the
program
end
itemize
item
All
other
arguments
are
usually
names
of
files
occasionally
for
example
for
programs
like
verb
grep
the
first
non
flag
argument
is
considered
a
pattern
for
which
verb
grep
must
search
in
the
files
named
in
subsequent
arguments
end
itemize
From
this
discussion
you
should
infer
that
Linux
emph
strongly
discourages
starting
a
filename
with
a
hyphen
verb
If
you
do
so
you
will
need
to
consult
online
help
to
rename
the
file
to
remove
the
leading
hyphen
If
you
are
writing
a
program
in
C
to
be
invoked
from
verb
bash
you
will
need
to
provide
logic
in
your
verb
main
to
obtain
the
arguments
that
were
specified
when
your
program
was
invoked
For
your
program
to
be
a
good
citizen
in
the
Linux
environment
you
should
adhere
to
the
following
rules
begin
itemize
noitemsep
item
If
information
such
as
verb
CFLAGS
to
verb
make
can
be
provided
via
an
environment
variable
this
information
should
be
obtained
before
processing
any
command
arguments
item
While
some
programs
enable
one
to
intersperse
flags
between
filenames
it
is
strongly
recommended
that
you
emph
not
do
that
In
other
words
all
flags
should
occur
before
the
first
non
flag
argument
item
If
an
argument
starts
with
verb
and
it
is
emph
not
a
bare
verb
it
is
a
flag
if
it
emph
is
a
bare
verb
most
programs
consider
this
to
be
shorthand
for
verb
standard
input
item
For
a
flag
if
the
next
character
is
another
verb
it
is
a
long
flag
The
processing
of
a
flag
will
depend
upon
this
distinction
begin
itemize
label
star
noitemsep
item
If
it
is
a
short
flag
your
code
should
process
each
character
that
appears
after
the
leading
hyphen
item
If
it
is
a
short
flag
and
the
last
character
that
follows
the
hyphen
requires
additional
information
you
need
to
process
the
next
argument
for
that
additional
information
item
If
it
is
a
long
flag
and
the
flag
requires
additional
information
it
will
be
found
in
the
same
argument
following
the
verb
sign
item
If
the
flag
is
providing
the
same
information
as
an
environment
variable
the
value
provided
by
the
flag
emph
overrides
any
value
that
was
obtained
from
an
environment
variable
end
itemize
end
itemize
section
Debugging
your
programs
index
gdb
textbf
gdb
index
commands
textbf
commands
gdb
The
GNU
debugger
usually
called
GDB
and
named
verb
gdb
as
an
executable
file
is
the
standard
debugger
for
the
Linux
operating
system
It
can
be
used
to
debug
programs
written
in
a
number
of
programming
languages
including
C
C
Objective
C
Fortran
Java
and
many
others
GDB
was
first
written
by
Richard
Stallman
in
1986
as
part
of
the
GNU
system
It
is
free
software
released
under
the
GNU
General
Public
License
and
is
included
in
all
Linux
distributions
GDB
enables
you
to
inspect
what
a
program
is
doing
at
certain
points
of
execution
Errors
like
emph
segmentation
faults
are
often
quite
easy
to
find
with
the
help
of
verb
gdb
This
section
provides
a
brief
introduction
into
the
use
of
verb
gdb
Complete
documentation
for
verb
gdb
may
be
obtained
from
url
https
www
gnu
org
software
gdb
documentation
subsection
Preparing
your
program
for
use
with
texttt
gdb
Normally
you
compile
your
program
as
follows
small
begin
adjustwidth
1cm
verb
gcc
flags
o
executable
file
source
files
end
adjustwidth
normalsize
As
advised
in
Section
ref
sec
CFLAGS
verb
flags
should
be
replaced
by
verb
W
Wall
In
order
for
the
verb
executable
file
to
be
used
with
verb
gdb
one
must
add
an
additional
flag
verb
g
to
the
command
line
as
in
the
following
example
small
begin
adjustwidth
1cm
verb
gcc
W
Wall
g
o
prog
prog
c
end
adjustwidth
normalsize
index
gdb
textbf
gdb
g
flag
to
gcc
You
can
now
execute
verb
prog
under
verb
gdb
s
control
using
the
following
command
small
begin
adjustwidth
1cm
verb
gdb
prog
end
adjustwidth
normalsize
This
command
simply
starts
up
verb
gdb
section
ref
running
under
gdb
describes
how
to
proceed
with
actually
running
the
program
under
verb
gdb
verb
gdb
provides
an
interactive
shell
enabling
you
to
recall
history
using
the
arrow
keys
and
to
auto
complete
most
words
using
the
verb
TAB
key
At
any
time
you
may
ask
verb
gdb
for
help
with
a
command
by
typing
the
following
to
the
verb
gdb
prompt
small
begin
adjustwidth
1cm
verb
gdb
help
textit
command
end
adjustwidth
normalsize
subsection
Running
the
program
under
texttt
gdb
label
running
under
gdb
To
run
your
program
under
verb
gdb
you
type
the
following
command
small
begin
adjustwidth
1cm
verb
gdb
run
arguments
end
adjustwidth
normalsize
index
gdb
textbf
gdb
run
command
If
your
program
requires
arguments
obtained
through
verb
argv
in
verb
main
you
must
specify
them
after
the
verb
run
command
You
may
also
specify
I
O
redirection
verb
file
and
or
verb
file
along
with
the
command
arguments
This
runs
the
program
if
there
are
no
serious
problems
the
program
should
run
to
successful
completion
If
the
program
has
issues
verb
gdb
assumes
control
after
the
program
unsuccessfully
terminates
and
displays
some
useful
information
about
the
program
such
as
the
line
number
where
it
terminated
parameters
to
the
enclosing
function
etc
Consider
the
following
program
in
a
file
verb
test
c
small
begin
adjustwidth
1cm
verbatiminput
c
gdb
testbug
c
end
adjustwidth
normalsize
The
following
dialog
shows
execution
of
this
program
using
verb
gdb
small
begin
adjustwidth
1cm
verbatiminput
c
gdb
testbug
log
end
adjustwidth
normalsize
As
you
can
see
we
encountered
a
emph
segmentation
fault
in
verb
strlen
index
gdb
textbf
gdb
segmentation
fault
which
caused
the
program
to
terminate
You
may
recall
that
segmentation
faults
result
from
attempting
to
access
virtual
address
verb
0
Thus
it
is
likely
that
the
argument
to
verb
strlen
is
a
NULL
pointer
Since
we
define
verb
a
to
be
verb
NULL
in
verb
main
pass
verb
a
to
verb
foo
len
which
then
passes
verb
a
on
to
verb
strlen
we
have
found
the
source
of
our
segmentation
fault
footnote
Note
that
if
we
had
simply
invoked
texttt
test
in
the
shell
the
shell
would
have
yielded
the
relatively
unhelpful
message
of
begin
adjustwidth
1cm
texttt
Segmentation
fault
core
dumped
end
adjustwidth
If
we
change
the
declaration
for
verb
a
to
the
following
small
begin
adjustwidth
1cm
verb
const
char
a
This
is
a
test
string
end
adjustwidth
normalsize
the
following
dialog
results
small
begin
adjustwidth
1cm
verbatiminput
c
gdb
test
log
end
adjustwidth
normalsize
To
exit
from
verb
gdb
one
uses
the
verb
quit
command
index
gdb
textbf
gdb
quit
command
If
you
are
attempting
to
verb
quit
after
a
program
has
terminated
successfully
verb
gdb
lets
you
verb
quit
directly
as
in
small
begin
adjustwidth
1cm
verb
gdb
quit
newline
verb
end
adjustwidth
normalsize
If
on
the
other
hand
the
program
has
terminated
unsuccessfully
verb
gdb
requests
that
you
verify
your
intention
to
quit
as
in
small
begin
adjustwidth
1cm
verb
gdb
quit
newline
verb
A
debugging
session
is
active
newline
verb
newline
verb
Inferior
1
process
26028
will
be
killed
newline
verb
newline
verb
Quit
anyway
y
or
n
y
newline
verb
end
adjustwidth
normalsize
subsection
Other
useful
commands
If
all
verb
gdb
provided
was
extra
information
about
the
source
of
the
fault
that
killed
your
program
it
would
not
have
to
be
interactive
The
real
power
of
a
debugger
is
that
it
lets
you
stop
the
execution
of
your
program
inspect
the
contents
of
memory
and
view
other
aspects
of
your
program
as
it
executes
One
useful
command
to
verb
gdb
is
to
inspect
the
sequence
of
calls
that
resulted
in
the
faulty
termination
of
your
program
This
command
is
verb
bt
for
textit
backtrace
verb
backtrace
is
also
index
gdb
textbf
gdb
backtrace
command
index
gdb
textbf
gdb
bt
command
see
backtrace
a
legal
command
to
obtain
this
functionality
Let
s
ask
for
the
backtrace
after
our
faulty
program
above
exits
with
a
segmentation
fault
small
begin
adjustwidth
1cm
verb
gdb
bt
newline
verb
1
0x00007ffff7ab8201
in
strlen
from
usr
lib
libc
so
6
newline
verb
2
0x000000000040055e
in
foo
len
s
0x0
at
test
c
8
newline
verb
3
0x0000000000400583
in
main
argc
1
argv
0x7fffffff3878
at
test
c
14
newline
verb
gdb
newline
end
adjustwidth
normalsize
For
this
simple
example
the
backtrace
corroborates
our
logic
above
regarding
the
source
of
the
segmentation
fault
A
particularly
useful
command
to
verb
gdb
is
to
set
a
emph
breakpoint
in
the
program
this
is
done
with
a
command
of
the
form
small
begin
adjustwidth
1cm
verb
gdb
break
textit
location
end
adjustwidth
normalsize
index
gdb
textbf
gdb
break
command
When
your
program
reaches
a
breakpoint
it
will
pause
and
control
returns
to
verb
gdb
You
must
set
your
initial
breakpoint
s
before
you
verb
run
the
program
you
may
introduce
additional
breakpoints
whenever
your
program
has
paused
and
verb
gdb
has
regained
control
Let
s
set
a
breakpoint
in
our
faulty
program
before
we
execute
it
footnote
The
boilerplate
text
from
texttt
gdb
will
no
longer
be
shown
in
dialogs
small
begin
adjustwidth
1cm
verbatiminput
c
gdb
breakpoint
log
end
adjustwidth
normalsize
We
specified
that
a
breakpoint
should
be
set
at
the
start
of
verb
foo
len
Alternatively
since
we
know
that
the
function
starts
at
line
8
of
test
c
we
could
have
specified
small
begin
adjustwidth
1cm
verb
gdb
break
test
c
8
end
adjustwidth
normalsize
In
fact
you
can
set
a
breakpoint
at
any
statement
in
your
source
files
they
do
not
have
to
coincide
with
the
start
of
a
function
Since
you
typically
will
not
know
the
line
numbers
for
your
source
files
setting
breakpoints
at
the
start
of
a
function
is
a
very
easy
way
to
pause
your
program
before
a
bug
manifests
itself
When
we
issue
the
verb
run
command
the
program
starts
to
execute
verb
main
when
verb
foo
len
is
invoked
control
returns
to
verb
gdb
At
the
verb
gdb
prompt
we
may
then
issue
other
commands
In
this
case
we
invoked
the
verb
print
command
to
see
what
the
value
index
gdb
textbf
gdb
print
command
is
for
the
argument
verb
s
which
is
shown
to
be
verb
0x0
note
that
the
function
arguments
are
provided
when
the
breakpoint
is
encountered
Note
also
that
when
we
asked
verb
gdb
to
print
the
value
of
verb
s
it
printed
verb
1
0x0
we
could
equally
have
asked
it
to
print
the
value
of
verb
1
as
verb
gdb
represents
the
arguments
to
a
function
positionally
as
verb
1
verb
2
You
can
use
the
verb
print
command
to
not
only
display
the
values
of
function
arguments
by
name
but
of
any
local
or
global
variables
by
name
as
well
If
a
variable
is
a
pointer
say
verb
struct
foo
p
specifying
verb
print
p
to
verb
gdb
will
cause
the
contents
of
the
verb
struct
foo
to
which
verb
p
currently
points
to
be
printed
out
Any
time
verb
gdb
regains
control
after
the
program
starts
running
we
can
continue
the
execution
of
the
program
by
issuing
the
verb
c
for
textit
continue
verb
continue
is
also
a
legal
command
index
gdb
textbf
gdb
continue
command
index
gdb
textbf
gdb
c
see
continue
to
obtain
this
functionality
command
We
can
also
single
step
our
program
after
execution
is
paused
There
are
two
forms
of
the
single
step
functionality
begin
itemize
noitemsep
item
The
next
line
of
code
is
executed
by
specifying
the
verb
step
command
index
gdb
textbf
gdb
step
command
This
will
execute
emph
just
the
next
line
of
code
If
the
next
line
of
code
contains
a
function
invocation
verb
step
emph
steps
into
that
function
This
enables
you
to
dive
deep
into
a
sequence
of
call
frames
to
get
to
the
bottom
of
your
problem
item
You
can
also
execute
the
next
line
of
code
by
specifying
the
verb
next
index
gdb
textbf
gdb
next
command
command
If
the
next
line
of
code
contains
a
function
invocation
using
verb
next
does
emph
not
step
into
that
function
Thus
verb
next
simply
enables
you
to
step
through
the
current
function
end
itemize
Typing
verb
step
or
verb
next
many
times
is
extremely
tedious
verb
gdb
interprets
a
bare
carriage
return
to
mean
re
execute
the
previous
command
Thus
if
you
need
to
step
next
through
many
lines
of
code
repeatedly
typing
verb
RETURN
will
eliminate
a
bit
of
the
tedium
We
can
clear
a
breakpoint
by
issuing
the
verb
clear
command
this
command
index
gdb
textbf
gdb
clear
command
requires
the
same
argument
as
used
in
a
verb
break
command
to
set
the
breakpoint
In
our
example
above
a
verb
clear
foo
len
command
will
remove
the
breakpoint
set
upon
entry
to
verb
foo
len
Breakpoints
permit
verb
gdb
to
regain
control
when
a
statement
is
about
to
be
executed
Another
way
for
verb
gdb
to
regain
control
is
through
emph
watchpoints
A
watchpoint
allows
you
to
monitor
the
values
of
variables
pausing
the
program
when
a
watched
variable
changes
value
To
set
a
watchpoint
you
use
the
verb
watch
command
small
begin
adjustwidth
1cm
verb
gdb
watch
my
var
end
adjustwidth
normalsize
index
gdb
textbf
gdb
watch
command
Now
whenever
verb
my
var
s
value
is
modified
the
program
is
paused
and
the
old
and
new
values
are
printed
verb
gdb
interprets
the
scope
of
the
variable
name
in
a
verb
watch
command
based
upon
the
program
scope
at
the
time
the
verb
watch
command
is
executed
This
means
that
you
can
set
watchpoints
for
global
variables
before
running
the
program
if
you
wish
to
set
a
watchpoint
for
a
static
local
variable
within
a
function
you
need
to
set
a
breakpoint
for
that
function
set
a
watchpoint
for
that
variable
when
the
function
is
entered
the
first
time
and
then
clear
the
breakpoint
There
are
a
multitude
of
other
features
provided
by
verb
gdb
Please
consult
materials
at
url
https
www
gnu
org
software
gdb
documentation
as
you
become
familiar
with
verb
gdb
section
Managing
heap
memory
Valgrind
is
a
program
execution
monitoring
framework
index
commands
textbf
commands
valgrind
It
comes
with
many
tools
the
tool
upon
which
we
are
focused
is
the
emph
memcheck
tool
Memcheck
detects
and
reports
the
following
types
of
memory
errors
begin
itemize
noitemsep
item
Use
of
unitialized
memory
item
Reading
writing
to
heap
memory
after
it
has
been
freed
item
Reading
writing
off
the
end
of
malloc
d
blocks
item
Heap
allocated
memory
leaks
item
Mismatched
use
of
malloc
vs
free
item
And
many
more
end
itemize
subsection
Invoking
texttt
valgrind
To
test
whether
verb
prog
arguments
correctly
allocates
and
uses
memory
we
run
it
with
verb
valgrind
as
follows
small
begin
adjustwidth
1cm
verb
valgrind
prog
arguments
end
adjustwidth
normalsize
As
with
verb
gdb
the
source
files
must
be
compiled
with
the
verb
g
flag
to
verb
gcc
index
valgrind
textbf
valgrind
g
flag
to
gcc
verb
valgrind
supports
a
large
number
of
options
the
user
manual
may
be
consulted
at
url
http
valgrind
org
docs
manual
manual
html
subsection
Use
of
unitialized
memory
verb
valgrind
keeps
track
of
each
program
variable
and
each
block
allocated
by
verb
malloc
to
determine
when
that
variable
block
has
been
written
to
If
your
program
attempts
to
read
from
a
variable
or
heap
block
before
it
has
been
initialized
verb
valgrind
will
flag
each
occurrence
appropriately
index
valgrind
textbf
valgrind
uninitialized
memory
check
Consider
the
following
program
small
begin
adjustwidth
1cm
verbatiminput
c
valgrind
uninit
c
end
adjustwidth
normalsize
When
executed
by
verb
valgrind
the
following
output
results
small
begin
adjustwidth
1cm
verbatiminput
c
valgrind
uninit
log
end
adjustwidth
normalsize
As
you
can
see
verb
valgrind
indicates
that
there
an
unitialized
value
was
used
in
main
at
line
8
of
uninit
c
subsection
Reading
writing
to
heap
memory
after
it
has
been
freed
verb
valgrind
keeps
track
of
each
verb
malloc
allocated
block
to
determine
when
it
is
returned
to
the
heap
index
valgrind
textbf
valgrind
writes
to
freed
memory
Attempts
to
access
an
already
freed
heap
block
cause
verb
valgrind
to
flag
each
occurrence
appropriately
Consider
the
following
program
small
begin
adjustwidth
1cm
verbatiminput
c
valgrind
alreadyfree
c
end
adjustwidth
normalsize
When
executed
by
verb
valgrind
the
following
output
results
small
begin
adjustwidth
1cm
verbatiminput
c
valgrind
alreadyfree
log
end
adjustwidth
normalsize
Apparently
verb
strcpy
attempts
to
access
the
first
and
last
byte
of
the
destination
string
thus
causing
verb
valgrind
to
flag
two
invalid
writes
subsection
Reading
writing
off
the
end
of
malloc
d
blocks
verb
valgrind
keeps
track
of
the
length
of
each
verb
malloc
allocated
block
to
check
for
attempted
access
beyond
the
allocation
Such
attempts
cause
verb
valgrind
to
flag
each
occurrence
appropriately
index
valgrind
textbf
valgrind
access
beyond
allocation
Consider
the
following
program
small
begin
adjustwidth
1cm
verbatiminput
c
valgrind
overrun
c
end
adjustwidth
normalsize
When
executed
by
verb
valgrind
the
following
output
results
small
begin
adjustwidth
1cm
verbatiminput
c
valgrind
overrun
log
end
adjustwidth
normalsize
This
program
shows
the
typical
cause
of
these
overrun
problems
forgetting
to
allocate
space
for
the
0
byte
at
the
end
of
a
string
Another
common
source
of
this
problem
is
to
allocate
an
array
of
emph
n
items
in
a
heap
memory
block
and
then
attempt
to
use
emph
n
as
an
index
into
that
block
forgetting
that
the
array
is
indexed
by
emph
0
n
1
subsection
Heap
allocated
memory
leaks
verb
valgrind
keeps
track
of
each
verb
malloc
allocated
block
to
determine
when
it
is
returned
to
the
heap
Attempts
to
terminate
the
program
when
there
are
still
outstanding
allocations
cause
verb
valgrind
to
flag
those
occurrences
index
valgrind
textbf
valgrind
memory
leaks
Consider
the
following
program
small
begin
adjustwidth
1cm
verbatiminput
c
valgrind
memleak
c
end
adjustwidth
normalsize
When
executed
by
verb
valgrind
the
following
output
results
small
begin
adjustwidth
1cm
verbatiminput
c
valgrind
memleak
log
end
adjustwidth
normalsize
If
you
wish
to
see
details
of
leaked
memory
use
the
following
invocation
small
begin
adjustwidth
1cm
verb
valgrind
leak
check
full
prog
arguments
end
adjustwidth
normalsize
index
valgrind
textbf
valgrind
leak
check
full
subsection
Mismatched
use
of
malloc
vs
free
verb
valgrind
keeps
track
of
each
verb
malloc
allocated
block
to
determine
when
it
is
returned
to
the
heap
Attempts
to
free
memory
that
is
not
allocated
e
g
has
already
been
verb
free
ed
or
is
an
address
that
does
not
reside
on
the
heap
cause
verb
valgrind
to
flag
those
occurrences
index
valgrind
textbf
valgrind
double
frees
Consider
the
following
program
small
begin
adjustwidth
1cm
verbatiminput
c
valgrind
dblfree
c
end
adjustwidth
normalsize
When
executed
by
verb
valgrind
the
following
output
results
small
begin
adjustwidth
1cm
verbatiminput
c
valgrind
dblfree
log
end
adjustwidth
normalsize
subsection
General
advice
verb
valgrind
is
an
enormously
useful
tool
Nearly
every
sophisticated
C
program
makes
extensive
use
of
the
heap
it
is
essential
that
all
memory
allocation
and
use
errors
be
eliminated
from
your
programs
The
previous
sections
have
demonstrated
how
different
types
of
memory
misuse
manifest
themselves
in
the
output
from
verb
valgrind
The
only
time
you
should
be
satisfied
that
you
have
eliminated
all
problems
with
your
memory
use
is
if
the
output
from
verb
valgrind
looks
like
the
following
dialog
small
begin
adjustwidth
1cm
verbatiminput
c
valgrind
allok
log
end
adjustwidth
normalsize
chapter
A
beginner
s
guide
to
Linux
label
ch
beginnersguide
section
Some
history
label
sec
somehistory
It
is
likely
that
you
have
been
using
computers
since
you
were
very
young
I
recall
sitting
my
2
year
old
niece
down
in
front
of
one
of
the
first
Macintosh
textsuperscript
TM
computers
to
play
a
game
called
Lode
Runner
in
1985
Admittedly
a
poor
baby
sitting
approach
but
it
did
the
trick
she
happily
punched
the
keys
for
nearly
an
hour
while
I
was
trying
to
finish
up
a
section
of
a
research
paper
using
paper
and
pencil
begin
wrapfigure
L
0
25
textwidth
centering
includegraphics
width
0
8
linewidth
linux
model33teletype
small
Model
33
teletype
newline
newline
newline
newline
includegraphics
width
0
8
linewidth
linux
adm3a
small
adm3a
terminal
newline
end
wrapfigure
The
very
first
interactive
computers
had
a
single
console
upon
which
output
from
programs
was
displayed
and
through
which
input
could
be
provided
using
the
keyboard
The
input
and
output
speeds
on
such
consoles
were
maddeningly
slow
but
one
could
at
least
get
on
with
the
job
The
console
shown
in
the
figure
also
had
a
paper
tape
reader
a
very
early
form
of
mass
storage
for
digital
information
Smiley
begin
wrapfigure
L
0
25
textwidth
centering
includegraphics
width
0
8
linewidth
adm3a
small
adm3a
terminal
end
wrapfigure
As
processors
became
more
powerful
and
memory
became
more
plentiful
computers
were
fitted
with
serial
line
devices
that
enabled
one
to
connect
terminals
to
the
system
Such
terminals
provided
a
similar
interface
to
the
system
as
the
console
but
usually
consisted
of
a
cathode
ray
tube
for
display
and
a
keyboard
a
window
of
80
character
lines
x
24
lines
of
fixed
width
font
characters
was
provided
on
the
CRT
and
the
typical
transmission
speeds
of
such
devices
was
30
times
faster
than
for
the
earlier
consoles
Multiple
people
could
be
connected
to
the
system
at
one
time
leading
to
time
sharing
systems
one
particular
time
sharing
system
that
was
popular
in
universities
and
among
computer
science
researchers
was
UNIX
textsuperscript
TM
UNIX
textsuperscript
TM
was
developed
by
Ken
Thompson
and
Dennis
Ritchie
at
Bell
Laboratories
along
with
contributions
from
many
of
the
other
researchers
at
the
Bell
Labs
Murray
Hill
facility
It
had
originally
been
implemented
to
ease
the
withdrawal
experienced
by
Thompson
and
Ritchie
when
they
were
recalled
from
the
Multics
Project
footnote
Elliott
I
Organick
1972
The
Multics
system
an
examination
of
its
structure
MIT
Press
Cambridge
MA
USA
UNIX
textsuperscript
TM
was
used
internally
within
Bell
Labs
until
Thompson
spent
a
sabbatical
year
at
Berkeley
as
with
all
good
computer
scientists
Thompson
took
his
environment
UNIX
textsuperscript
TM
with
him
when
others
at
Berkeley
discovered
the
power
and
simplicity
of
the
environment
Western
Electric
Bell
Labs
parent
company
was
persuaded
to
create
an
academic
license
that
enabled
Berkeley
and
other
university
computer
science
departments
to
have
access
to
the
system
Students
that
graduated
from
institutions
in
which
UNIX
textsuperscript
TM
was
used
found
themselves
also
experiencing
withdrawal
when
they
went
off
to
employment
in
industry
or
the
national
laboratories
the
licensing
of
UNIX
textsuperscript
TM
was
restricted
to
universities
Computer
system
vendors
such
as
HP
IBM
and
Sun
observed
this
demand
and
negotiated
licensing
arrangements
with
Western
Electric
to
produce
vendor
specific
versions
of
UNIX
textsuperscript
TM
for
their
workstations
and
servers
HP
HP
UX
IBM
AIX
Sun
SunOS
Since
these
were
vendor
specific
they
presented
slightly
different
libraries
and
system
calls
complicating
porting
of
code
between
the
platforms
To
eliminate
most
of
the
differences
the
vendors
through
the
activities
of
a
variety
of
consortia
worked
with
the
IEEE
to
create
the
POSIX
standards
to
define
a
standard
set
of
library
functions
that
could
be
depended
upon
when
programming
on
a
POSIX
compliant
system
One
particularly
unique
innovation
of
UNIX
textsuperscript
TM
was
how
it
read
commands
from
a
user
commonly
called
a
command
line
interpreter
CLI
Prior
operating
systems
usually
provided
a
privileged
program
sometimes
embedded
in
the
kernel
itself
for
reading
and
executing
commands
typed
by
the
user
through
their
terminal
The
UNIX
textsuperscript
TM
kernel
provided
a
complete
set
of
system
calls
enabling
processes
to
create
and
manage
other
processes
thus
the
CLI
could
simply
be
another
program
These
user
level
CLI
s
have
become
known
as
shells
since
the
very
first
such
CLI
was
called
the
shell
and
the
command
one
typed
to
invoke
the
shell
was
texttt
sh
texttt
sh
was
written
by
Steve
Bourne
Beginning
in
1991
Linus
Torvalds
began
work
to
create
a
new
free
operating
system
kernel
This
kernel
coupled
with
the
applications
from
the
GNU
project
has
eventually
become
known
as
Linux
Linux
is
open
source
licensed
under
the
GNU
General
Public
License
Given
its
open
source
nature
it
is
now
the
dominant
operating
system
used
in
academia
replacing
the
many
flavors
of
UNIX
textsuperscript
TM
section
The
user
interface
label
sec
theuserinterface
The
primary
interface
between
a
user
and
Linux
is
the
terminal
window
i
e
a
window
on
the
screen
that
emulates
the
80x24
terminal
windows
found
on
earlier
UNIX
textsuperscript
TM
systems
A
command
line
interpreter
usually
emph
bash
footnote
The
name
is
an
acronym
for
emph
Bourne
again
shell
a
pun
on
the
Bourne
shell
that
it
replaced
reads
each
command
line
typed
by
the
user
in
the
window
creates
one
or
more
processes
needed
to
execute
the
command
line
and
normally
waits
for
those
processes
to
finish
execution
before
prompting
the
user
for
another
command
line
This
is
obviously
quite
different
from
the
point
and
click
mechanism
with
which
you
are
undoubtedly
familiar
Linux
systems
do
provide
one
or
more
graphical
user
interfaces
that
support
the
point
and
click
mechanism
where
it
is
appropriate
e
g
invocation
of
your
browser
creation
of
another
terminal
window
Program
development
on
Linux
systems
is
nearly
always
performed
using
the
command
line
interface
provided
by
a
terminal
window
in
which
texttt
bash
is
executing
We
will
therefore
restrict
our
discussion
to
this
environment
section
The
command
line
interpreter
texttt
bash
label
sec
commandlineinterpreter
texttt
bash
reads
the
commands
typed
by
a
user
in
its
terminal
window
and
executes
those
commands
texttt
bash
displays
a
prompt
string
reads
the
line
of
input
typed
and
executes
the
command
The
prompt
string
can
be
customized
as
will
be
shown
later
until
then
we
will
use
the
string
as
the
prompt
Consider
the
following
example
footnote
You
are
encouraged
to
try
these
commands
on
your
Linux
system
as
you
read
along
You
should
see
the
same
or
similar
output
from
the
commands
footnote
In
the
examples
in
this
chapter
the
text
that
you
type
is
in
ttfamily
bfseries
boldface
while
that
displayed
by
the
shell
and
commands
is
in
texttt
normalface
begin
adjustwidth
1cm
small
verb
ttfamily
bfseries
date
verb
textit
show
today
s
date
newline
verb
Tue
Jun
27
15
09
02
PDT
2017
newline
verb
ttfamily
bfseries
pwd
verb
textit
print
the
current
working
directory
newline
verb
home
me
newline
verb
ttfamily
bfseries
date
pwd
verb
textit
a
semicolon
is
a
command
separator
newline
verb
Tue
Jun
27
15
09
43
PDF
2017
newline
verb
home
me
normalsize
end
adjustwidth
From
the
last
example
you
see
that
you
can
place
more
than
one
command
on
a
single
command
line
A
verb
is
a
command
separator
a
b
tells
the
shell
to
first
execute
textit
a
then
execute
textit
b
After
texttt
bash
displays
the
prompt
string
it
reads
everything
you
type
up
to
when
you
press
the
texttt
Enter
key
On
some
systems
the
key
is
labeled
texttt
Return
we
will
refer
to
it
as
the
texttt
Enter
key
in
this
text
If
you
wish
to
erase
a
character
before
pressing
texttt
Enter
you
should
press
the
texttt
Backspace
key
If
you
have
made
a
number
of
mistakes
and
wish
to
simply
erase
the
entire
line
and
start
again
you
can
type
emph
ctl
u
footnote
The
expression
emph
ctl
x
means
you
should
press
the
texttt
x
key
while
holding
down
the
texttt
Ctrl
key
sometimes
emph
ctl
u
is
called
the
emph
line
kill
character
Both
texttt
date
and
texttt
pwd
are
commands
that
do
not
require
any
additional
information
in
order
to
do
their
jobs
footnote
texttt
date
emph
can
take
a
number
of
arguments
that
determine
how
to
format
the
date
string
that
it
prints
Type
linux
man
date
as
a
search
string
in
your
favorite
browser
to
see
the
arguments
that
texttt
date
understands
Most
programs
require
additional
textit
command
arguments
to
provide
additional
information
to
the
program
while
it
is
executing
Consider
the
program
texttt
echo
it
has
a
particularly
simple
job
print
the
supplied
arguments
and
exit
as
in
the
following
examples
begin
adjustwidth
1cm
small
verb
ttfamily
bfseries
echo
this
verb
textit
print
this
on
the
output
newline
verb
this
newline
verb
ttfamily
bfseries
echo
this
and
that
verb
textit
print
this
and
that
newline
verb
this
and
that
newline
verb
ttfamily
bfseries
echo
this
verb
and
that
verb
textit
two
spaces
between
this
and
and
newline
verb
this
and
that
textit
the
extra
space
has
disappeared
newline
verb
ttfamily
bfseries
echo
verb
this
verb
and
that
verb
verb
textit
quote
the
input
newline
verb
this
and
that
textit
the
extra
space
was
maintained
newline
normalsize
end
adjustwidth
These
examples
demonstrate
a
number
of
features
of
texttt
bash
begin
itemize
item
The
shell
breaks
up
the
line
of
input
that
you
type
into
separate
words
the
words
can
be
separated
by
blanks
or
tabs
or
by
punctuation
like
the
semicolon
item
The
first
word
in
a
command
texttt
echo
above
is
the
program
to
execute
we
will
discuss
later
how
the
shell
looks
for
the
program
file
that
corresponds
to
that
word
item
The
other
words
in
the
command
are
provided
to
the
program
as
a
list
of
words
for
it
to
do
with
as
it
sees
fit
texttt
echo
simply
prints
each
of
these
words
placing
a
single
space
between
each
pair
of
words
item
It
does
not
matter
how
many
spaces
or
tabs
separate
two
words
it
does
not
change
the
list
of
words
that
the
shell
gives
to
the
program
item
If
you
want
to
have
many
words
in
a
single
argument
you
can
quote
the
phrase
using
verb
or
verb
In
the
last
example
above
texttt
echo
received
a
list
with
a
single
word
in
it
consisting
of
the
phrase
verb
this
and
that
emph
without
the
quote
characters
end
itemize
We
saw
earlier
that
texttt
bash
gives
a
special
meaning
to
the
character
verb
now
we
see
that
it
gives
special
meaning
to
verb
and
verb
as
well
In
fact
texttt
bash
gives
special
meanings
to
most
non
alphanumeric
characters
If
you
want
to
provide
an
argument
to
a
program
that
contains
a
non
alphanumeric
character
the
easiest
way
to
prevent
the
shell
from
giving
it
its
special
meaning
is
to
quote
the
argument
For
example
begin
adjustwidth
1cm
small
verb
ttfamily
bfseries
echo
A
semi
colon
verb
ttfamily
bfseries
verb
ttfamily
bfseries
is
a
command
separator
newline
verb
A
semi
colon
is
a
command
separator
newline
normalsize
end
adjustwidth
A
command
argument
that
needs
to
contain
an
apostrophe
verb
can
be
escaped
using
a
quotation
mark
verb
and
vice
versa
By
convention
command
arguments
that
start
with
verb
are
considered
flags
to
a
program
i
e
they
change
the
way
the
program
does
its
task
these
are
usually
a
single
letter
following
the
hyphen
and
are
called
emph
short
flags
index
bash
textbf
bash
short
flags
If
additional
information
is
required
when
a
short
flag
is
specified
that
information
must
be
the
next
word
that
immediately
follows
the
short
flag
as
in
verb
n
name
Finally
if
you
wish
to
specify
several
short
flags
on
a
single
command
line
you
can
usually
collapse
them
into
a
single
flag
e
g
verb
command
a
b
c
can
usually
be
written
as
verb
command
abc
A
second
flag
convention
called
emph
long
flags
has
a
flag
starting
with
verb
and
is
usually
written
out
in
full
for
example
verb
command
a
might
be
the
same
as
verb
command
all
index
bash
textbf
bash
long
flags
If
additional
information
is
required
when
a
long
flag
is
specified
it
is
written
as
verb
name
value
i
e
the
information
associated
with
the
flag
is
part
of
the
same
command
argument
word
You
will
note
in
the
previous
example
that
a
hyphen
verb
is
not
special
to
texttt
bash
nor
is
a
period
verb
footnote
This
latter
assertion
is
not
completely
true
if
the
1st
word
in
a
command
is
texttt
texttt
bash
does
something
special
The
equals
sign
verb
is
another
non
alphanumeric
character
that
has
no
special
meaning
to
texttt
bash
The
non
special
nature
of
these
characters
enables
these
two
flag
conventions
Let
s
look
at
examples
of
the
use
of
both
short
and
long
flags
The
command
texttt
ls
lists
the
files
found
in
one
or
more
directories
if
index
commands
textbf
commands
ls
no
directories
are
specified
the
files
in
the
current
directory
are
listed
texttt
ls
understands
a
number
of
flags
that
dictate
how
it
displays
the
files
in
a
directory
The
examples
below
show
both
the
short
and
long
form
of
some
of
these
flags
begin
adjustwidth
1cm
small
verb
ttfamily
bfseries
ls
verb
textit
list
the
contents
of
the
current
directory
newline
verb
book
calendar
data
Music
Pictures
shopping
list
src
newline
verb
ttfamily
bfseries
ls
a
verb
textit
list
the
entire
contents
of
the
current
directory
newline
verb
bashrc
vimrc
calendar
data
Pictures
src
newline
verb
profile
book
Music
shopping
list
newline
verb
ttfamily
bfseries
ls
verb
all
verb
textit
long
form
of
a
newline
verb
bashrc
vimrc
calendar
data
Pictures
src
newline
verb
profile
book
Music
shopping
list
newline
verb
ttfamily
bfseries
ls
verb
group
directories
first
verb
textit
places
directories
first
no
short
version
newline
verb
book
Music
Pictures
src
calendar
data
shopping
list
newline
verb
ttfamily
bfseries
ls
p
verb
textit
append
to
indicate
directories
newline
verb
bin
calendar
data
Music
Pictures
shopping
list
src
newline
verb
ttfamily
bfseries
ls
verb
indicator
style
slash
verb
textit
long
version
of
p
newline
verb
bin
calendar
data
Music
Pictures
shopping
list
src
newline
verb
ttfamily
bfseries
ls
t
verb
textit
display
files
ordered
by
modification
time
newest
first
newline
verb
shopping
list
calendar
data
newline
verb
ttfamily
bfseries
ls
rt
verb
textit
same
but
oldest
first
reverse
sort
newline
verb
calendar
data
shopping
list
newline
verb
ttfamily
bfseries
ls
w
20
verb
textit
output
is
20
characters
wide
newline
verb
calendar
data
newline
verb
shopping
list
newline
verb
ttfamily
bfseries
ls
verb
width
20
verb
textit
the
long
form
of
w
20
newline
verb
calendar
data
newline
verb
shopping
list
newline
normalsize
end
adjustwidth
After
any
flags
what
about
the
other
arguments
to
a
command
Most
commands
need
to
work
on
files
so
the
non
flag
arguments
are
typically
filenames
There
are
other
sorts
of
information
that
a
command
might
need
for
example
a
program
that
searches
for
textual
patterns
in
a
file
requires
at
least
one
argument
indicating
the
pattern
we
wish
to
find
In
the
last
four
examples
above
we
provided
as
an
argument
to
texttt
ls
What
does
that
mean
As
we
mentioned
previously
most
of
the
non
alphanumeric
characters
available
on
the
keyboard
have
a
special
meaning
to
texttt
bash
When
texttt
bash
breaks
up
the
command
into
words
it
looks
for
four
particular
special
characters
verb
verb
verb
and
verb
as
these
indicate
that
texttt
bash
should
perform
a
pattern
match
against
filenames
in
the
current
directory
In
the
last
four
texttt
ls
examples
above
indicates
that
texttt
bash
should
replace
that
string
by
all
filenames
that
consist
of
1
or
more
characters
before
a
verb
and
0
or
more
characters
after
In
our
directory
this
pattern
matches
exactly
two
files
texttt
calendar
data
and
texttt
shopping
list
texttt
bash
replaces
the
single
word
by
two
words
in
the
list
presented
to
texttt
ls
The
wildcard
character
verb
is
often
used
in
the
shell
to
select
a
subset
of
files
to
be
processed
by
the
command
The
verb
in
a
command
argument
indicates
that
it
matches
any
single
character
at
that
point
e
g
jo
n
matches
verb
john
or
verb
joan
but
not
verb
johan
The
square
brackets
enable
the
specification
of
a
range
of
characters
to
match
at
a
particular
location
in
the
filename
e
g
ls
a
ch
would
match
files
named
texttt
a
c
and
texttt
a
h
in
the
current
directory
but
would
emph
not
match
texttt
a
x
One
can
also
specify
a
range
of
characters
within
the
square
brackets
e
g
ls
a
d
would
match
any
files
that
end
in
verb
a
verb
b
verb
c
or
verb
d
footnote
Note
that
the
wildcard
expansion
is
done
by
texttt
bash
emph
not
by
the
command
itself
in
this
case
texttt
ls
By
performing
such
substitution
in
the
command
line
interpreter
it
means
that
all
programs
benefit
from
this
feature
What
should
you
do
if
you
start
a
program
by
mistake
Most
commands
can
be
stopped
by
typing
emph
ctl
c
often
known
as
the
texttt
INTERRUPT
character
Some
programs
like
text
editors
will
stop
whatever
the
program
is
doing
when
you
type
the
texttt
INTERRUPT
character
but
enable
you
to
issue
another
command
to
the
program
after
it
has
stopped
Closing
the
terminal
window
will
stop
most
programs
as
well
section
Simple
commands
label
sec
simplecommands
Linux
provides
you
with
a
number
of
simple
commands
to
manipulate
files
and
your
environment
This
section
covers
some
of
the
more
useful
ones
subsection
Obtaining
help
label
sec
obtaininghelp
Online
manual
pages
for
all
of
the
commands
in
Linux
are
available
over
the
Internet
it
is
a
good
idea
to
maintain
an
open
browser
window
while
you
are
working
so
that
you
can
access
these
manual
pages
A
search
query
of
the
form
linux
man
textit
command
will
yield
several
links
to
online
man
pages
for
textit
command
Additionally
there
is
a
directory
available
at
url
http
man7
org
linux
man
pages
dir
all
by
section
html
you
can
skim
it
quickly
for
commands
that
might
be
relevant
to
what
you
want
to
do
There
is
also
an
introduction
to
the
system
at
url
http
www
tldp
org
LDP
intro
linux
intro
linux
pdf
that
gives
an
overview
of
how
things
work
Depending
upon
how
complete
a
Linux
system
you
have
the
man
pages
for
most
of
your
commands
may
also
index
commands
textbf
commands
man
be
available
on
your
Linux
system
If
so
you
can
display
the
manual
page
for
textit
command
by
typing
man
textit
command
to
texttt
bash
Thus
to
read
about
the
texttt
ls
command
type
begin
adjustwidth
1cm
small
verb
ttfamily
bfseries
man
ls
verb
newline
normalsize
end
adjustwidth
subsection
Creating
files
label
sec
creatingfiles
Information
on
Linux
systems
is
stored
in
files
In
order
to
enter
information
into
a
file
as
well
as
to
modify
that
information
you
will
need
to
use
a
text
editor
It
is
likely
that
you
have
experience
using
emph
document
editors
such
as
Microsoft
textsuperscript
TM
Word
Document
editors
not
only
enable
you
to
enter
and
edit
information
in
a
document
it
also
enables
you
to
specify
how
that
information
should
be
formatted
when
it
is
displayed
Most
files
in
a
Linux
system
do
not
require
such
formatting
information
i
e
the
content
of
the
file
is
a
sequence
of
characters
with
the
end
of
line
being
the
only
type
of
formatting
needed
Every
Linux
system
has
several
screen
editors
the
one
you
choose
to
use
is
a
matter
of
personal
taste
The
Arch
Linux
image
described
in
Appendix
B
comes
with
texttt
nano
url
https
wiki
archlinux
org
index
php
nano
and
texttt
vi
url
https
wiki
archlinux
org
index
php
Vim
You
may
also
install
any
of
a
number
of
other
editors
such
as
texttt
emacs
and
texttt
gedit
See
url
https
en
wikipedia
org
wiki
List
of
text
editors
for
a
list
of
text
editors
that
has
been
compiled
in
Wikipedia
begin
exercise
small
Choose
a
screen
editor
If
your
editor
is
named
editor
it
is
likely
that
you
can
find
a
tutorial
or
three
available
on
the
web
with
a
search
query
of
the
form
editor
tutorial
begin
itemize
noitemsep
item
Work
your
way
through
your
chosen
tutorial
creating
and
editing
the
example
files
found
therein
item
Use
your
editor
to
create
a
new
file
in
your
home
directory
the
directory
in
which
you
are
placed
when
you
create
a
new
terminal
window
named
verb
Jabberwocky
and
containing
the
following
four
lines
footnote
This
is
the
first
stanza
from
the
poem
entitled
Jabberwocky
by
Lewis
Carroll
begin
adjustwidth
1cm
verb
Twas
brillig
and
the
slithy
toves
newline
verb
Did
gyre
and
gimble
in
the
wabe
newline
verb
All
mimsy
were
the
borogoves
newline
verb
And
the
mome
raths
outgrabe
newline
end
adjustwidth
item
Use
your
editor
to
create
verb
Jabberwocky1
starting
with
the
contents
of
verb
Jabberwocky
and
with
line
1
translated
into
modern
English
using
the
following
equivalences
begin
itemize
noitemsep
item
verb
Twas
verb
It
was
item
verb
brillig
verb
evening
item
verb
slithy
verb
smooth
active
item
verb
toves
verb
badgers
end
itemize
item
Use
your
editor
to
create
verb
Jabberwocky2
starting
with
the
contents
of
verb
Jabberwocky1
and
with
line
2
translated
into
modern
English
using
the
following
equivalences
begin
itemize
noitemsep
item
verb
gyre
verb
scratch
item
verb
gimble
verb
bore
holes
item
verb
wabe
verb
hill
side
end
itemize
item
Use
your
editor
to
create
verb
Jabberwocky3
starting
with
the
contents
of
verb
Jabberwocky2
and
with
line
3
translated
into
modern
English
using
the
following
equivalences
begin
itemize
noitemsep
item
verb
mimsy
verb
unhappy
item
verb
borogoves
verb
parrots
end
itemize
item
Use
your
editor
to
create
verb
Jabberwocky4
starting
with
the
contents
of
verb
Jabberwocky3
and
with
line
4
translated
into
modern
English
using
the
following
equivalences
begin
itemize
noitemsep
item
verb
mome
verb
solemn
item
verb
raths
verb
turtles
item
verb
outgrabe
verb
squeaked
out
end
itemize
end
itemize
When
you
have
finished
verb
Jabberwocky4
should
read
as
begin
adjustwidth
1cm
verb
It
was
evening
and
the
smooth
active
badgers
newline
verb
Did
scratch
and
bore
holes
in
the
hill
side
newline
verb
All
unhappy
were
the
parrots
newline
verb
And
the
solemn
turtles
squeaked
out
newline
end
adjustwidth
Box
normalsize
end
exercise
subsection
Listing
your
files
label
sec
listingyourfiles
We
have
previously
encountered
texttt
ls
in
section
ref
sec
commandlineinterpreter
index
commands
textbf
commands
ls
In
this
section
we
will
provide
examples
of
one
other
flag
to
texttt
ls
that
is
heavily
used
As
we
will
describe
in
the
next
section
Linux
stores
a
number
of
items
of
information
about
each
file
in
the
file
system
this
information
is
referred
to
as
emph
metadata
texttt
ls
can
be
used
to
see
some
of
this
metadata
needspace
8
baselineskip
begin
adjustwidth
1cm
small
verb
ttfamily
bfseries
ls
l
verb
newline
verb
total
24
newline
verb
drwxrwxr
x
2
me
me
4096
Jul
6
14
59
book
newline
verb
rw
rw
r
1
me
me
141
Jul
6
14
59
calendar
data
newline
verb
drwxrwxr
x
2
me
me
4096
Jul
6
14
59
Music
newline
verb
drwxrwxr
x
2
me
me
4096
Jul
6
14
59
Pictures
newline
verb
rw
rw
r
1
me
me
86
Jul
6
14
59
shopping
list
newline
verb
drwxrwxr
x
2
me
me
4096
Jul
6
14
59
src
newline
normalsize
end
adjustwidth
As
you
can
see
the
texttt
l
flag
gives
a
long
listing
that
provides
this
metadata
the
first
line
indicates
the
number
of
blocks
of
disk
space
occupied
by
the
listed
files
Each
subsequent
line
provides
information
about
an
individual
file
begin
itemize
item
the
first
character
indicates
if
the
file
is
a
directory
texttt
d
or
a
normal
file
texttt
item
the
next
9
characters
indicate
permissions
to
read
write
or
execute
the
file
the
first
3
characters
are
for
the
owner
of
the
file
texttt
me
in
this
case
the
next
3
characters
are
for
the
group
with
which
this
file
is
associated
texttt
me
is
the
associated
group
the
next
3
characters
are
for
everyone
else
item
next
we
have
the
number
of
links
to
the
file
this
will
be
discussed
in
the
next
section
on
the
file
system
item
the
owner
of
the
file
texttt
me
and
the
associated
group
texttt
me
follow
item
next
we
have
the
size
of
the
file
in
bytes
item
this
is
followed
by
the
month
day
and
time
of
last
modification
item
and
finally
we
have
the
name
of
the
file
end
itemize
We
previously
noted
that
after
all
of
the
flags
one
can
specify
one
or
more
file
names
to
texttt
ls
which
then
restricts
its
activity
to
those
files
For
example
begin
adjustwidth
1cm
small
verb
ttfamily
bfseries
ls
l
calendar
data
verb
newline
verb
rw
rw
r
1
me
me
141
Jul
6
14
59
calendar
data
newline
normalsize
end
adjustwidth
begin
exercise
small
Use
verb
ls
to
perform
a
long
listing
of
your
verb
Jabberwocky
files
How
does
the
size
of
the
file
change
going
from
the
original
to
the
final
translated
version
Is
it
as
you
expected
newline
Box
normalsize
end
exercise
subsection
Naming
your
files
label
sec
namingyourfiles
index
file
system
textbf
file
system
naming
Most
operating
systems
and
Linux
is
no
exception
have
rules
about
creating
legal
filenames
Firstly
there
is
usually
a
limit
on
the
length
of
a
filename
early
operating
systems
had
very
severe
restrictions
Linux
restricts
the
length
of
a
filename
to
255
characters
It
is
unusual
for
anyone
to
want
to
type
that
many
characters
as
an
argument
to
a
command
so
in
practice
you
will
usually
use
far
fewer
letters
in
your
filenames
Secondly
what
are
the
legal
characters
in
a
filename
Linux
allows
any
character
in
a
filename
except
for
texttt
and
a
null
character
this
does
emph
not
mean
that
you
should
start
putting
lots
of
strange
characters
in
your
filenames
The
POSIX
specification
footnote
url
http
pubs
opengroup
org
onlinepubs
9699919799
basedefs
V1
chap03
html
tag
03
280
is
quite
clear
on
characters
to
use
in
filenames
that
are
portable
across
emph
all
POSIX
conformant
systems
footnote
Linux
is
a
POSIX
conformant
system
begin
itemize
item
any
upper
case
character
from
the
set
texttt
ABCDEFGHIJKLMNOPQRSTUVWXYZ
item
any
lower
case
character
from
the
set
texttt
abcdefghijklmnopqrstuvwxyz
item
any
digit
from
the
set
texttt
0123456789
and
item
any
character
from
the
set
texttt
end
itemize
We
have
already
seen
that
texttt
is
used
to
introduce
flags
in
bash
command
lines
so
you
are
emph
strongly
recommended
to
avoid
starting
your
filenames
with
a
texttt
We
have
also
seen
above
that
filenames
that
start
with
a
texttt
are
emph
hidden
i
e
they
are
not
displayed
by
texttt
ls
unless
you
specify
the
texttt
a
or
verb
all
flags
thus
you
should
avoid
starting
your
filenames
with
a
texttt
unless
you
want
their
existence
to
be
hidden
in
this
way
subsection
What
s
in
a
file
label
sec
whatsinafile
We
often
try
to
give
files
descriptive
names
in
order
to
remember
their
contents
When
that
fails
one
often
resorts
to
displaying
the
contents
of
the
file
to
jog
one
s
memory
You
could
certainly
use
your
favorite
editor
to
display
the
contents
using
whatever
commands
it
provides
While
this
works
it
is
not
the
most
efficient
way
to
display
the
contents
since
the
editor
is
designed
to
enable
you
to
emph
modify
the
file
Linux
provides
several
commands
that
can
be
used
to
display
the
contents
of
a
file
index
commands
textbf
commands
cat
begin
itemize
item
The
simplest
program
is
texttt
cat
which
simply
prints
the
contents
of
each
file
argument
on
the
terminal
begin
adjustwidth
1cm
small
verb
ttfamily
bfseries
cat
shopping
list
verb
newline
verb
1
bottle
of
milk
newline
verb
2
granny
smith
apples
newline
verb
10
hot
house
tomatoes
newline
verb
1
six
pack
of
Coca
Cola
newline
normalsize
end
adjustwidth
item
texttt
cat
works
perfectly
well
for
short
files
like
texttt
shopping
list
but
for
very
long
files
the
contents
will
be
displayed
so
rapidly
in
your
terminal
window
that
you
will
only
see
the
last
screenful
of
lines
normally
24
lines
in
the
terminal
window
Linux
provides
two
commands
that
will
show
one
screenful
at
a
time
waiting
for
an
action
from
the
user
to
continue
the
display
to
search
for
a
pattern
or
to
perform
other
tasks
begin
itemize
item
texttt
more
is
an
especially
primitive
program
for
paging
through
text
one
screenful
at
a
time
index
commands
textbf
commands
more
Often
this
is
all
that
is
needed
item
Counterintuitively
texttt
less
is
a
program
similar
to
texttt
more
but
with
more
index
commands
textbf
commands
less
features
such
as
backward
movement
in
the
file
additionally
texttt
less
does
not
have
to
read
the
entire
input
file
before
starting
so
with
large
input
files
it
starts
up
emph
much
faster
than
text
editors
like
texttt
vi
end
itemize
end
itemize
subsection
Moving
copying
removing
files
texttt
mv
texttt
cp
texttt
rm
label
sec
movingcopyingremovingfiles
In
your
prior
experience
with
computer
systems
you
will
have
had
the
occasional
need
to
rename
a
file
On
Linux
this
is
done
with
the
texttt
mv
command
index
commands
textbf
commands
mv
begin
adjustwidth
1cm
small
verb
ttfamily
bfseries
mv
shopping
list
Shopping
List
verb
newline
verb
ttfamily
bfseries
ls
verb
newline
verb
calendar
data
Shopping
List
newline
verb
ttfamily
bfseries
cat
shopping
list
verb
newline
verb
cat
shopping
list
No
such
file
or
directory
newline
normalsize
end
adjustwidth
The
file
texttt
shopping
list
has
been
moved
to
a
file
named
texttt
Shopping
List
The
old
filename
has
disappeared
as
evidenced
by
the
output
from
texttt
ls
and
texttt
cat
This
example
also
shows
that
filenames
are
case
sensitive
i
e
the
name
texttt
shopping
list
is
different
from
texttt
Shopping
List
faWarning
textbf
If
the
target
filename
in
an
texttt
mv
command
already
exists
it
is
replaced
To
make
a
emph
copy
of
a
file
one
uses
the
texttt
cp
command
index
commands
textbf
commands
cp
begin
adjustwidth
1cm
small
verb
ttfamily
bfseries
cp
Shopping
List
20170706
shopping
list
verb
newline
normalsize
end
adjustwidth
saves
an
archive
copy
of
the
file
texttt
Shopping
List
To
remove
a
file
one
uses
the
texttt
rm
command
index
commands
textbf
commands
rm
begin
adjustwidth
1cm
small
verb
ttfamily
bfseries
rm
Shopping
List
shopping
list
verb
newline
verb
rm
cannot
remove
shopping
list
No
such
file
or
directory
newline
normalsize
end
adjustwidth
As
you
can
see
texttt
rm
warns
you
if
one
of
the
files
specified
did
not
exist
You
can
then
invoke
texttt
ls
to
verify
that
texttt
rm
did
its
job
begin
adjustwidth
1cm
small
verb
ttfamily
bfseries
ls
verb
newline
verb
20170706
shopping
list
calendar
data
newline
normalsize
end
adjustwidth
subsection
Other
useful
programs
label
sec
otherusefulprograms
Let
s
re
create
our
shopping
list
file
recall
that
we
removed
it
above
for
use
with
the
other
programs
described
in
this
section
begin
adjustwidth
1cm
small
verb
ttfamily
bfseries
cp
20170706
shopping
list
shopping
list
verb
newline
verb
ttfamily
bfseries
cat
shopping
list
verb
newline
verb
1
bottle
of
milk
newline
verb
2
granny
smith
apples
newline
verb
10
hot
house
tomatoes
newline
verb
1
six
pack
of
Coca
Cola
newline
normalsize
end
adjustwidth
subsubsection
Count
lines
words
and
characters
texttt
wc
label
sec
wc
Suppose
we
need
to
know
the
number
of
different
types
of
items
that
are
contained
in
the
shopping
list
index
commands
textbf
commands
wc
We
could
count
the
number
of
lines
on
the
screen
after
displaying
the
file
using
texttt
cat
this
type
of
processing
of
files
happens
often
enough
that
the
program
texttt
wc
is
provided
texttt
wc
counts
the
number
of
characters
words
each
word
is
a
sequence
of
non
whitespace
characters
separated
from
other
words
by
whitespace
and
lines
The
number
of
lines
in
texttt
shopping
list
is
exactly
what
we
need
begin
adjustwidth
1cm
small
verb
ttfamily
bfseries
wc
shopping
list
verb
newline
verb
4
17
85
shopping
list
newline
verb
ttfamily
bfseries
wc
l
shopping
list
verb
newline
verb
4
shopping
list
newline
verb
ttfamily
bfseries
wc
w
shopping
list
calendar
data
verb
newline
verb
17
shopping
list
newline
verb
19
calendar
data
newline
verb
36
total
newline
normalsize
end
adjustwidth
If
we
simply
invoke
texttt
wc
without
any
flags
it
will
print
the
number
of
lines
number
of
words
and
number
of
characters
for
each
file
specified
in
the
command
line
If
we
specify
texttt
l
texttt
wc
restricts
itself
to
counting
lines
texttt
w
or
texttt
c
restricts
texttt
wc
to
counting
words
or
characters
respectively
If
more
than
one
file
is
specified
in
the
command
line
texttt
wc
displays
the
counts
for
each
file
and
provides
a
total
in
each
category
at
the
end
subsubsection
Translate
or
delete
characters
texttt
tr
label
sec
tr
index
commands
textbf
commands
tr
It
often
happens
that
you
have
a
need
to
translate
and
or
delete
characters
in
a
file
verb
tr
copies
its
standard
input
to
standard
output
translating
or
deleting
characters
as
described
by
its
arguments
Let
s
look
at
some
simple
examples
begin
adjustwidth
1cm
small
verb
ttfamily
bfseries
tr
a
A
verb
newline
verb
ttfamily
bfseries
abacus
verb
newline
verb
AbAcus
newline
textit
ctl
d
verb
textit
you
type
this
to
indicate
end
of
file
newline
verb
ttfamily
bfseries
tr
d
x
verb
newline
verb
ttfamily
bfseries
xerxes
verb
newline
verb
eres
newline
textit
ctl
d
newline
verb
ttfamily
bfseries
tr
upper
lower
verb
newline
verb
ttfamily
bfseries
This
Is
A
Test
verb
newline
verb
this
is
a
test
newline
textit
ctl
d
newline
verb
ttfamily
bfseries
tr
s
blank
textbackslash
n
verb
newline
verb
ttfamily
bfseries
This
Is
A
Test
verb
newline
verb
This
newline
verb
Is
newline
verb
A
newline
verb
Test
newline
textit
ctl
d
newline
normalsize
end
adjustwidth
The
first
invocation
tells
verb
tr
to
replace
all
occurrences
of
a
by
A
Since
verb
tr
is
a
simple
filter
only
reads
standard
input
and
writes
to
standard
output
it
reads
verb
abacus
from
the
keyboard
and
writes
verb
AbAcus
to
the
terminal
window
Note
the
use
of
textit
ctl
d
typed
to
the
keyboard
to
indicate
end
of
file
from
the
keyboard
The
second
invocation
indicates
that
verb
tr
should
delete
all
occurrences
of
the
letter
x
found
in
the
standard
input
The
third
invocation
indicates
that
all
upper
case
characters
on
standard
input
must
be
converted
to
their
lower
case
equivalents
verb
tr
understands
a
number
of
character
class
arguments
such
as
verb
upper
see
the
verb
tr
man
entry
for
a
complete
list
The
final
invocation
tells
verb
tr
to
translate
each
horizontal
white
space
character
blank
or
tab
to
an
end
of
line
character
Sequences
of
multiple
horizontal
white
space
characters
are
squeezed
into
a
single
horizontal
white
space
character
before
the
translation
is
performed
As
you
can
see
this
causes
each
word
in
the
file
to
be
placed
on
a
line
of
its
own
subsubsection
Report
omit
or
count
repeated
lines
texttt
uniq
label
sec
uniq
index
commands
textbf
commands
uniq
The
default
behavior
for
verb
uniq
is
to
copy
standard
input
to
standard
output
replacing
each
sequence
of
matching
lines
by
a
single
instance
of
that
line
If
the
verb
c
flag
is
specified
it
precedes
each
line
by
the
number
of
occurrences
in
that
sequence
The
following
show
an
original
file
for
which
there
are
emph
no
sequences
of
matching
lines
and
the
resulting
output
when
that
file
is
processed
using
verb
uniq
c
small
begin
adjustwidth
1cm
verbatiminput
linux
uniq
out
end
adjustwidth
normalsize
As
one
would
expect
all
of
the
lines
of
input
are
reproduced
on
the
output
preceded
by
a
count
of
1
Now
let
s
see
what
happens
if
we
sort
the
input
file
using
verb
sort
and
the
output
that
results
when
the
sorted
file
is
processed
using
verb
uniq
c
small
begin
adjustwidth
1cm
verbatiminput
linux
uniqsorted
out
end
adjustwidth
normalsize
As
expected
verb
uniq
discovered
two
successive
lines
consisting
solely
of
the
it
only
output
one
line
for
the
but
preceded
by
a
count
of
2
Note
that
verb
uniq
is
case
sensitive
so
although
the
sorted
file
contained
successive
lines
of
this
followed
by
This
these
were
not
seen
as
a
sequence
of
matching
lines
and
each
was
output
with
a
count
of
1
We
will
use
verb
uniq
later
in
this
chapter
to
show
the
power
of
pipelines
in
verb
bash
subsubsection
Find
occurrence
of
a
pattern
texttt
grep
label
sec
grep
Suppose
we
do
not
remember
whether
we
added
apples
to
our
shopping
list
index
commands
textbf
commands
grep
The
command
texttt
grep
which
stands
for
textbf
g
et
textbf
r
egular
textbf
e
xpression
and
textbf
p
rint
will
search
the
file
arguments
for
lines
that
match
a
pattern
The
following
shows
us
using
texttt
grep
to
answer
our
question
about
apples
begin
adjustwidth
1cm
small
verb
ttfamily
bfseries
grep
apple
shopping
list
verb
newline
verb
2
granny
smith
apples
newline
normalsize
end
adjustwidth
Thus
we
see
that
we
did
add
granny
smith
apples
to
the
list
We
see
that
the
first
non
flag
argument
to
texttt
grep
is
the
pattern
to
search
for
in
this
case
it
is
simply
the
string
apple
texttt
grep
understands
much
more
powerful
patterns
called
emph
regular
expressions
we
recommend
that
you
consult
the
Linux
man
entry
for
texttt
grep
for
more
discussion
of
these
more
powerful
patterns
Suppose
that
your
friend
purchased
apples
on
the
way
home
from
class
so
that
you
do
not
need
to
purchase
them
when
you
go
to
the
store
the
following
shows
how
to
print
all
lines
that
do
emph
not
match
the
pattern
begin
adjustwidth
1cm
small
verb
ttfamily
bfseries
grep
v
apple
shopping
list
verb
newline
verb
1
bottle
of
milk
newline
verb
10
hot
house
tomatoes
newline
verb
1
six
pack
of
Coca
Cola
newline
normalsize
end
adjustwidth
If
you
specify
two
or
more
file
arguments
to
texttt
grep
it
will
prefix
each
matching
line
with
the
name
of
the
file
in
which
it
was
found
begin
adjustwidth
1cm
small
verb
ttfamily
bfseries
grep
apple
shopping
list
calendar
data
verb
newline
verb
shopping
list
2
granny
smith
apples
newline
normalsize
end
adjustwidth
Unsurprisingly
the
term
apple
is
not
found
in
texttt
calendar
data
even
so
since
we
specified
two
filenames
in
the
texttt
grep
command
it
prefixes
the
matching
line
in
texttt
shopping
list
with
the
name
of
the
file
subsubsection
Sorting
files
texttt
sort
label
sec
sort
This
command
sorts
its
input
into
alphabetical
order
by
default
index
commands
textbf
commands
sort
The
order
can
be
changed
using
various
flags
which
will
be
shown
below
Let
s
sort
our
shopping
list
begin
adjustwidth
1cm
small
verb
ttfamily
bfseries
sort
shopping
list
verb
newline
verb
1
bottle
of
milk
newline
verb
1
six
pack
of
Coca
Cola
newline
verb
10
hot
house
tomatoes
newline
verb
2
granny
smith
apples
newline
normalsize
end
adjustwidth
Note
that
the
default
sorting
order
of
characters
is
blank
then
digit
then
upper
case
letter
then
lower
case
letter
This
explains
why
the
milk
line
appears
before
the
Coke
line
s
in
six
comes
after
b
in
bottle
why
the
tomatoes
line
appears
after
the
Coke
line
1
comes
before
10
and
why
the
apple
line
comes
last
2
comes
after
1
As
indicated
above
texttt
sort
has
many
options
to
control
the
sort
order
e
g
numerical
order
by
field
within
each
line
reverse
the
order
Here
are
some
examples
again
using
texttt
shopping
list
begin
adjustwidth
1cm
small
verb
ttfamily
bfseries
sort
r
shopping
list
verb
textit
reverse
the
order
of
the
sort
newline
verb
2
granny
smith
apples
newline
verb
10
hot
house
tomatoes
newline
verb
1
six
pack
of
Coca
Cola
newline
verb
1
bottle
of
milk
newline
verb
ttfamily
bfseries
sort
n
shopping
list
verb
textit
numeric
sort
on
first
field
newline
verb
1
bottle
of
milk
newline
verb
1
six
pack
of
Coca
Cola
newline
verb
2
granny
smith
apples
newline
verb
10
hot
house
tomatoes
newline
verb
ttfamily
bfseries
sort
k
2
shopping
list
verb
textit
sort
on
2
textsuperscript
nd
field
newline
verb
1
bottle
of
milk
newline
verb
2
granny
smith
apples
newline
verb
10
hot
house
tomatoes
newline
verb
1
six
pack
of
Coca
Cola
newline
normalsize
end
adjustwidth
Note
that
a
field
is
defined
as
a
sequence
of
non
whitespace
characters
separated
from
other
fields
by
whitespace
characters
Thus
textbf
b
ottle
textless
textbf
g
ranny
textless
textbf
h
ot
textless
textbf
s
ix
in
the
last
example
above
subsubsection
Beginning
and
end
of
a
file
texttt
head
and
texttt
tail
label
sec
headtail
We
discussed
texttt
more
and
texttt
less
above
for
displaying
the
contents
of
a
file
A
very
common
occurrence
is
the
need
to
just
see
the
first
few
lines
or
the
last
few
lines
of
a
file
This
capability
is
provided
by
texttt
head
and
texttt
tail
respectively
as
shown
in
the
following
examples
index
commands
textbf
commands
head
index
commands
textbf
commands
tail
begin
adjustwidth
1cm
small
verb
ttfamily
bfseries
head
shopping
list
verb
textit
print
the
first
10
lines
newline
verb
1
bottle
of
milk
newline
verb
2
granny
smith
apples
newline
verb
10
hot
house
tomatoes
newline
verb
1
six
pack
of
Coca
Cola
newline
verb
ttfamily
bfseries
head
n
1
shopping
list
verb
textit
print
the
first
line
newline
verb
1
bottle
of
milk
newline
verb
ttfamily
bfseries
head
verb
lines
1
shopping
list
verb
textit
print
the
first
line
newline
verb
1
bottle
of
milk
newline
verb
ttfamily
bfseries
tail
shopping
list
verb
textit
print
the
last
10
lines
newline
verb
1
bottle
of
milk
newline
verb
2
granny
smith
apples
newline
verb
10
hot
house
tomatoes
newline
verb
1
six
pack
of
Coca
Cola
newline
verb
ttfamily
bfseries
tail
n
1
shopping
list
verb
textit
print
the
last
line
newline
verb
1
six
pack
of
Coca
Cola
newline
verb
ttfamily
bfseries
tail
verb
lines
1
shopping
list
verb
textit
print
the
last
line
newline
verb
1
six
pack
of
Coca
Cola
newline
normalsize
end
adjustwidth
subsubsection
Comparing
files
texttt
cmp
and
texttt
diff
label
sec
cmpdiff
It
is
common
to
need
to
compare
files
to
understand
emph
if
they
are
different
and
if
they
are
emph
how
they
differ
Earlier
in
this
chapter
we
made
a
copy
of
texttt
shopping
list
named
texttt
20170706
shopping
list
Perhaps
as
part
of
a
dietary
regimen
we
need
to
keep
the
shopping
list
that
we
use
each
day
begin
adjustwidth
1cm
small
verb
ttfamily
bfseries
cat
20170706
shopping
list
verb
newline
verb
1
bottle
of
milk
newline
verb
2
granny
smith
apples
newline
verb
10
hot
house
tomatoes
newline
verb
1
six
pack
of
Coca
Cola
newline
normalsize
end
adjustwidth
We
have
discovered
that
we
do
not
eat
enough
tomatoes
such
that
we
are
building
up
a
tomato
mountain
in
the
kitchen
Therefore
we
change
the
quantity
of
tomatoes
in
texttt
shopping
list
to
3
instead
of
10
as
shown
below
begin
adjustwidth
1cm
small
verb
ttfamily
bfseries
cat
shopping
list
verb
newline
verb
1
bottle
of
milk
newline
verb
2
granny
smith
apples
newline
verb
3
hot
house
tomatoes
newline
verb
1
six
pack
of
Coca
Cola
newline
normalsize
end
adjustwidth
Just
before
you
go
to
the
store
you
cannot
remember
if
you
changed
the
quantity
of
tomatoes
or
not
You
could
just
display
the
file
and
look
for
the
changes
but
there
may
have
been
many
changes
and
we
sometimes
do
not
see
subtle
textual
differences
Therefore
we
can
rely
upon
comparison
tools
to
help
us
out
The
first
comparison
program
texttt
cmp
compares
the
two
files
and
reports
the
first
difference
that
it
finds
index
commands
textbf
commands
cmp
begin
adjustwidth
1cm
small
verb
ttfamily
bfseries
cmp
shopping
list
20170706
shopping
list
verb
newline
verb
shopping
list
20170706
shopping
list
differ
byte
40
line
3
newline
normalsize
end
adjustwidth
While
texttt
cmp
has
indicated
we
made
some
change
to
texttt
shopping
list
we
want
to
verify
that
we
made
the
correct
change
just
in
case
This
is
where
texttt
diff
comes
handy
index
commands
textbf
commands
diff
needspace
4
baselineskip
begin
adjustwidth
1cm
small
verb
ttfamily
bfseries
diff
shopping
list
20170706
shopping
list
verb
newline
verb
3c3
newline
verb
3
hot
house
tomatoes
newline
verb
newline
verb
10
hot
house
tomatoes
newline
normalsize
end
adjustwidth
The
3c3
line
indicates
that
only
line
3
of
the
two
files
are
different
lines
preceded
by
textless
are
lines
in
the
first
file
texttt
shopping
list
in
this
case
and
lines
preceded
by
textgreater
are
lines
in
the
second
file
texttt
20170706
shopping
list
in
this
case
If
there
had
been
more
than
one
difference
in
the
two
files
each
such
difference
would
have
been
shown
in
this
way
begin
exercise
small
Use
verb
diff
to
compare
your
verb
Jabberwocky
files
An
easy
way
to
do
this
is
to
use
the
following
command
to
verb
bash
begin
adjustwidth
1cm
verb
for
n
in
1
2
3
4
do
newline
verb
diff
Jabberwocky
Jabberwocky
n
newline
verb
done
newline
end
adjustwidth
Note
how
verb
diff
shows
you
the
smallest
number
of
changes
needed
to
convert
from
the
first
file
argument
to
the
second
Is
the
output
as
you
expected
newline
Box
normalsize
end
exercise
section
The
file
system
label
sec
thefilesystem
We
have
introduced
the
basic
notion
of
a
file
and
metadata
about
a
file
in
the
previous
section
Now
we
need
to
understand
how
Linux
organizes
the
file
system
begin
wrapfigure
R
0
4
textwidth
centering
label
CaDS
tree
includegraphics
width
1
0
linewidth
linux
DirectoryTree
small
Partial
directory
tree
end
wrapfigure
In
your
previous
computing
experience
you
have
undoubtedly
been
exposed
to
folders
via
a
graphical
user
interface
A
folder
contains
files
and
often
other
folders
Double
clicking
on
a
folder
usually
causes
its
contents
to
be
displayed
Double
clicking
on
a
file
in
a
folder
usually
causes
an
application
associated
with
that
type
of
file
to
execute
on
that
file
Most
systems
provide
some
way
to
visualize
the
file
tree
hierarchy
here
is
the
hierarchy
for
the
current
state
of
this
book
Note
that
directories
are
shown
in
textbf
textcolor
blue
blue
and
files
are
shown
in
textbf
textcolor
OliveGreen
green
Different
folders
can
each
contain
a
file
with
the
same
name
such
as
texttt
shopping
list
for
example
although
the
contents
of
the
files
are
different
This
means
that
the
unique
name
for
a
file
is
a
sequence
of
directories
from
the
root
to
the
file
itself
for
example
in
this
directory
tree
rooted
at
texttt
CaDS
the
unique
name
for
texttt
shopping
list
is
the
sequence
of
names
verb
CaDS
ch02
me
shopping
list
This
complete
sequence
of
names
is
termed
a
emph
pathname
as
it
describes
a
path
from
the
root
to
the
index
file
system
textbf
file
system
pathname
file
that
is
of
interest
Linux
provides
a
hierarchical
file
system
of
this
type
The
root
of
the
tree
has
the
name
texttt
and
the
complete
pathname
for
texttt
shopping
list
assuming
that
texttt
CaDS
is
a
directory
in
the
root
would
be
verb
CaDS
ch02
me
shopping
list
i
e
the
complete
pathname
starts
with
the
root
and
each
subsequent
pair
of
names
in
the
path
are
separated
by
texttt
While
this
overloading
of
the
use
of
texttt
may
seem
strange
one
quickly
becomes
accustomed
to
it
Given
such
a
hierarchical
structure
it
is
common
to
use
family
terms
to
describe
the
relationships
between
directories
If
a
directory
texttt
a
contains
a
directory
texttt
b
texttt
a
is
the
emph
parent
of
texttt
b
and
texttt
b
is
the
emph
child
of
texttt
a
texttt
a
s
parent
is
the
emph
grandparent
of
texttt
b
and
so
on
subsection
Current
working
directory
and
home
directory
label
sec
cwdandhome
index
file
system
textbf
file
system
current
working
directory
It
would
be
extremely
tedious
to
have
to
type
the
full
pathname
each
time
you
wanted
to
refer
to
a
file
so
texttt
bash
maintains
a
notion
of
your
emph
current
working
directory
It
also
maintains
a
notion
of
your
emph
home
directory
which
has
been
assigned
to
you
when
your
account
was
created
whenever
you
start
up
a
terminal
window
your
current
working
directory
is
your
home
directory
If
you
type
a
file
name
that
does
emph
not
start
with
a
texttt
it
assumes
that
you
are
naming
the
file
relative
to
the
current
working
directory
All
of
the
examples
in
the
previous
sections
of
this
chapter
assume
that
our
current
working
directory
is
verb
CaDS
ch02
me
such
that
invoking
verb
cat
shopping
list
will
yield
the
contents
of
texttt
shopping
list
on
the
screen
index
file
system
textbf
file
system
home
directory
For
the
purposes
of
this
textbook
your
home
directory
is
verb
home
me
Your
home
directory
never
changes
while
your
current
working
directory
can
as
we
will
now
show
footnote
We
will
no
longer
show
the
text
you
type
in
textbf
boldface
It
should
be
obvious
as
it
follows
the
texttt
bash
prompt
begin
adjustwidth
1cm
small
verb
pwd
textit
what
is
our
current
working
directory
newline
verb
home
me
textit
just
started
bash
we
are
in
our
home
directory
newline
verb
ls
p
textit
what
s
in
our
home
directory
newline
verb
20170706
shopping
list
calendar
data
Pictures
src
newline
verb
book
Music
shopping
list
newline
verb
cd
Music
textit
change
into
the
Music
directory
newline
verb
pwd
textit
let
s
see
if
we
were
successful
newline
verb
home
me
Music
textit
yes
we
were
newline
verb
ls
textit
what
s
in
the
Music
directory
nothing
newline
verb
cd
pwd
textit
go
up
one
level
in
the
directory
hierarchy
newline
verb
home
me
textit
we
are
back
home
newline
verb
cd
src
pwd
cd
pwd
textit
cd
into
src
what
does
cd
without
a
directory
do
newline
verb
home
me
src
newline
verb
home
me
textit
ok
cd
without
a
directory
takes
us
home
newline
verb
cd
home
me
Pictures
pwd
textit
we
can
specify
a
full
pathname
to
cd
as
well
newline
verb
home
me
Pictures
newline
verb
cd
pwd
textit
what
does
textasciitilde
mean
newline
verb
home
me
textit
ok
it
s
shorthand
for
home
newline
normalsize
end
adjustwidth
You
may
wonder
why
we
need
the
verb
shorthand
for
the
home
directory
it
can
be
used
as
the
first
character
of
a
pathname
as
in
verb
shopping
list
to
access
files
that
are
in
your
home
directory
Thus
no
matter
where
your
current
working
directory
is
in
the
hierarchy
you
can
easily
access
files
that
are
directly
reachable
from
your
home
directory
The
use
of
verb
seems
a
little
strange
for
referring
to
the
parent
of
our
current
working
directory
Why
is
this
the
case
Remember
when
we
used
the
texttt
a
flag
to
texttt
ls
earlier
begin
adjustwidth
1cm
small
verb
pwd
newline
verb
home
me
newline
verb
ls
a
newline
verb
bashrc
vimrc
calendar
data
Pictures
src
newline
verb
profile
book
Music
shopping
list
newline
normalsize
end
adjustwidth
Notice
that
there
are
two
entries
in
the
directory
named
verb
and
verb
These
entries
were
placed
in
the
directory
when
the
directory
was
created
verb
points
to
the
parent
of
this
directory
here
it
points
to
texttt
home
verb
points
to
the
directory
itself
here
it
points
to
texttt
home
me
index
file
system
textbf
file
system
index
file
system
textbf
file
system
Let
s
navigate
up
the
tree
to
see
what
happens
begin
adjustwidth
1cm
small
verb
cd
Music
pwd
textit
let
s
start
somewhere
interesting
newline
verb
home
me
Music
newline
verb
cd
pwd
textit
go
up
one
level
newline
verb
home
me
newline
verb
cd
pwd
textit
again
newline
verb
home
newline
verb
cd
pwd
textit
and
again
newline
verb
newline
verb
cd
pwd
textit
will
this
work
newline
verb
newline
normalsize
end
adjustwidth
We
see
from
this
little
experiment
that
the
root
is
its
own
parent
we
can
ask
to
change
our
working
directory
to
root
s
parent
but
we
stay
in
the
same
place
Just
as
we
can
use
verb
as
shorthand
for
our
home
directory
we
can
use
use
verb
as
shorthand
for
our
current
directory
and
verb
as
shorthand
for
the
parent
of
our
current
directory
Consider
the
following
commands
the
examples
refer
to
the
file
system
shown
on
page
pageref
CaDS
tree
begin
adjustwidth
1cm
small
verb
pwd
newline
verb
CaDS
ch02
me
newline
verb
ls
p
newline
verb
adm3a
jpg
ch02
synctex
gz
DirectoryTree
pdf
me
tgz
newline
verb
ch02
pdf
ch02
tex
me
model33teletype
jpg
newline
verb
cd
Music
pwd
newline
verb
CaDS
ch02
me
Music
newline
verb
cat
shopping
list
textit
Need
to
look
at
shopping
list
again
newline
verb
1
bottle
of
milk
newline
verb
2
granny
smith
apples
newline
verb
3
hot
house
tomatoes
newline
verb
1
six
pack
of
Coca
Cola
newline
verb
head
n
1
me
shopping
list
textit
Admittedly
unusual
but
works
newline
verb
1
bottle
of
milk
newline
verb
cd
tail
n
1
shopping
list
textit
name
treated
identically
to
name
newline
verb
1
six
pack
of
Coca
Cola
newline
normalsize
end
adjustwidth
label
sec
dotanddotdot
The
last
two
examples
are
meant
to
show
that
you
can
introduce
verb
and
verb
as
elements
of
a
pathname
The
last
example
may
seem
strange
but
later
you
will
see
a
situation
where
using
verb
comes
in
handy
subsection
Creating
a
new
directory
texttt
mkdir
label
sec
mkdir
index
commands
textbf
commands
mkdir
Let
s
suppose
that
we
want
to
create
a
directory
to
hold
all
of
our
archival
shopping
lists
begin
adjustwidth
1cm
small
verb
cd
textit
go
home
newline
verb
mkdir
ShoppingLists
textit
create
our
directory
newline
verb
cd
ShoppingLists
textit
make
it
our
working
directory
newline
verb
ls
a
textit
what
s
in
a
newly
created
directory
newline
verb
textit
only
the
link
to
our
parent
and
ourselves
newline
verb
cd
textit
up
to
our
parent
newline
verb
ls
l
ShoppingLists
textit
it
s
empty
so
no
output
from
ls
newline
verb
ls
dl
ShoppingLists
textit
d
flag
says
describe
the
directory
newline
verb
drwxrwxr
x
2
me
me
4096
Jul
11
16
00
ShoppingLists
newline
normalsize
end
adjustwidth
There
is
also
an
texttt
rmdir
command
that
can
be
used
to
remove
a
directory
this
will
only
work
emph
if
index
commands
textbf
commands
rmdir
the
directory
is
empty
i
e
the
only
entries
in
the
directory
are
verb
and
verb
subsection
The
Linux
hierarchical
file
system
structure
label
sec
Linuxfilesystem
index
Linux
file
system
Linux
organizes
all
of
the
files
in
the
system
into
a
single
hierarchy
There
can
be
millions
of
files
in
the
file
system
of
a
single
Linux
system
for
the
Arch
Linux
system
used
in
this
book
there
are
textgreater
160
000
files
and
textgreater
13
000
directories
newpage
begin
wrapfigure
R
0
25
textwidth
includegraphics
scale
0
55
linux
root
tree
end
wrapfigure
For
typical
use
of
a
Linux
system
the
most
important
directories
are
begin
itemize
noitemsep
item
texttt
bin
contains
basic
progams
like
texttt
bash
that
are
required
during
the
boot
process
item
texttt
sbin
contains
programs
that
must
be
accessed
by
the
system
administrator
item
texttt
lib
contains
dynamic
libraries
and
static
support
files
needed
in
the
boot
process
item
texttt
etc
contains
configuration
files
for
the
system
item
texttt
home
contains
the
home
director
for
each
user
texttt
home
me
in
our
case
item
texttt
usr
has
several
important
sub
directories
begin
itemize
noitemsep
item
texttt
usr
bin
contains
programs
that
are
accessed
by
all
users
item
texttt
usr
sbin
contains
programs
that
must
be
accessed
by
the
system
administrator
item
texttt
usr
lib
contains
dynamic
libraries
and
static
support
files
for
the
programs
in
texttt
usr
bin
and
texttt
usr
sbin
item
texttt
usr
include
contains
include
files
needed
by
C
and
C
programs
item
texttt
usr
share
doc
and
texttt
usr
share
man
contain
manuals
documentation
examples
etc
item
texttt
usr
local
has
texttt
bin
texttt
include
texttt
lib
texttt
etc
etc
directories
for
locally
added
software
end
itemize
end
itemize
section
Back
to
the
shell
label
sec
backtotheshell
subsection
Environment
variables
label
sec
environmentvariables
We
have
already
discussed
how
the
shell
breaks
up
the
command
you
typed
into
words
uses
the
1
textsuperscript
st
word
in
that
sequence
to
find
the
program
to
run
and
passes
all
of
the
other
words
to
the
program
for
it
to
interpret
Besides
passing
these
arguments
to
a
program
it
also
maintains
a
set
of
name
value
pairs
that
it
provides
to
the
program
for
it
to
use
if
it
wishes
this
set
of
name
value
pairs
is
known
as
the
emph
environment
index
bash
textbf
bash
environment
The
command
to
type
to
see
what
is
currently
in
the
environment
is
texttt
env
begin
adjustwidth
1cm
small
verb
env
textit
display
the
environment
newline
verb
textit
several
variables
specific
to
particular
programs
newline
verb
XTERM
SHELL
bin
bash
textit
the
shell
reading
a
new
terminal
window
newline
verb
USER
me
textit
my
identity
newline
verb
PWD
home
me
textit
my
current
working
directory
newline
verb
HOME
home
me
textit
my
home
directory
newline
verb
textit
many
other
variables
specific
to
particular
programs
newline
verb
PATH
usr
local
sbin
usr
local
bin
usr
bin
usr
bin
site
perl
newline
verb
usr
bin
vendor
perl
usr
bin
core
perl
newline
verb
textit
many
other
variables
specific
to
particular
programs
newline
normalsize
end
adjustwidth
index
bash
textbf
bash
environment
variable
Each
environment
variable
has
a
name
consisting
of
upper
case
letters
digits
and
underscores
verb
Each
is
displayed
in
the
form
NAME
value
We
can
use
our
friend
texttt
echo
to
see
the
current
value
of
a
particular
environment
variable
as
follows
begin
adjustwidth
1cm
small
verb
echo
USER
textit
what
is
the
current
value
of
USER
newline
verb
me
textit
as
we
expected
newline
normalsize
end
adjustwidth
When
texttt
bash
encounters
verb
ENVIRONMENT
VARIABLE
NAME
in
a
command
line
it
replaces
it
with
the
current
value
of
that
variable
Thus
in
the
example
above
texttt
bash
replaces
verb
USER
with
verb
me
sending
that
as
the
command
argument
to
texttt
echo
which
dutifully
prints
verb
me
on
the
terminal
Environment
variables
are
just
a
specific
case
of
shell
variables
which
enable
the
user
to
assign
values
to
names
and
refer
to
those
values
using
the
verb
name
syntax
index
bash
textbf
bash
shell
variable
How
does
one
establish
the
value
of
a
variable
How
does
one
remove
a
variable
How
does
one
make
that
variable
part
of
the
environment
The
easiest
way
to
answer
these
questions
is
to
show
a
number
of
examples
begin
adjustwidth
1cm
small
verb
ID
usr
local
include
textit
ID
has
a
very
long
value
newline
verb
echo
ID
textit
did
it
work
newline
verb
usr
local
include
textit
yes
newline
verb
bash
textit
create
a
child
process
running
bash
newline
verb
echo
ID
textit
see
if
the
child
process
knows
the
value
of
ID
newline
verb
textit
no
it
is
not
part
of
the
environment
newline
verb
exit
textit
exit
the
child
texttt
bash
process
newline
verb
export
ID
textit
make
this
variable
part
of
the
environment
newline
verb
bash
textit
create
a
child
process
running
bash
newline
verb
echo
ID
textit
see
if
the
child
process
knows
the
value
of
ID
newline
verb
usr
local
include
textit
yes
newline
verb
exit
textit
exit
the
child
texttt
bash
process
newline
verb
unset
ID
textit
remove
ID
from
the
set
of
variables
newline
verb
echo
ID
textit
make
sure
it
has
been
removed
newline
verb
textit
yes
it
has
no
value
newline
normalsize
end
adjustwidth
texttt
bash
makes
the
environment
available
to
the
process
that
it
creates
to
run
your
program
the
program
can
access
the
value
associated
with
an
environment
variable
through
a
library
call
texttt
getenv
provided
by
the
system
index
bash
textbf
bash
search
path
A
particular
environment
variable
texttt
PATH
is
of
particular
importance
to
texttt
bash
as
it
tells
index
bash
textbf
bash
shell
variable
PATH
texttt
bash
where
to
look
for
the
program
that
you
have
requested
texttt
PATH
consists
of
a
sequence
of
directory
names
separated
by
colons
verb
After
texttt
bash
has
broken
up
your
command
into
words
it
then
proceeds
to
search
for
an
executable
file
with
the
name
you
have
specified
in
each
component
of
texttt
PATH
until
it
either
finds
such
a
file
or
it
has
exhausted
the
texttt
PATH
In
the
former
case
it
then
runs
the
program
in
a
process
giving
it
the
remaining
arguments
for
it
to
process
A
standard
program
is
provided
which
will
perform
this
search
emph
without
starting
up
the
program
texttt
which
Let
s
look
at
it
in
action
begin
adjustwidth
1cm
small
verb
which
bash
textit
where
is
bash
stored
newline
verb
usr
bin
bash
newline
verb
which
wc
textit
where
is
wc
stored
newline
verb
usr
bin
wc
newline
verb
which
pyhton3
textit
look
for
python3
but
a
typo
newline
verb
which
no
pyhton3
in
usr
local
sbin
usr
local
bin
usr
bin
newline
verb
usr
bin
site
perl
usr
bin
vendor
perl
usr
bin
core
perl
newline
verb
pyhton3
textit
let
s
see
what
bash
says
newline
verb
bash
pyhton3
command
not
found
newline
normalsize
end
adjustwidth
From
these
examples
we
can
deduce
a
couple
of
things
begin
itemize
noitemsep
item
most
of
the
standard
programs
are
in
texttt
usr
bin
and
item
if
the
command
you
have
typed
cannot
be
found
using
texttt
PATH
texttt
bash
will
report
it
and
texttt
which
will
also
report
the
search
path
used
end
itemize
While
this
is
interesting
if
the
search
path
was
fixed
then
there
would
not
be
much
point
in
discussing
it
Fortunately
since
texttt
PATH
is
an
environment
variable
you
can
change
it
and
texttt
bash
will
begin
to
use
the
new
version
of
texttt
PATH
on
the
very
next
command
you
type
Before
showing
you
how
this
is
done
why
might
we
want
to
change
texttt
PATH
We
ve
previously
discussed
the
texttt
usr
local
branch
of
the
file
system
as
a
place
where
site
specific
programs
are
typically
installed
on
your
system
You
really
wouldn
t
want
to
put
these
programs
in
texttt
usr
bin
since
the
next
release
of
the
operating
system
would
require
you
to
remember
all
of
the
non
standard
programs
that
you
placed
in
texttt
usr
bin
so
that
you
could
reinstall
them
Sometimes
you
want
a
site
specific
version
of
one
of
the
standard
programs
and
whenever
that
program
is
invoked
you
want
the
site
specific
version
to
be
found
instead
of
the
standard
one
And
finally
you
might
want
to
have
a
number
of
your
own
programs
it
is
very
easy
to
do
that
you
use
regularly
and
you
want
texttt
bash
to
be
able
to
find
them
in
the
same
way
Note
that
the
search
performed
by
texttt
bash
goes
from
left
to
right
in
the
sequence
of
directories
that
make
up
texttt
PATH
Thus
if
you
want
to
find
your
version
of
texttt
ls
instead
of
the
one
stored
in
texttt
usr
bin
then
your
version
will
have
to
be
in
a
directory
that
is
earlier
in
texttt
PATH
than
texttt
usr
bin
Let
s
experiment
with
this
a
bit
begin
adjustwidth
1cm
small
verb
mkdir
bin
textit
let
s
create
a
personal
bin
directory
newline
verb
cp
usr
bin
ls
bin
textit
make
a
copy
of
ls
in
that
directory
newline
verb
sudo
cp
usr
bin
ls
usr
local
bin
textit
make
a
copy
in
usr
local
bin
newline
verb
sudo
password
for
me
textit
type
your
password
followed
by
Enter
no
echo
newline
verb
ls
l
bin
ls
usr
local
bin
ls
usr
bin
ls
newline
verb
rwxr
xr
x
1
me
me
130552
Jul
12
15
11
home
me
bin
ls
newline
verb
rwxr
xr
x
1
root
root
130552
Mar
12
07
09
usr
bin
ls
newline
verb
rwxr
xr
x
1
root
root
130552
Jul
12
15
10
usr
local
bin
ls
newline
verb
PATH
usr
bin
bin
textit
set
path
to
just
usr
bin
and
bin
newline
verb
which
ls
newline
verb
usr
bin
ls
textit
found
it
in
usr
bin
newline
verb
PATH
usr
local
bin
PATH
textit
insert
usr
local
bin
at
the
front
newline
verb
which
ls
newline
verb
usr
local
bin
ls
textit
found
it
in
usr
local
bin
newline
verb
PATH
bin
PATH
textit
insert
textasciitilde
bin
at
the
front
newline
verb
which
ls
newline
verb
home
me
bin
ls
textit
found
it
in
textasciitilde
bin
newline
verb
rm
bin
ls
textit
remove
copy
from
textasciitilde
bin
newline
verb
which
ls
newline
verb
usr
local
bin
ls
textit
found
it
in
usr
local
bin
newline
verb
sudo
rm
usr
local
bin
ls
textit
remove
copy
from
usr
local
bin
newline
verb
sudo
password
for
me
newline
verb
which
ls
newline
verb
usr
bin
ls
textit
found
it
in
usr
bin
newline
verb
echo
PATH
newline
verb
home
me
bin
usr
local
bin
usr
bin
bin
newline
normalsize
end
adjustwidth
Only
two
tricky
things
in
this
exercise
begin
itemize
noitemsep
item
as
can
be
done
in
most
programming
languages
we
can
define
a
new
value
for
a
variable
in
terms
of
its
previous
value
thus
the
expression
verb
PATH
usr
local
bin
PATH
causes
the
shell
to
append
the
current
value
of
texttt
PATH
verb
PATH
to
the
string
texttt
usr
local
bin
and
to
assign
the
concatenated
string
as
the
new
value
of
texttt
PATH
and
index
commands
textbf
commands
sudo
item
there
is
a
command
available
in
Linux
texttt
sudo
that
allows
you
to
become
the
root
user
to
exercise
one
command
if
you
perform
verb
ls
dl
usr
local
bin
you
will
see
that
it
is
owned
by
the
texttt
root
user
and
you
do
not
have
write
permission
to
that
directory
by
using
the
texttt
sudo
command
you
can
perform
the
requested
command
first
texttt
cp
to
create
the
copy
there
and
later
texttt
rm
to
remove
the
copy
as
if
you
were
the
root
user
the
Arch
Linux
virtual
machine
knows
that
your
account
texttt
me
is
permitted
to
use
texttt
sudo
all
you
need
to
do
is
type
your
password
to
be
able
to
perform
the
command
end
itemize
subsection
Input
output
error
output
label
sec
inputoutputerror
So
far
we
have
focused
on
typing
commands
on
the
keyboard
to
the
shell
the
shell
parses
each
command
to
determine
which
program
to
run
it
creates
a
process
to
run
that
program
and
the
shell
makes
the
arguments
and
the
environment
available
to
that
program
The
shell
then
waits
for
that
program
to
finish
before
prompting
the
user
for
another
command
All
of
our
examples
so
far
take
some
action
and
output
the
results
to
the
screen
if
a
program
detects
something
wrong
it
displays
an
error
message
on
the
screen
Computers
would
be
not
nearly
as
useful
to
us
if
this
was
all
that
could
be
done
index
bash
textbf
bash
standard
input
index
bash
textbf
bash
standard
output
index
bash
textbf
bash
standard
error
output
When
a
program
comes
to
life
three
data
channels
are
defined
begin
itemize
noitemsep
item
standard
input
this
is
the
default
channel
from
which
the
program
can
read
data
it
is
normally
the
keyboard
item
standard
output
this
is
the
default
channel
to
which
the
program
can
write
results
of
its
processing
it
is
normally
the
terminal
window
and
item
standard
error
output
this
is
the
default
channel
to
which
the
program
can
write
error
messages
it
is
normally
the
terminal
window
end
itemize
The
shell
sets
up
these
standard
channels
for
a
program
when
it
starts
it
in
a
process
Thus
the
shell
is
in
a
position
to
emph
redirect
these
channels
to
files
or
other
objects
in
the
system
index
bash
textbf
bash
IO
redirection
subsubsection
Input
redirection
label
sec
inputredirection
First
let
s
focus
on
taking
our
input
from
a
file
instead
of
the
keyboard
index
bash
textbf
bash
standard
input
redirection
consider
the
following
example
begin
adjustwidth
1cm
small
verb
cd
textit
make
sure
we
are
home
newline
verb
cat
shopping
list
textit
reacquaint
ourselves
with
shopping
list
newline
verb
1
bottle
of
milk
newline
verb
2
granny
smith
apples
newline
verb
3
hot
house
tomatoes
newline
verb
1
six
pack
of
Coca
Cola
newline
verb
cat
textit
invoke
without
a
filename
newline
verb
line
1
textit
you
type
this
newline
verb
line
1
textit
cat
echoes
the
line
newline
textit
ctl
d
verb
textit
you
type
this
to
indicate
end
of
file
newline
verb
cat
shopping
list
textit
what
is
this
newline
verb
1
bottle
of
milk
textit
we
obtain
the
same
results
as
before
newline
verb
2
granny
smith
apples
newline
verb
3
hot
house
tomatoes
newline
verb
1
six
pack
of
Coca
Cola
newline
normalsize
end
adjustwidth
There
are
several
things
going
on
here
that
make
this
work
begin
itemize
noitemsep
item
when
texttt
cat
is
invoked
if
any
arguments
are
supplied
it
copies
the
contents
of
those
files
to
the
terminal
window
item
if
invoked
without
any
arguments
it
copies
the
standard
input
to
the
terminal
window
item
in
the
first
case
above
where
texttt
cat
was
invoked
without
arguments
the
standard
input
was
the
keyboard
thus
you
had
to
type
on
the
keyboard
to
provide
texttt
cat
with
characters
that
it
could
write
to
the
terminal
window
note
that
textit
ctl
d
is
the
character
to
type
at
the
keyboard
to
indicate
an
end
of
file
item
in
the
second
case
above
the
shell
interpreted
verb
shopping
list
to
mean
that
standard
input
for
texttt
cat
should
come
from
texttt
shopping
list
not
from
the
keyboard
it
resets
standard
input
for
texttt
cat
to
be
from
the
file
emph
and
removes
verb
shopping
list
from
the
set
of
arguments
made
available
to
texttt
cat
item
texttt
cat
doesn
t
care
as
it
has
been
invoked
without
any
arguments
so
it
simply
reads
from
standard
input
until
an
end
of
file
is
detected
end
itemize
Thus
we
see
that
texttt
bash
interprets
yet
another
special
character
texttt
textless
to
indicate
that
the
standard
input
for
the
program
should
come
from
a
file
rather
than
from
the
keyboard
This
redirection
occurs
without
emph
any
knowledge
on
the
part
of
the
program
texttt
cat
in
this
case
Correct
behavior
does
demand
that
the
program
read
from
standard
input
if
it
has
not
received
any
file
arguments
footnote
Some
programs
such
as
texttt
cat
understand
an
argument
consisting
solely
of
a
hyphen
texttt
to
mean
that
it
should
also
read
from
the
standard
input
as
in
texttt
cat
file1
file2
i
e
copy
contents
of
texttt
file1
to
the
terminal
window
then
copy
the
contents
from
standard
input
to
the
terminal
window
and
finally
copy
contents
of
texttt
file2
to
the
terminal
window
The
man
page
for
a
particular
command
will
indicated
if
a
particular
program
interprets
a
bare
in
this
way
subsubsection
Output
redirection
label
sec
outputredirection
Often
one
would
like
to
capture
the
output
of
a
program
into
a
file
not
have
it
displayed
in
the
index
bash
textbf
bash
standard
output
redirection
terminal
window
in
fact
in
creating
this
textbook
a
large
number
of
files
have
been
generated
in
this
way
in
order
to
show
you
the
actual
interaction
dialogs
that
occur
on
the
system
Let
s
consider
the
following
example
begin
adjustwidth
1cm
small
verb
echo
ls
l
ls
l
textit
show
command
and
output
newline
verb
ls
l
newline
verb
total
24
newline
verb
drwxrwxr
x
2
me
me
4096
Jul
6
14
59
book
newline
verb
rw
rw
r
1
me
me
141
Jul
6
14
59
calendar
data
newline
verb
drwxrwxr
x
2
me
me
4096
Jul
6
14
59
Music
newline
verb
drwxrwxr
x
2
me
me
4096
Jul
6
14
59
Pictures
newline
verb
rw
rw
r
1
me
me
86
Jul
6
14
59
shopping
list
newline
verb
drwxrwxr
x
2
me
me
4096
Jul
6
14
59
src
newline
verb
echo
ls
l
tmp
out
textit
where
is
the
output
newline
verb
ls
l
tmp
out
textit
and
this
output
newline
verb
cat
tmp
out
textit
maybe
it
s
in
here
newline
verb
ls
l
textit
yes
it
is
newline
verb
total
24
newline
verb
drwxrwxr
x
2
me
me
4096
Jul
6
14
59
book
newline
verb
rw
rw
r
1
me
me
141
Jul
6
14
59
calendar
data
newline
verb
drwxrwxr
x
2
me
me
4096
Jul
6
14
59
Music
newline
verb
drwxrwxr
x
2
me
me
4096
Jul
6
14
59
Pictures
newline
verb
rw
rw
r
1
me
me
86
Jul
6
14
59
shopping
list
newline
verb
drwxrwxr
x
2
me
me
4096
Jul
6
14
59
src
newline
normalsize
end
adjustwidth
Thus
we
see
that
there
is
yet
another
special
character
understood
by
the
shell
If
it
detects
an
argument
of
the
form
verb
filename
it
redirects
the
program
s
standard
output
to
that
file
If
it
detects
an
argument
of
the
form
verb
filename
it
redirects
the
program
s
standard
output
to
the
end
of
that
file
i
e
its
output
is
appended
to
the
current
contents
of
the
file
The
ability
to
perform
such
redirection
emph
again
depends
upon
each
program
writing
to
standard
output
by
default
It
s
a
bit
clunky
having
to
break
up
our
original
command
line
verb
echo
ls
l
ls
l
into
separate
commands
and
appending
the
output
of
all
but
the
first
command
to
the
file
The
shell
also
understands
grouping
commands
to
act
as
a
single
command
such
that
you
can
redirect
the
input
or
output
for
the
command
in
one
go
as
in
begin
adjustwidth
1cm
small
verb
echo
ls
l
ls
l
tmp
out
textit
group
the
enclosed
commands
newline
verb
cat
tmp
out
newline
verb
ls
l
newline
verb
total
24
newline
verb
drwxrwxr
x
2
me
me
4096
Jul
6
14
59
book
newline
verb
rw
rw
r
1
me
me
141
Jul
6
14
59
calendar
data
newline
verb
drwxrwxr
x
2
me
me
4096
Jul
6
14
59
Music
newline
verb
drwxrwxr
x
2
me
me
4096
Jul
6
14
59
Pictures
newline
verb
rw
rw
r
1
me
me
86
Jul
6
14
59
shopping
list
newline
verb
drwxrwxr
x
2
me
me
4096
Jul
6
14
59
src
newline
normalsize
end
adjustwidth
Parentheses
more
special
characters
can
be
used
to
group
the
enclosed
commands
into
a
single
command
and
all
of
the
output
appropriately
serialized
can
be
directed
to
a
file
The
way
that
this
is
done
is
that
the
shell
acts
as
if
you
had
typed
the
following
command
begin
adjustwidth
1cm
small
verb
bash
c
echo
ls
l
ls
l
tmp
out
newline
normalsize
end
adjustwidth
i
e
it
creates
a
subshell
executing
the
enclosed
commands
with
the
standard
output
of
that
subshell
redirected
to
texttt
tmp
out
This
also
shows
you
that
the
standard
input
and
standard
output
of
commands
executed
by
a
shell
in
the
absence
of
redirection
are
the
standard
input
and
standard
output
of
the
shell
itself
subsubsection
Error
redirection
label
sec
errorredirection
It
stands
to
reason
that
since
we
can
redirect
standard
input
and
standard
output
it
is
likely
that
we
can
redirect
standard
error
output
as
well
index
bash
textbf
bash
standard
error
output
redirection
You
might
think
that
the
right
way
to
do
this
would
be
to
select
another
special
character
say
Frowny
and
for
texttt
bash
to
interpret
Frowny
texttt
filename
to
mean
redirect
standard
error
output
to
texttt
filename
and
to
interpret
Frowny
Frowny
texttt
filename
to
mean
to
redirect
standard
error
output
to
the
end
of
texttt
filename
Unfortunately
texttt
bash
has
used
up
all
of
the
special
characters
we
have
not
introduced
all
of
them
yet
Instead
texttt
bash
interprets
texttt
2
textgreater
filename
and
texttt
2
textgreater
textgreater
filename
to
mean
that
standard
error
output
should
be
redirected
Let
s
look
at
some
examples
of
standard
error
output
redirection
begin
adjustwidth
1cm
small
verb
cat
Shoping
list
textit
typo
in
filename
newline
verb
cat
Shoping
list
No
such
file
or
directory
newline
verb
cat
Shoping
list
2
tmp
err
textit
capture
the
error
message
in
a
file
newline
verb
cat
tmp
err
textit
see
if
it
is
there
newline
verb
cat
Shoping
list
No
such
file
or
directory
newline
verb
cat
readme
1st
2
tmp
err
textit
try
another
non
existent
file
newline
verb
cat
tmp
err
textit
see
if
it
is
there
newline
verb
cat
Shoping
list
No
such
file
or
directory
newline
verb
cat
readme
1st
No
such
file
or
directory
newline
normalsize
end
adjustwidth
Usually
one
does
not
redirect
standard
error
output
to
a
file
instead
we
want
the
error
messages
to
be
displayed
on
the
screen
so
that
we
can
see
the
error
messages
as
our
programs
run
Occasionally
especially
if
a
set
of
commands
are
all
being
executed
by
the
shell
with
the
output
of
the
commands
redirected
to
a
file
we
would
also
like
to
see
the
error
messages
embedded
in
the
same
file
so
we
can
see
the
context
in
which
the
errors
occur
much
as
we
would
on
the
screen
if
neither
output
nor
error
output
were
redirected
texttt
bash
has
a
syntax
for
specifying
this
shown
below
begin
adjustwidth
1cm
small
verb
cat
shopping
list
Shoping
list
tmp
out
2
1
newline
verb
cat
tmp
out
newline
verb
1
bottle
of
milk
newline
verb
2
granny
smith
apples
newline
verb
3
hot
house
tomatoes
newline
verb
1
six
pack
of
Coca
Cola
newline
verb
cat
Shoping
list
No
such
file
or
directory
newline
normalsize
end
adjustwidth
The
non
intuitive
expression
verb
2
1
means
redirect
standard
error
output
onto
the
same
stream
as
the
standard
output
the
texttt
1
at
the
end
of
the
expression
footnote
The
order
of
the
two
redirections
is
important
here
as
texttt
bash
will
process
them
from
left
to
right
thus
in
this
case
it
redirects
standard
output
to
texttt
tmp
out
then
redirects
standard
error
output
to
wherever
standard
output
is
being
sent
If
you
did
them
in
the
other
order
standard
error
output
would
be
set
to
texttt
bash
s
standard
output
and
then
texttt
cat
s
standard
output
is
set
to
texttt
tmp
out
not
what
you
wanted
at
all
In
the
same
way
that
standard
error
output
is
represented
by
texttt
2
standard
output
is
represented
by
texttt
1
In
fact
we
could
redirect
standard
output
in
the
following
way
begin
adjustwidth
1cm
small
verb
cat
shopping
list
1
tmp
out
newline
verb
cat
tmp
out
newline
verb
1
bottle
of
milk
newline
verb
2
granny
smith
apples
newline
verb
3
hot
house
tomatoes
newline
verb
1
six
pack
of
Coca
Cola
newline
normalsize
end
adjustwidth
That
is
texttt
digit
textgreater
works
for
each
output
stream
known
to
texttt
bash
In
this
book
we
restrict
ourselves
to
standard
output
texttt
1
and
standard
error
output
texttt
2
subsection
Pipes
and
multiple
processes
label
sec
pipes
In
the
previous
section
we
described
how
texttt
bash
performs
input
output
and
error
output
redirection
index
bash
textbf
bash
pipes
Being
able
to
do
so
would
be
pretty
useless
if
commands
did
not
read
from
standard
input
by
default
write
results
to
standard
output
by
default
and
write
error
messages
to
standard
error
output
by
default
Given
that
programs
do
conform
to
this
standard
texttt
bash
can
now
provide
significant
expressive
and
computational
power
by
managing
multiple
processes
and
enabling
these
processes
to
talk
to
each
other
emph
without
knowing
that
they
are
doing
so
This
is
done
through
an
abstraction
known
as
emph
pipelines
Suppose
you
wanted
to
know
the
number
of
files
in
a
particular
directory
How
would
you
do
so
One
has
to
invoke
texttt
ls
on
the
directory
to
access
its
contents
We
could
make
a
special
version
of
texttt
ls
that
understood
a
flag
verb
count
which
would
indicate
that
it
would
simply
print
the
number
of
files
found
in
each
directory
specified
on
the
command
line
verb
all
could
also
be
specified
with
this
new
flag
indicating
that
hidden
files
that
start
with
a
period
verb
would
also
be
counted
Seems
reasonable
so
far
But
we
already
have
texttt
wc
which
will
count
lines
words
and
characters
in
a
file
If
there
was
some
easy
way
to
put
the
output
of
texttt
ls
into
a
file
and
then
have
texttt
wc
take
its
input
from
that
file
we
would
have
a
solution
without
having
to
modify
texttt
ls
But
we
just
discussed
redirection
in
the
last
section
so
we
can
already
do
this
Let
s
try
it
out
on
the
current
directory
begin
adjustwidth
1cm
small
verb
ls
newline
verb
book
calendar
data
Music
Pictures
Shopping
List
src
tmp
err
tmp
out
newline
verb
ls
tmp
out
newline
verb
wc
w
tmp
out
textit
count
the
words
in
tmp
out
newline
verb
8
newline
verb
rm
tmp
out
newline
normalsize
end
adjustwidth
It
is
clear
that
this
works
There
s
the
problem
that
we
have
to
choose
a
temporary
filename
for
the
output
that
does
not
collide
with
one
of
the
files
already
in
the
directory
which
we
did
emph
not
do
that
the
temporary
file
will
be
listed
by
texttt
ls
and
thus
be
counted
by
texttt
wc
and
that
we
have
to
remember
to
remove
the
temporary
file
after
we
are
done
Operating
systems
have
long
supported
the
ability
for
processes
running
programs
to
communicate
with
each
other
called
emph
interprocess
communication
IPC
oddly
enough
Smiley
Linux
supports
several
different
types
of
IPC
that
enable
different
styles
of
interaction
In
this
case
we
would
like
to
have
a
way
for
two
child
processes
footnote
In
the
same
way
that
we
discussed
parent
child
relationships
between
directories
and
files
when
texttt
bash
creates
a
process
to
run
your
command
it
is
the
process
s
parent
and
the
process
is
texttt
bash
s
child
to
interact
with
one
process
writing
data
as
if
to
a
file
and
the
other
process
reading
that
data
as
if
coming
from
a
file
Linux
provides
an
abstraction
in
the
operating
system
called
a
emph
pipe
which
provides
this
ability
each
pipe
has
a
write
end
and
a
read
end
if
one
process
is
given
the
write
end
and
another
the
read
end
the
two
processes
interact
without
knowing
that
a
process
is
on
the
other
end
texttt
bash
is
already
able
to
redirect
input
output
and
error
output
So
if
it
knows
you
wanted
to
plumb
your
two
processes
together
it
could
ask
the
operating
system
for
a
pipe
redirect
one
process
s
standard
output
to
the
pipe
and
the
redirect
the
other
process
s
standard
input
to
the
pipe
As
you
might
have
guessed
texttt
bash
has
another
special
character
that
indicates
the
need
for
plumbing
two
processes
together
begin
adjustwidth
1cm
small
verb
ls
newline
verb
book
calendar
data
Music
Pictures
Shopping
List
src
tmp
err
newline
verb
ls
wc
w
newline
verb
7
newline
normalsize
end
adjustwidth
This
works
exactly
as
intended
Note
that
we
removed
texttt
tmp
out
in
our
previous
example
so
there
are
only
texttt
7
files
in
the
directory
A
vertical
bar
verb
is
the
special
character
that
separates
the
communicating
programs
texttt
bash
reads
everything
up
to
a
semicolon
or
the
end
of
line
then
breaks
that
line
up
into
individual
commands
separated
by
verb
characters
It
then
creates
a
pipe
for
each
verb
symbol
and
redirects
standard
output
for
the
command
to
the
left
of
the
verb
to
the
pipe
and
the
standard
input
for
the
command
to
right
of
the
verb
to
the
pipe
After
starting
each
of
these
processes
it
waits
for
each
of
them
to
complete
Note
that
pipelines
are
only
concerned
with
standard
output
and
input
they
do
not
affect
standard
error
output
If
you
need
to
have
both
the
output
and
error
messages
go
through
a
pipe
the
previous
syntax
continues
to
work
begin
adjustwidth
1cm
small
verb
cat
shopping
list
Shoping
list
2
1
more
newline
verb
1
bottle
of
milk
newline
verb
2
granny
smith
apples
newline
verb
3
hot
house
tomatoes
newline
verb
1
six
pack
of
Coca
Cola
newline
verb
cat
Shoping
list
No
such
file
or
directory
newline
normalsize
end
adjustwidth
As
described
above
verb
bash
first
looks
for
pipe
symbols
verb
in
each
line
that
it
reads
redirecting
the
left
process
s
standard
output
to
the
pipe
and
redirecting
the
right
process
s
standard
input
to
the
pipe
It
then
processes
any
other
IO
redirection
for
each
command
Thus
in
the
above
example
verb
cat
s
standard
output
is
already
set
to
the
pipe
and
the
verb
2
1
is
interpreted
to
mean
that
verb
cat
s
standard
error
output
is
to
be
redirected
to
the
same
place
as
standard
output
in
this
case
to
the
pipe
A
common
use
of
this
mixing
of
output
and
error
messages
on
a
pipe
is
when
you
wish
to
observe
the
programs
in
action
emph
and
you
want
to
capture
the
blended
output
in
a
file
The
program
texttt
tee
copies
its
standard
input
index
commands
textbf
commands
tee
to
its
standard
output
as
well
as
to
each
of
the
files
in
its
argument
list
begin
adjustwidth
1cm
small
verb
command
arguments
if
any
2
1
tee
log
newline
normalsize
end
adjustwidth
will
cause
verb
command
to
run
and
display
its
output
and
error
output
in
the
terminal
window
as
if
it
was
not
being
piped
into
texttt
tee
When
the
command
is
finished
texttt
log
will
have
an
exact
copy
of
the
output
and
error
messages
in
context
as
well
This
is
often
used
when
marking
programming
projects
as
it
enables
the
marker
to
observe
the
student
s
program
under
test
as
well
as
to
capture
a
log
to
give
to
the
student
as
part
of
the
assessment
begin
exercise
label
ex
wordfreqpipeline
small
Suppose
that
you
have
been
asked
to
determine
the
frequency
of
words
used
in
a
file
We
could
write
a
program
say
in
Python
or
C
to
perform
this
task
Fortunately
with
the
standard
programs
available
in
Linux
and
with
verb
bash
s
support
of
pipes
all
one
has
to
type
is
a
single
pipeline
command
to
verb
bash
We
know
from
Section
ref
sec
tr
that
we
can
use
verb
tr
to
break
up
a
file
into
one
word
per
line
We
also
know
from
Section
ref
sec
sort
that
we
can
use
verb
sort
to
sort
a
file
We
also
know
from
Section
ref
sec
uniq
that
we
can
use
verb
uniq
to
count
the
number
of
successive
matching
lines
in
a
file
This
is
all
we
need
for
our
pipeline
Recall
that
the
following
command
places
each
word
in
the
standard
input
on
its
own
line
footnote
In
this
case
a
word
is
a
sequence
of
non
whitespace
characters
separated
from
other
words
by
a
blank
tab
or
end
of
line
begin
adjustwidth
1cm
verb
tr
s
blank
n
newline
end
adjustwidth
If
verb
sort
is
invoked
without
filename
arguments
it
sorts
the
standard
input
lexicographically
as
characters
Finally
if
presented
with
a
sorted
file
on
standard
input
verb
uniq
replaces
each
sequence
of
identical
lines
by
a
single
copy
of
that
line
on
standard
output
if
the
verb
c
flag
has
been
specified
it
preceds
that
line
by
the
number
of
identical
lines
in
that
sequence
Therefore
given
a
file
verb
document
the
following
pipeline
will
produce
the
frequency
of
each
word
in
the
document
begin
adjustwidth
1cm
verb
tr
s
blank
n
document
sort
uniq
c
newline
end
adjustwidth
begin
itemize
noitemsep
item
As
discussed
in
Section
ref
sec
uniq
verb
uniq
is
case
sensitive
such
that
this
and
This
would
be
considered
separate
words
Add
another
invocation
of
verb
tr
to
the
pipeline
above
to
eliminate
this
artefact
item
The
pipeline
above
outputs
the
results
according
to
the
sort
order
of
the
words
It
is
more
likely
that
you
wish
to
see
the
words
by
frequency
from
high
to
low
Add
another
invocation
of
verb
sort
to
the
pipeline
above
to
present
the
output
by
frequency
from
highest
to
lowest
item
Our
definition
of
a
word
means
that
punctuation
is
included
in
a
word
e
g
the
last
word
in
I
must
go
to
the
store
is
store
Add
another
invocation
of
verb
tr
to
the
pipeline
above
to
remove
punctuation
characters
from
words
end
itemize
Box
normalsize
end
exercise
section
Compression
and
file
packaging
label
sec
compressionfilepackaging
It
is
not
uncommon
to
need
to
share
an
entire
directory
of
files
with
another
user
on
a
different
machine
The
mechanism
by
which
such
inter
machine
sharing
is
achieved
is
beyond
the
scope
of
this
book
The
mechanism
by
which
you
package
such
files
before
you
share
them
is
an
important
aspect
of
Linux
use
so
we
will
cover
the
basics
here
index
file
archives
Consider
the
directory
tree
shown
on
page
pageref
CaDS
tree
Here
we
will
use
another
standard
program
texttt
find
which
will
perform
commands
on
all
files
in
a
directory
tree
the
index
commands
textbf
commands
find
following
will
print
the
name
of
each
file
found
in
the
tree
rooted
at
verb
CaDS
begin
adjustwidth
1cm
small
verb
find
CaDS
print
newline
verb
CaDS
newline
verb
CaDS
book
tex
newline
verb
CaDS
ch00
newline
verb
CaDS
ch00
Preface
pdf
newline
verb
CaDS
ch00
Preface
synctex
gz
newline
verb
CaDS
ch00
Preface
tex
newline
verb
CaDS
ch01
newline
verb
CaDS
ch01
ch01
pdf
newline
verb
CaDS
ch01
ch01
synctex
gz
newline
verb
CaDS
ch01
ch01
tex
newline
verb
CaDS
ch02
newline
verb
CaDS
ch02
adm3a
jpg
newline
verb
CaDS
ch02
ch02
pdf
newline
verb
CaDS
ch02
ch02
synctex
gz
newline
verb
CaDS
ch02
ch02
tex
newline
verb
CaDS
ch02
dir
out
newline
verb
CaDS
ch02
me
newline
verb
CaDS
ch02
me
20170706
shopping
list
newline
verb
CaDS
ch02
me
book
newline
verb
CaDS
ch02
me
calendar
data
newline
verb
CaDS
ch02
me
Music
newline
verb
CaDS
ch02
me
Pictures
newline
verb
CaDS
ch02
me
shopping
list
newline
verb
CaDS
ch02
me
src
newline
verb
CaDS
ch02
me
tgz
newline
verb
CaDS
ch02
model33teletype
jpg
newline
verb
CaDS
Outline
pdf
newline
verb
CaDS
Outline
synctex
gz
newline
verb
CaDS
Outline
tex
newline
normalsize
end
adjustwidth
Definitely
a
less
informative
representation
than
the
figure
on
page
pageref
CaDS
tree
Smiley
There
are
a
number
of
ways
that
we
could
share
each
of
these
files
with
other
individuals
or
ourselves
on
another
machine
that
does
not
share
this
file
system
by
attaching
each
file
to
an
email
message
by
using
a
network
file
transfer
program
such
as
verb
scp
or
verb
ftp
or
by
copying
each
file
to
a
cloud
storage
provider
such
as
DropBox
Apple
s
iCloud
or
Microsoft
s
OneDrive
While
this
one
file
at
a
time
approach
would
work
it
does
not
make
it
easy
to
share
all
the
files
at
once
in
an
easy
and
consistent
way
The
better
way
would
be
to
make
a
new
file
that
contains
the
contents
of
all
of
the
other
files
along
with
meta
information
about
each
contained
file
so
that
the
individual
files
can
be
extracted
at
the
other
end
You
have
probably
used
ZIP
files
for
such
things
in
your
previous
computer
experience
subsection
texttt
tar
label
sec
tar
The
verb
tar
program
packages
many
files
together
into
a
single
disk
file
often
called
an
emph
archive
and
can
restore
individual
files
from
the
archive
verb
tar
is
named
after
textbf
t
ape
textbf
ar
chive
as
it
was
initially
created
to
move
files
to
from
magnetic
tapes
index
commands
textbf
commands
tar
Let
s
create
an
archive
of
the
files
in
the
verb
CaDS
directory
begin
adjustwidth
1cm
small
verb
tar
cvf
CaDS
tar
CaDS
column
newline
verb
CaDS
CaDS
ch02
dir
out
newline
verb
CaDS
book
tex
CaDS
ch02
me
newline
verb
CaDS
ch00
CaDS
ch02
me
20170706
shopping
list
newline
verb
CaDS
ch00
Preface
pdf
CaDS
ch02
me
book
newline
verb
CaDS
ch00
Preface
synctex
gz
CaDS
ch02
me
calendar
data
newline
verb
CaDS
ch00
Preface
tex
CaDS
ch02
me
Music
newline
verb
CaDS
ch01
CaDS
ch02
me
Pictures
newline
verb
CaDS
ch01
ch01
pdf
CaDS
ch02
me
shopping
list
newline
verb
CaDS
ch01
ch01
synctex
gz
CaDS
ch02
me
src
newline
verb
CaDS
ch01
ch01
tex
CaDS
ch02
me
tgz
newline
verb
CaDS
ch02
CaDS
ch02
model33teletype
jpg
newline
verb
CaDS
ch02
adm3a
jpg
CaDS
Outline
pdf
newline
verb
CaDS
ch02
ch02
pdf
CaDS
Outline
synctex
gz
newline
verb
CaDS
ch02
ch02
synctex
gz
CaDS
Outline
tex
newline
verb
CaDS
ch02
ch02
tex
newline
normalsize
end
adjustwidth
The
flags
to
verb
tar
that
we
have
used
have
the
following
meanings
verb
c
means
create
an
archive
verb
v
means
write
the
name
of
each
file
as
it
is
added
and
verb
f
filename
means
to
create
the
archive
in
verb
filename
As
you
can
see
verb
tar
allows
you
to
collect
all
flags
into
a
single
argument
since
verb
f
is
included
in
the
flag
argument
the
name
of
the
archive
file
to
be
created
must
immediately
follow
verb
cvf
The
filename
arguments
for
inclusion
can
either
be
regular
files
or
the
name
of
a
directory
in
the
latter
case
all
files
contained
in
the
directory
are
included
in
the
archive
if
an
included
file
is
a
directory
then
its
contents
are
also
included
in
the
archive
Note
that
we
have
used
another
Linux
command
texttt
column
to
pack
the
list
of
file
and
index
commands
textbf
commands
column
directory
names
into
columns
across
the
screen
to
more
efficiently
use
the
vertical
space
in
the
book
if
we
had
not
piped
the
output
of
texttt
tar
into
texttt
column
each
filename
would
have
appeared
on
a
single
line
Suppose
I
have
received
verb
CaDS
tar
from
someone
and
it
is
currently
stored
in
texttt
home
jsven
To
check
the
contents
of
the
archive
I
can
say
begin
adjustwidth
1cm
small
verb
tar
tf
CaDS
tar
column
newline
verb
CaDS
CaDS
ch02
dir
out
newline
verb
CaDS
book
tex
CaDS
ch02
me
newline
verb
CaDS
ch00
CaDS
ch02
me
20170706
shopping
list
newline
verb
CaDS
ch00
Preface
pdf
CaDS
ch02
me
book
newline
verb
CaDS
ch00
Preface
synctex
gz
CaDS
ch02
me
calendar
data
newline
verb
CaDS
ch00
Preface
tex
CaDS
ch02
me
Music
newline
verb
CaDS
ch01
CaDS
ch02
me
Pictures
newline
verb
CaDS
ch01
ch01
pdf
CaDS
ch02
me
shopping
list
newline
verb
CaDS
ch01
ch01
synctex
gz
CaDS
ch02
me
src
newline
verb
CaDS
ch01
ch01
tex
CaDS
ch02
me
tgz
newline
verb
CaDS
ch02
CaDS
ch02
model33teletype
jpg
newline
verb
CaDS
ch02
adm3a
jpg
CaDS
Outline
pdf
newline
verb
CaDS
ch02
ch02
pdf
CaDS
Outline
synctex
gz
newline
verb
CaDS
ch02
ch02
synctex
gz
CaDS
Outline
tex
newline
verb
CaDS
ch02
ch02
tex
newline
normalsize
end
adjustwidth
The
verb
t
command
to
verb
tar
indicates
that
I
want
to
see
a
table
of
contents
Again
we
have
used
texttt
column
to
pack
the
output
into
columns
If
I
execute
the
following
begin
adjustwidth
1cm
small
verb
tar
tvf
CaDS
tar
CaDS
ch02
ch02
tex
newline
verb
rw
r
r
me
me
94095
2017
07
14
11
28
CaDS
ch02
ch02
tex
newline
normalsize
end
adjustwidth
I
see
a
verbose
listing
about
verb
CaDS
ch02
ch02
tex
It
looks
very
similar
to
the
output
of
verb
ls
l
in
that
it
shows
each
file
s
protections
owner
group
size
modification
date
and
its
name
If
I
want
to
extract
all
of
the
files
into
my
home
directory
I
would
say
the
following
begin
adjustwidth
1cm
small
verb
tar
xf
book
tar
newline
normalsize
end
adjustwidth
I
can
check
to
see
that
it
has
worked
by
executing
begin
adjustwidth
1cm
small
verb
ls
CaDS
newline
verb
book
tex
ch00
ch01
ch02
Outline
pdf
Outline
synctex
gz
Outline
tex
newline
normalsize
end
adjustwidth
Sometimes
you
want
to
extract
a
particular
file
onto
the
standard
output
This
can
be
achieved
using
the
following
command
begin
adjustwidth
1cm
small
verb
tar
xOf
CaDS
tar
CaDS
ch01
ch01
tex
chapter1
tex
newline
normalsize
end
adjustwidth
There
are
many
other
options
supported
by
verb
tar
See
verb
tar
1
for
more
information
footnote
This
indicates
that
you
should
look
at
the
man
page
for
texttt
tar
in
section
1
of
the
Linux
users
manual
This
can
be
achieved
using
a
browser
as
indicated
earlier
in
the
chapter
or
by
typing
texttt
man
1
tar
to
the
shell
subsection
Compression
label
sec
compression
Files
on
a
computer
system
often
have
a
significant
amount
of
redundancy
in
them
such
that
they
occupy
more
space
than
is
theoretically
required
to
represent
the
contained
information
Linux
provides
tools
for
performing
two
styles
of
compression
inflation
index
file
compression
begin
itemize
noitemsep
item
The
tools
verb
compress
verb
uncompress
and
verb
zcat
use
an
adaptive
Lempel
Ziv
coding
to
remove
the
redundancy
verb
compress
encodes
the
content
of
a
file
using
adaptive
Lempel
Ziv
coding
verb
uncompress
and
verb
zcat
decode
an
encoded
file
producing
the
original
file
item
The
tools
verb
gzip
verb
gunzip
and
verb
gzcat
use
Lempel
Ziv
coding
LZ77
to
remove
the
redundancy
verb
gzip
encodes
the
content
of
a
file
using
Lempel
Ziv
coding
verb
gunzip
and
verb
gzcat
decode
an
encoded
file
producing
the
original
file
end
itemize
index
commands
textbf
commands
compress
index
commands
textbf
commands
uncompress
index
commands
textbf
commands
zcat
index
commands
textbf
commands
gzip
index
commands
textbf
commands
gunzip
index
commands
textbf
commands
gzcat
The
default
behavior
of
verb
compress
and
verb
gzip
is
to
replace
each
file
argument
by
an
encoded
file
with
an
extension
of
verb
Z
or
verb
gz
respectively
while
keeping
the
same
ownership
modes
access
and
modification
times
For
example
begin
adjustwidth
1cm
small
verb
cp
shopping
list
sl
1
textit
make
a
couple
of
files
to
compress
newline
verb
cp
shopping
list
sl
2
newline
verb
gzip
sl
1
textit
Encode
sl
1
to
sl
1
gz
remove
sl
1
newline
verb
compress
sl
2
textit
Encode
sl
2
to
sl
2
Z
remove
sl
2
newline
normalsize
end
adjustwidth
The
default
behavior
of
verb
uncompress
and
verb
gunzip
is
to
replace
each
file
argument
with
an
extension
of
verb
Z
or
verb
gz
respectively
by
an
unencoded
file
with
the
verb
Z
or
verb
gz
removed
from
the
name
while
keeping
the
same
ownership
modes
access
and
modification
times
For
example
begin
adjustwidth
1cm
small
verb
gunzip
sl
1
gz
textit
Unencode
sl
1
gz
to
sl
1
remove
sl
1
gz
newline
verb
uncompress
sl
2
Z
textit
Unencode
sl
2
Z
to
sl
2
remove
sl
2
Z
newline
normalsize
end
adjustwidth
The
default
behavior
of
verb
zcat
and
verb
gzcat
unencode
each
file
argument
with
an
extension
of
verb
Z
or
verb
gz
respectively
and
write
the
unencoded
content
to
standard
output
For
example
begin
adjustwidth
1cm
small
verb
gzcat
sl
1
gz
textit
Unencode
sl
1
gz
writing
contents
to
standard
output
newline
verb
zcat
sl
2
Z
textit
Unencode
sl
2
Z
writing
contents
to
standard
output
newline
normalsize
end
adjustwidth
The
most
common
use
of
these
types
of
tools
are
for
very
large
data
files
The
principle
use
of
compression
technologies
is
in
conjunction
with
file
packaging
tools
for
files
that
are
to
be
exchanged
These
are
described
in
the
next
section
subsection
Compression
and
File
Packaging
label
sec
compressionplusfilepackaging
subsubsection
texttt
gzip
and
texttt
tar
label
sec
gzipplustar
We
described
the
use
of
verb
tar
in
section
ref
sec
tar
to
create
verb
tar
archives
and
to
extract
files
from
verb
tar
archives
We
also
described
in
section
ref
sec
compression
the
use
of
verb
gzip
to
compress
files
Therefore
you
can
easily
create
a
compressed
verb
tar
archive
by
using
verb
tar
and
verb
gzip
as
follows
begin
adjustwidth
1cm
small
verb
tar
cf
CaDS
tar
CaDS
gzip
CaDS
tar
newline
normalsize
end
adjustwidth
After
completing
these
commands
you
will
be
left
with
a
file
verb
CaDS
tar
gz
and
verb
CaDS
tar
will
have
been
deleted
To
access
the
files
in
the
compressed
archive
you
will
need
to
execute
begin
adjustwidth
1cm
small
verb
gunzip
CaDS
tar
gz
tar
tf
CaDS
tar
newline
normalsize
end
adjustwidth
Remember
that
the
verb
gunzip
invocation
deletes
the
verb
CaDS
tar
gz
file
needspace
8
baselineskip
While
this
approach
works
it
suffers
from
several
deficiencies
begin
itemize
noitemsep
item
The
constant
conversion
from
uncompressed
to
compressed
and
back
again
represents
significant
wasted
computational
resources
item
During
verb
gzip
and
verb
gunzip
processing
both
uncompressed
and
compressed
versions
of
the
verb
tar
archive
are
resident
on
the
disk
item
If
the
long
term
stored
form
of
the
verb
tar
archive
is
the
compressed
form
having
to
convert
back
to
uncompressed
for
emph
any
access
is
unintuitive
at
best
end
itemize
Fortunately
verb
tar
can
compress
and
uncompress
as
part
of
its
processing
The
verb
z
flag
tells
verb
tar
to
create
a
compressed
archive
during
creation
and
file
addition
and
to
uncompress
the
data
in
a
compressed
archive
when
extracting
files
or
listing
its
contents
index
gzipped
tar
archives
The
commands
begin
adjustwidth
1cm
small
verb
tar
zcf
CaDS
tar
gz
CaDS
newline
verb
tar
ztf
CaDS
tar
gz
newline
verb
tar
zxf
CaDS
tar
gz
CaDS
ch01
ch01
tex
newline
verb
tar
zxOf
CaDS
tar
gz
CaDS
ch01
ch01
tex
chapter1
tex
newline
normalsize
end
adjustwidth
creates
a
gzipped
verb
tar
archive
containing
the
files
in
the
verb
CaDS
directory
lists
the
table
of
contents
of
the
archive
extracts
a
particular
file
from
the
archive
into
the
current
working
directory
and
extracts
a
particular
file
from
the
archive
onto
standard
output
respectively
Gzipped
verb
tar
archives
are
so
prevalent
in
Linux
systems
that
such
an
archive
is
usually
named
with
a
verb
tgz
extension
as
in
begin
adjustwidth
1cm
small
verb
tar
zcf
CaDS
tgz
CaDS
newline
normalsize
end
adjustwidth
We
will
use
the
verb
tgz
extension
in
the
rest
of
the
book
when
we
have
need
for
a
gzip
ed
verb
tar
archive
subsubsection
texttt
zip
and
texttt
unzip
label
zipplusunzip
While
use
of
verb
tar
to
create
compressed
archives
is
the
predominant
method
on
Linux
for
creating
compressed
packages
of
files
there
is
another
method
which
you
may
find
useful
especially
if
you
are
exchanging
packages
with
non
Linux
systems
index
commands
textbf
commands
zip
index
commands
textbf
commands
unzip
If
you
have
encountered
ZIP
files
in
your
previous
computer
use
you
will
know
that
a
ZIP
archive
is
similar
to
a
compressed
verb
tar
archive
the
contents
have
been
compressed
such
that
some
of
the
redundancy
in
the
contained
files
has
been
emph
squeezed
out
in
the
archive
To
extract
one
or
more
files
from
the
ZIP
archive
you
need
a
program
that
can
also
uncompress
the
data
as
it
is
extracted
Linux
provides
the
verb
zip
and
verb
unzip
commands
footnote
The
Arch
Linux
image
described
in
the
appendices
does
not
have
texttt
zip
or
texttt
unzip
installed
If
you
need
to
use
it
you
need
to
execute
texttt
sudo
pacman
S
zip
and
answer
the
question
posed
in
the
affirmative
for
creating
ZIP
archive
files
and
extracting
files
from
a
ZIP
archive
respectively
The
following
dialog
shows
use
of
verb
zip
and
verb
unzip
to
create
list
extract
to
standard
output
and
extract
the
contents
of
an
archive
verb
example
zip
It
assumes
that
we
have
a
directory
named
verb
tmp
in
the
current
working
directory
begin
adjustwidth
1cm
small
verb
ls
tmp
newline
verb
cat
cat
c
tento6
txt
newline
verb
zip
example
zip
tmp
newline
verb
adding
tmp
cat
deflated
70
newline
verb
adding
tmp
cat
c
deflated
36
newline
verb
adding
tmp
tento6
txt
deflated
80
newline
verb
unzip
l
example
zip
newline
verb
Archive
example
zip
newline
verb
Length
Date
Time
Name
newline
verb
newline
verb
8710
2016
08
30
12
44
tmp
cat
newline
verb
327
2016
08
30
12
43
tmp
cat
c
newline
verb
46301948
2016
08
30
12
44
tmp
tento6
txt
newline
verb
newline
verb
46310985
3
files
newline
verb
unzip
p
example
zip
tmp
cat
c
mycat
c
newline
verb
unzip
o
example
zip
newline
verb
Archive
example
zip
newline
verb
inflating
tmp
cat
newline
verb
inflating
tmp
cat
c
newline
verb
inflating
tmp
tento6
txt
newline
normalsize
end
adjustwidth
This
creates
verb
example
zip
containing
all
of
the
files
in
verb
tmp
using
the
adaptive
Lempel
Ziv
encoding
as
used
in
verb
compress
As
each
file
is
added
verb
zip
prints
the
size
of
the
file
the
compressed
size
and
the
percentage
of
compression
on
standard
output
The
verb
unzip
l
command
enables
you
to
determine
the
contents
of
an
archive
The
verb
unzip
p
command
enables
you
to
extract
a
member
of
the
archive
to
standard
output
in
this
case
we
redirect
standard
output
to
verb
mycat
c
Finally
to
extract
the
entire
contents
of
an
archive
you
invoke
verb
unzip
archive
name
the
files
are
extracted
into
the
current
working
directory
if
a
filename
includes
a
directory
name
e
g
verb
tmp
cat
c
the
file
will
be
extracted
into
that
directory
the
directory
will
be
created
if
it
does
not
exist
If
a
file
already
exists
verb
unzip
will
prompt
you
about
each
file
unless
you
have
specified
the
verb
o
flag
which
indicates
overwrite
existing
files
without
prompting
section
Summary
label
sec
ch2summary
This
chapter
has
introduced
you
to
the
Linux
system
as
experienced
by
a
user
It
started
off
discussing
the
basic
features
of
the
shell
how
commands
are
initiated
and
provided
arguments
and
presented
a
number
of
basic
commands
that
will
enable
you
to
get
started
using
the
system
As
we
discuss
C
programming
in
a
later
chapter
we
will
introduce
additional
programs
that
are
needed
to
develop
software
written
in
C
for
use
on
Linux
and
other
Posix
compliant
systems
We
then
moved
on
to
discuss
the
major
aspects
of
the
file
system
and
the
most
important
directories
in
the
file
system
for
a
software
developer
Armed
with
knowledge
of
the
file
system
we
then
returned
to
additional
features
of
the
shell
that
enable
sophisticated
use
of
the
shell
Finally
we
described
how
to
create
files
archives
that
contain
other
files
for
sharing
with
other
users
both
in
uncompressed
and
compressed
formats
