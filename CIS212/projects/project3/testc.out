\section{The edit-compile-link-execute (ECLE) cycle}
You present blocks written in Python to the interpreter;
it interprets the code, executing as it goes along.
C and many other programming languages are \emph{not} interpreted.
A programmer using these languages must perform the following steps:
\item use an \textbf{e}ditor or other tools to generate one or more files containing program fragments in
that language; these are called \emph{source} files;
\item \textbf{c}ompile/transform each of these files from source to a more binary representation;
the tool used to perform this transformation is called a \emph{compiler}, and the binary representation
\item \textbf{l}ink together each of the object files, along with any code needed from system libraries, into
\item \textbf{e}xecute the program file, with suitable arguments and inputs, to see if it performs correctly.
If the program does not execute correctly, you will need to edit one or more of the source files,
Do this until the program executes correctly; thus, the \emph{ECLE} cycle.
\subsection{\texttt{gcc} - the C compiler on Linux}
The GNU Compiler Collection is a compilation system that enables you to compile source files written in
\verb!gcc! is the name of the C compiler on Linux.
The command needed to do so is:
The \verb!-c! flag tells \verb!gcc! to compile only (\verb!gcc! also performs the link task);
if there are no errors in \verb!prog.c!, \verb!gcc!
will leave the compilation results in a file named \verb!prog.o!.
Note that \verb!.o! is the conventional extension for an object file.
Assuming that \verb!prog.c! contains all of the user-defined logic needed, then the following command
Finally, you can execute your program by typing the following command:
Recall that \verb!bash! uses the \verb!PATH! environment variable to find the executable program file
corresponding to the command you have typed.
If you simply typed \verb!prog!, \verb!bash! would look in each of the directories found in \verb!PATH!.
instead simply executing the file as typed.
And, as we recall from the section \ref{sec:dotanddotdot}, the directory \verb!'.'! simply means the current directory,
so \verb!./prog! will cause the executable file named \verb!prog! in the current directory to be executed,
and the \verb!/! in the name turns off the search by \verb!bash!.
Of course, you could add \verb!.! to the front of \verb!PATH!, but this can sometimes cause trouble if
you give your program an identical name to one of the standard programs provided in Linux.
The presence of a \verb!.c! file in the argument list causes \verb!gcc! to first compile it into an object
file, to then link that object file into the executable program, \emph{and} to then delete the object file.
As you use the ECLE cycle to debug your program, you seldom change all of the source files at once; usually,
you need to change one source file to resolve the current bug that the program is exhibiting; this only
requires that you compile that particular source file again, and then link all of the object files together into
If your C source file has language errors, \verb!gcc! will report these errors on standard error output.
There are a large number of flags to \verb!gcc! that control the reporting of warnings regarding your usage
of the C language; some of these warnings are indicative of poor programming practices that will likely lead
source files, as these warning flags will do a reasonable job of reporting such poor programming practices.
Therefore, we strongly recommend that your compile command lines look like:
The next section describes a tool to help you with the ECLE cycle, automating the necessary recompiles and
the relink of your program after you have made changes to source files.
\subsection{\texttt{make} - a tool to help you with the ECLE cycle}
It should be clear that one can establish a set of dependencies between the files that make up your
The executable program file depends upon the constituent object files; if one of them changes, then the
program file must be regenerated by relinking the object files.
Likewise, each object file depends upon its source file; if the source file has changed, then the
object file must be recreated by recompiling the source file; since the object file is now changed, the
Clearly, a tool that keeps track of these (and other) dependencies, and what actions are required to
\verb!make! requires that you specify the dependencies between your files.
It also requires that you specify what action to take to recreate a dependent file when one of the files
Finally, it has built in rules for the most common types of actions (e.g., going from a \verb!.c! to a
Recall from Chapter 2 that the file system keeps metadata about each file, and that one such piece of
metadata was the modification date/time for the file.
Given a specification of the dependencies between your files, \verb!make! can determine if a dependent file
needs to be recreated if the modification date of any of the files upon which the dependent file depends has
a later modification date than the dependent file.
Upon detection of such a situation, it then applies the action that you have specified for recreating
the dependent file (or applies one of the built-in, implicit rules) to recreate the dependent file, which will, of
course, now have a modification date later than any of the files upon which it depends.
In that directory, a file named \verb!Makefile! contains the specification of the file dependencies,
and the actions that should be taken.
The built-in rules for converting from a C source file to a C object file knows to look for a variable named
\verb!CFLAGS!; if this is defined, it will use it in the \verb!gcc! command to compile a source file into
It is good practice to create a variable named \verb!OBJECTS! for all of the object files that must
be linked together to create our program.
In this case, there is only one; if there had been other files, the entire set would have been listed as
part of the definition of \verb!OBJECTS!, with the files separated by blanks.
The first line says that \verb!prog! depends upon the definition of \verb!OBJECTS!; since \verb!OBJECTS!
\verb!make! checks the modification date for \verb!prog.o!; if the file does not exist, it looks for
a rule in the Makefile to see how to create \verb!prog.o!, and executes that rule.
Armed with the modification date for \verb!prog.o!, it compares it to the modification date for
\verb!prog!, and if it is newer, executes the second line, which is the rule used to update \verb!prog!.
Note that the action lines must be indented by a TAB character; there can be multiple action lines, each
indented by a TAB; an empty line indicates the end of the action lines associated with that rule.
This indicates that \verb!prog.o! depends upon \verb!prog.c!. The absence of a rule for updating
The lines starting with \verb!prog:! and \verb!prog.o:! define \emph{targets}.
You can ask \verb!make! to ``make'' one of the targets defined in a \verb!Makefile! by typing the following
In our particular case, we could type any of the following commands:
The first command asks \verb!make! to compile \verb!prog.c! to produce \verb!prog.o! if \verb!prog.c! is newer than \verb!prog.o!.
The second command asks \verb!make! to link \verb!prog.o! to produce \verb!prog! if \verb!prog.o! is newer
\verb!prog.c! first, and then would have to recreate \verb!prog!, since \verb!prog.o! has to be newer than
The third command asks \verb!make! to produce the first target that it finds, top to bottom,
cases, capturing the knowledge of the dependencies between files and the actions to take to update a
target if it is older than any of the files upon which it depends in a \verb!Makefile!, and using \verb!make!
Let's assume that the code in \verb!prog.c! refers to functions defined in \verb!a.c! and \verb!b.c!.
Furthermore, let's assume that some global definitions needed by \verb!a.c! and \verb!b.c! are in
\verb!globals.h!.\footnote{We will see later how source code can ``include'' information from another
file, thus establishing a dependency of the compiled object file upon the ``included'' file.}
This yields the following dependency graph between source files, object files, and program files.
The following \verb!Makefile! captures this dependency graph along with any non-built-in rules needed
We have augmented the definition for \verb!OBJECTS! to include \verb!a.o! and \verb!b.o!, and we have
added dependencies for these two additional object files.
\item we store all of the source, object, and program files for a particular program in its own
\item we create a file named \verb!Makefile! that captures the dependencies between source, object, and
\item we define a variable named \verb!CFLAGS! at the top of the makefile to specify some of the
\item we define a variable named \verb!OBJECTS! at the top of the makefile to collect together the
\item the first target shows the dependency of our program file upon the objects, and provides the
appropriate \verb!gcc! command to link those together to create our program file;
\item this is followed by a dependency line for each object file, showing the dependency upon the
\item we do not provide rules to perform the compilation, instead relying upon the built-in rule within
There are many other things one can specify in the \verb!Makefile! which are beyond the scope of this
This final section describes a couple of the more common things you will see in makefiles, and which you
As with our previous discussion, we will motivate the discussion with an example \verb!Makefile!.
It makes sense to build both programs in the same directory.
Thus, we have made the following changes to the previous \verb!Makefile!:
we have removed \verb!prog.o! from the variable \verb!OBJECTS!, as we only want to capture here those
we have added a variable named \verb!PROGRAMS! in which we can record all of the programs that can
be built by this \verb!Makefile!; we didn't have to do this, but it is good practice, especially as in the
future there is every likelihood that you will add one or more new programs to this set;
we define the first target to be dependent upon all programs \emph{without} an update rule; if you
type \verb!make! or \verb!make all!, this will cause \verb!make! to check that all of the programs
are up-to-date, and if not, bring them up-to-date;
the old dependency and rule for \verb!prog! is modified to build \verb!prog1!; note that since we removed
\verb!prog.o! from \verb!OBJECTS!, we have to include \verb!prog1.o! in the dependency line and the
we obviously need to replace the old target for \verb!prog.o! by equivalent targets for \verb!prog1.o! and
the \verb!rm! command to remove all of the object files and the program files, leaving only the source
files and the makefile; note the \verb!-f! flag to \verb!rm! - this has the effect of preventing \verb!rm!
from asking you if ``you are really sure'' about removing the specified files; it also prevents it from
warning you if any of the specified files are not found.
Finally, there is often an \verb!install! target in makefiles; we will revisit this at the end of this chapter.
The code below is a C version of this program.
As you can see, there are a number of similarities between the Python and C source files, as well as a
The following describes these similarities and differences.
\item The beginning of the program is devoted to accessing functions and values from other files/modules.
Python requires you to \verb!import math! in order to access the square root function, the floating point
absolute value function, and the value of $\pi$; it also requires you to \verb!import sys! in order to access
the command arguments.
C requires you to \verb!#include <math.h>! in order to access the square root function,
the floating point absolute value function, and the value of $\pi$ (denoted \verb!M_PI!);
raises \verb!x! to the \verb!y!\textsuperscript{th} power, returning it as a \verb!double!.
Note that, in C, \verb!double! is the default representation of a floating point number.
C does not require a special include to access arguments, since the signature for \verb!main()! has the
number of arguments and the arguments themselves passed in as values; the \verb!char *argv[]! argument
C also requires you to \verb!#include <stdlib.h>! in order to access the \verb!atoi()! function;
this converts a string representation of a number into an integer, just as the \verb!int()! built-in
Finally, C requires you to \verb!#include <stdio.h>! in order to access the \verb!printf()! function; unlike
acts like a combination of Python's \verb!print()! function and the \verb!format()! method on a
\item C requires that the return type of a function be defined in its signature; additionally, sound use of
C demands that you provide the type of each argument to a function.
Unlike Python, where all lines of a block must be at the same indentation level, C uses curly braces
Thus, the entire body of \verb!approx_pi()! is within a pair of curly braces; the body of the \verb!for!
loop in the function is also within a nested pair of curly braces.
Thus, immediately after the signature line for \verb!approx_pi()!, we declare variables named \verb!sum!,
Note that immediately after the \verb!for()! statement, we also declare \verb!di!, which is a \verb!double!
and is assigned the value of \verb!i! converted to a \verb!double!.
Explicit casts from one type to another are done as shown.
\verb!di! is only defined in the body of the \verb!for()! loop, not outside of it.
The computation of \verb!sum! is identical to our Python code, except that each occurrence of \verb!x**y!
The \verb!return! is also identical.
Note that each statement in the function is terminated by a semicolon (\verb!;!).
\item \verb!main()! is very similar between the two languages.
The call to \verb!printf()! looks a bit strange; the first argument is like the string template upon
which we invoked the \verb!format()! method in our Python code, although \verb!printf()! uses percent signs
to specify where an argument value should be placed (unlike the curly braces used in Python).
Another difference is that there is no format specifier equivalent to \verb!{:%}!, thus we had to
multiply the fractional difference by \verb!100!; finally, since \verb!%! is the special character
in the format string for \verb!printf()!, we had to double it in order for it to print out a percent sign.
\subsection{Do they give the same results?}
Note that we have added another variable, \verb!LIBRARIES!, to the
To access the library of math routines, one must add \verb!-lm! to the
By defining it as a variable at the top of the makefile, it is easy for you
libraries easily if your code grows to use other libraries.
from the default system library that \verb!gcc! consults whenever it is
linking together a program.
Now, let's build \verb!approx_pi!, and then compare its output
with the output from \verb!approx_pi.py!.
While these look the same, we can use a pipeline and \verb!diff! to be completely
sure, as in the following.
Here we have captured the output from the Python script into \verb!tmp.out!.
The subsequent pipeline executes \verb!approx_pi! with the same number of terms
of the summation, piping the output to \verb!diff!.
The bare hyphen (\verb!-!) as an argument to \verb!diff! tells it to use its
The lack of output from \verb!diff! indicates that the two files are exactly the
We then remove \verb!tmp.out! as good file system hygiene.
The names of variables in C are made up of alphabetic letters, digits, and the underscore (\verb!_!)
The first character of a name must be a letter or an underscore;
the underscore as the first letter to avoid collisions with names you define.
\item all lower case: in this situation, if you have a variable name with two or more words, use the
underscore to separate the words (e.g., \verb!modification_time!);
names, use ``camel case'' - i.e., capitalize the first letter of the 2\textsuperscript{nd} and subsequent
\item mixed case/start upper: as we shall see in the next chapter, we will capitalize the first letter of
each word in the name for an abstract data type (e.g., \verb!PriorityQueue!).
At least the first 31 characters of a variable name are significant (more on Linux, but if you are going to
port your programs to other C compilers on other operating systems, the language standard only guarantees
Keywords in the language, such as \verb!if!, \verb!else!, \verb!int!, \verb!float!, ... are reserved
Variables must be declared before they are used, unlike in Python.
In order to declare variables, we first need to understand the data types that C supports.
\item \verb!char! - this is a single byte, capable of holding one character in the local character set;
\item \verb!int! - this is an integer, typically reflecting the natural size of integers on the machine;
\verb!long int counter!, or even \verb!long long int packetCount!; note that these examples
show how one declares the type of a variable in your program.
The name \verb!int! can be omitted when using the \verb!short! or \verb!long! qualifiers.
As described above, the actual precision for an \verb!int! can vary from machine to machine, thus making
Thus, the standard has specified that the following are true:
\item unsigned numbers are always positive or zero, obeying the laws of arithmetic modulo
$2^n$, where $n$ is the number of bits in the type;
\item signed numbers vary from $2^{-(n-1)}$ to $2^{(n-1)} - 1$, obeying the laws of 2s-complement arithmetic.
There are standard header files, \verb!<limits.h>! and \verb!<float.h>!, that contain symbolic constants for
all of these sizes, along with other properties of the machine and compiler.
C supports the creation of arrays of a given type, accessed via indexing.
Arrays indices start at \verb!0!; thus, the legal indices for \verb!myArray! above are \verb!0 .. 24!.
One refers to the element at index \verb!10! as \verb!myArray[10]!.
We will discuss strings in more detail later in the chapter.
C also supports the definition of \emph{structures}, similar to data-only classes in Python.
You will need to be able to use literal values for different types in your program; these are usually
The following table indicates how to express constant integer values for different integer types.
Floating point constants contain a decimal point or an exponent or both; the type of the constant is
The following table shows the legal escape sequence character constants.
quotes (\verb!"!); the quotes are \emph{not} part of the string, only serving to
delimit the string contents.
(\verb!'\0'!) at the end.
It is important to understand the difference between character and string
\verb!'x'! is an integer, representing the numerical value of the letter \verb!x!
in the machine's character set.
the length of a string.
The production version of \verb!strlen()!, along with many other useful
The last example above shows that one does not need to specify the size of
Variables can be declared outside of any function definition, in which case they
file that is linked together with the file that declares that external
For external variables, initialization is done only once, before the program
starts to execute; as a result, the initializer must be a constant expression.
Variables declared at the top of a block (after an opening left curly brace
An explicitly initialized automatic variable is initialized each time the
defining block is entered; the initializer can be any expression.
An automatic variable for which there is no explicit initializer has an undefined
The qualifier \verb!const! can be applied to the declaration of any variable to
the function does not change that argument, as in:
The binary operators \verb!+!, \verb!-!, \verb!*!, and \verb!/! are defined for
both integer and floating point types; the modulus operator, \verb!%!, is also
For integers x and y, \verb!x / y! yields the integral number of times that
\verb!y! goes into \verb!x!, while \verb!x % y! yields the remainder from
The relational and logical operators described below return 1 when the
The following comparison operators, when used with numeric types, generate boolean values:
Boolean values can be combined using the usual boolean operators:
\texttt{x || y} & if x is \texttt{False}, then y, else x & y is only evaluated if x is \texttt{False}\\
\texttt{x \&\& y} & if x is \texttt{False}, then x, else y & y is only evaluated if x is \texttt{True}\\
\texttt{!x} & if x is \texttt{False}, then \texttt{True}, else \texttt{False} & has lower priority than non-Boolean operators, so \texttt{!a == b} is interpreted as \texttt{!(a == b)}\\
When an operator has operands of different types, they are converted to a
In general, the only automatic conversions are those that convert a ``narrower''
the compiler to alert you to the potential danger in doing so.
contiguity of sequences of digits or letters, or about the relationship between
If a binary operator has operands of different types, the ``narrower'' type is
promoted to the ``wider'' type before the operation proceeds, and the result is
of the ``wider'' type.
If there are no unsigned operands, the following informal rules are followed:
\verb!if either operand is long double!\newline
\verb!    convert the other to long double!\newline
\verb!else if either operand is double!\newline
\verb!    convert the other to double!\newline
\verb!else if either operand is float!\newline
\verb!    convert the other to float!\newline
\verb!    if either operand is long long!\newline
\verb!        convert the other to long long!\newline
\verb!    else if either operand is long!\newline
\verb!        convert the other to long!\newline
Conversions take place across assignments; the value of the right hand
side is converted to the type of the left hand side, which is the type
of the result; ``wider'' integers are converted to ``narrower'' ones by dropping
the excess high order bits.
You can avoid depending upon implicit conversions by explicitly coercing the
result of an expression using a \emph{cast}; these are of the form
The result of \textit{expression} is converted to \textit{type-name} using
the type conversions rules.
In this case, the compiler converts the integral value of \verb!N! to a
The cast produces the value of \verb!N! of the proper type; \verb!N! itself is
Incrementing and decrementing variables happens so often in C programs that there
Consider the following code fragment:
\verb!x = n++! says to assign the current value of \verb!n! to \verb!x!, then
\verb!y = ++n! says to increment \verb!n!, and then assign the value of \verb!n!
Thus, when \verb!printf()! is invoked, we should see the following on standard
Assignment of the value of an expression to a variable has the same syntax as
for Python, except for the required semicolon at the end.
The entire assignment statement is also an expression, and returns a value -
i.e., the value that was assigned to the variable.
As a result, the following types of statements are not only legal, are are
The first example above simply shows that one can assign the same value to
i.e., \verb!expression! is evaluated and assigned to \verb!var2!. The value of
that assignment is the value of \verb!expression!, and this value is assigned to
The second example shows invocation of the function \verb!fetch()!, assigning
its returned value to \verb!status!; the value of this assignment is then
compared to \verb!EOF! to conditionally execute the body of the \verb!if!
Besides normal assignment, it is often the case that one wants to evaluate an
expression, then perform a binary operation between a variable and that
expression, and reassign the result of that binary operation to the variable.
We have seen this in Python with the \verb!+=! syntax.
C has very rich support for these \emph{assignment operators}, all of the
The operators \verb!+!, \verb!-!, \verb!*!, \verb!/!, and \verb!%! all have
assignment operator forms.\footnote{There are other binary operators, associated
not covering bit manipulation in this book, they have not been mentioned
As with assignments, assignment operators have a value (the final value of
the variable), and can occur in expressions.
C has a ternary operator that is useful in many situations. It has the form:
You will see examples of its usage later in the book.
Unlike some other languages, where the semicolon is a statement separator,
in C the semicolon is a statement terminator.
Curly braces (\verb!{}!) are used to group declarations and statements together
As in Python, there are occasions where you will want different bits of code
to be executed depending upon the state of your program.
The syntax for \verb!if-else! is
with the \verb!else! part optional.
Since the \verb!else! part is optional, there is an ambiguity when an \verb!else!
This ambiguity is resolved by associating the \verb!else! with the closest
The expressions are evaluated in order; if any expression is true, the
statement associated with it is executed, and the processing of the entire
Again, the trailing \verb!else! can be omitted, although this is not a
particularly good idea; if the preceding expressions capture all of the legal
situations, then the \verb!else! clause can catch illegal usage of your code.
\subsection{Test at the top - \texttt{while} and \texttt{for}}
The safest way to loop through code until a terminating conditions is reached
is to test before entering the loop each time.
\verb!for! statement, on the other hand, is much more general than Python's.
The syntax for the \verb!while! statement is as follows:
The \verb!break! statement in a \verb!while! loop causes execution to resume after
C also provides a \verb!continue! statement to cause the next iteration of the
\verb!while! loop; in particular, execution will resume at the test of
\verb!expression!.\footnote{\texttt{continue} can also be used to cause the next
The syntax for the \verb!for! statement is as follows:
\verb!expr!\textsubscript{1} is known as the initialization field, and
\verb!expr!\textsubscript{3} is known as the update field.
except that the behavior of the \verb!continue! statement differs;
executed immediately, and then the test of \verb!expr!\textsubscript{2}.
into these fields in a \verb!for! statement; these are best reserved for
loop control operations appropriate to the situation.
What happens if you need to perform two or more statements in the initialization
expressions in a statement; a pair of expressions separated by a comma (\verb!,!) is evaluated left to right, and the type and value of the results are the type
and value of the rightmost expression.
The comma operator can be used legally anywhere in your program,\footnote{While its use is legal anywhere, such use outside of the initialization and update fields of a \texttt{for} statement should be avoided, as it leads to potentially
used in the initialization and update fields of a \verb!for! statement, as in
While being very general, the multi-way decision control described above using
is attempting to compare the result of an expression against a set of constant
values and take different actions based upon the result.
C provides the \verb!switch! statement to enable an efficient mechanism for such
The syntax for the \verb!switch! statement is as follows:
In the switch statement, the cases simply serve as labels.
If the \verb!expression! matches one of the constants in a particular label,
execution starts at the \verb!statements! associated with that \verb!case! label and
continues \emph{until the end of the \texttt{switch} statement} or until it
encounters a \verb!break! statement, at which point it will execute the first
statement after the \verb!switch! statement.
\faWarning~~~Since the default semantics (continue to the end) is almost
include a \verb!break! statement at the end of the set of statements associated
In other words, this is how you should use it!
Sound software engineering principles proscribe use of the goto.\footnote{See Edgar Dijkstra, ``Go To Statement Considered Harmful'', Communications of the ACM, Vol. 11, No. 3, pp. 147-148, March 1968.}
The \verb!break! statement enables us to escape from the innermost loop or
\verb!error:   /* code to clean up the mess */!\newline
A label has the same form as a variable name, and is followed by a colon (\verb!:!).
A label can be attached to any statement \emph{in the same function} as the \verb!goto! statement.
The scope of a label is the entire function.
One of the functions must have the name \verb!main()!, as the runtime will call that function after
it has initialized the process in which your program will execute.
Each function definition has the following form:
Various parts of the function declaration may be absent; a minimal function declaration is:
When the return type is omitted, it defaults to \verb!int!.
function prototypes to declare the types of the function arguments and its return type, as this
enables the compiler to make sure that you are using the function correctly.
Functions can occur in any order in the source file, and the source program can be split into
One can pre-declare function signatures in a source file to guarantee that their use in the source
file are type-correct; alternatively, the functions can be defined in an order that guarantees that
a function is defined prior to first use in the source file.
Returning a value from a function to its caller is achieved via the \verb!return! statement:
The calling function is free to ignore the returned value, although this is not good software engineering
practice. \footnote{If you are explicitly ignoring the return value from a function, you should indicate this by casting (see Section \ref{typeconversions}) the return result to \texttt{(void)}.}
An \verb!expression! is not required after the \verb!return! keyword; in such a situation, no value is
returned to the caller.
Control also returns to the caller (with no return value) if execution encounters the closing \verb!}! in
the function definition.
in another.
If a function fails to return a value, its ``value'', if checked by the caller, is most definitely
string of characters - a limited version of the Linux \verb!grep! program.
The main program falls neatly into three pieces:
\textit{while (there's another line)}\newline
\verb!    !\textit{if (the line contains the pattern)}\newline
\verb!        !\textit{print the line}\newline
The \textit{print the line} is simply a call to \verb!printf()!, defined in \verb!<stdio.h>!.
The \textit{while (there's another line)} is a call to a function \verb!fgets()! defined in \verb!<stdio.h>!.
Its signature is the following:
You pass \verb!fgets()! a character array (\verb!buf[]!), the size of that array (\verb!size!), and
Each time \verb!fgets()! is called, it copies the next line of input from \verb!stream! into \verb!buf!,
and places \verb!'\0'! after the line so that \verb!buf! is a legal string in C; if it copied a line
into \verb!buf!, it returns the address of \verb!buf! as its function value.
If there are no more lines on \verb!stream! when \verb!fgets()! is called, it returns \verb!NULL! as its
\verb!fgets()! is similar to the \verb!readline()! function in Python except
that you have to provide \verb!fgets()! with a buffer into which the next
\verb!        !\textit{if (the line contains the pattern)}\newline
In fact, if you simply delete the \textit{if (the line contains the pattern)} from this program,
What's the odd definition for \verb!UNUSED!, and why do we use it in the signature for \verb!main()!?
We previously advised that the warning flags to specify when compiling with \verb!gcc! are \verb!-W -Wall!.
One of the warnings that will be generated with these flags is if there is a function parameter or an automatic variable that is \emph{not} referenced in the function; in general, such a situation may be a strong indication of a problem in your code.
If you flag a parameter or variable with this attribute, \verb!gcc! will not issue the corresponding
In our case, we are not using the command arguments, so flagging \verb!argc! and \verb!argv! as unused is
So, how do we determine if one string is included in another string?
But, in the meantime, we should look in \verb!<string.h>! to see if such a function has been
supplied by the runtime system.
This can be easily done by asking your search engine to look for ``linux man string''; somewhere in the
first few results of the search you will see an entry entitled ``string(3) - Linux manual page - man7.org''.
A perusal of that page will yield the signature
seemingly just the function we need.
Clicking on the link for \verb!strstr(3)! in the ``SEE ALSO'' section gets us to the man page for
\verb!haystack!, and the address of the location in \verb!haystack! where \verb!needle! is first found if
edit and recompile the program to search for other patterns.
We will look at how to make the program more dynamic later in the chapter.
A C program consists of a set of external objects which are either variables or functions.
Functions are \emph{always} external since C does not permit functions to be defined inside of other
External variables and functions have the property that all references to them using the same name, even
from functions compiled separately, are references to the same thing.
The \emph{scope} of a name is the part of the program within which the name can be used.
For an automatic variable declared at the beginning of a block, the scope is the block in which the
The scope of an external variable or a function lasts from the point at which it is declared to the end
of the file being compiled.
file from the one in which it is being used, then an \verb!extern! declaration is required.
It is important to distinguish between the \emph{declaration} of an external variable and its
A declaration announces the properties of a variable, primarily its type; a definition also causes
storage to be set aside for the variable.
For example, if the lines
appear outside of any function, they define the external variables \verb!sp! and \verb!val!, cause
storage to be set aside for each of them, and serve as a declaration for the rest of that source file.
On the other hand, the lines
declare for the rest of the source file that \verb!sp! is an \verb!int! and that \verb!val! is a
\verb!double! array; they do not create the variables or reserve storage for them.
Only one definition of an external variable is allowed among all of the files that make up a program;
2) by functions in other source files.
information from functions in other source files.
The keyword \verb!static!, if prefixed to external variable definitions, achieves this
level of hiding - i.e., all functions in the source file can access the static variables,
but they are hidden from functions in other source files.
The following example declarations
define the types and cause storage to be created for \verb!sp! and \verb!val!.
These variables can only be accessed by functions in the source file where these declarations occur.
If a function is declared \verb!static!, its name is \emph{invisible} outside of the file in which it is declared.
Internal \verb!static! variables are only visible within the function in which they are declared, just
as automatic variables; unlike automatics, the \verb!static! variables retain their values across calls
to the defining function. The following example shows a typical use of an internal \verb!static!
In our pattern matching program, we included \verb!<stdio.h>!, which defined the variable \verb!stdin!
and the functions \verb!fgets()! and \verb!printf()!; we also included \verb!<string.h>!, which defined
the function \verb!strstr()!.
Let's suppose that we wish to replace our call to \verb!strstr()! by our own function, with the signature
We will create two files: \verb!issubstring.h!, which defines the function signature, and
\verb!issubstring.c!, which implements the function.
Admittedly, \verb!isSubString()! is a very simple function, simply using \verb!strstr()! to do the
hard work, and returning the correct return type.
Note that our source file includes the header file using quotes (\verb!""!) around the name instead of
in the file system; files included using quotes are first searched for in the current directory,
then in the standard directories.
You may ask, why include the header file in the source? This guarantees that the file signature
defined in the header, which will be used by other files, is identical to that defined in the source.
And, obviously, we replace the call to \verb!strstr()! with a call to \verb!isSubString()!.
The standard include files are very stable, and do not change.
Our local include files, on the other hand, are likely to change as we debug the program.
Thus, we want \verb!make! to include our local include files in the dependency graph.
Now, let's eliminate the dependence of \verb!find! on a compiled pattern.
We want our program to take a single argument, which is the pattern we wish to look for.
Here is the absolute final version of \verb!find.c!.
Note that we removed the \verb!#define! of \verb!UNUSED!, as well as application of that attribute to
\verb!argc! and \verb!argv!, since we \emph{are} using the argument parameters.
We first check that the user has provided a pattern argument by comparing \verb!argc! with the value
\verb!2! - remember that \verb!argv[0]! is the command name specified in the \verb!bash! command line,
and \verb!argv[1]! is the first real argument to the program.
If the user has either not specified the pattern, or provided too many arguments, we
remind the user of the correct command line and return a non-zero value, indicating an error.
Otherwise, we use the pattern in argv[1].
While functions \emph{cannot} be defined inside of other functions,
Declarations of variables, including initializations, can follow the left brace (\verb!{!) that introduces
any compound statement, not just the one that begins a function.
existence until the matching right brace (\verb!}!).
an outer scope, as the potential for confusion and error is too great.
Consider the following example - what number will be printed out?
In the absence of explicit initialization, external and static variables are guaranteed to be initialized
Automatic variables have undefined initial value - i.e., in the absence of explicit initialization, they
Scalar variables can be initialized when they are defined by following the name with \verb!=! and an
For external and static variables, the initializer \emph{must} be a constant expression; the
initialization is done once, before the program begins execution.
For automatic variables, the initializer is not restricted to being a constant - it may be any expression
involving previously defined values, even function calls; the explicit initialization of
automatic variables is performed each time the function or block is
If the size of the array is omitted, as in this example, the compiler computes the length of the
array from the number of initializers.
If the size of array is specified, and there are fewer initializers than its declared size, the
If there are more initializers than elements in the array, a compiler error is generated.
C does not maintain the length of an array at runtime, unlike Python.
When using an initialization as for \verb!days[]! above, your code may need to know the number of
elements that the compiler actually created.
There are two common ways to do this:
\item you can append a value to the list of initializers that is obviously different from the others
(e.g., a \verb!-1! in \verb!days[]!), such that at runtime you can count the number of items in the array
until hitting the terminating value; such a value is called a \emph{sentinel}; or
\item a more C-savvy way to do this is to use the \verb!sizeof! compile-time operator to define a
constant that is the length of the array; \verb!sizeof(type-name)! is replaced at compile time with
the number of bytes that an instance of \verb!type-name! will occupy in memory; \verb!sizeof variable-name! is replaced at compile time with the number of bytes that the variable will occupy in memory;
the following code shows how to exploit this to yield a defined constant that is the size of \verb!days[]!:
Your code may refer to \verb!DAYS_LENGTH! whenever it needs to limit its accesses to the legal index values.
\subsection{The C preprocessor}
The preprocessor is the first pass of the compiler;
during this pass, the preprocessor replaces commands that it understands with other text,
obtained from other files or from symbolic constants.
The commands that are understood are: \verb!#include!, \verb!#define!, \verb!#if!, and \verb!#ifdef!.
Any source line of the form
is \emph{replaced} by the contents of \verb!filename!.
If \verb!filename! is delimited by quotes, the file is first search for in the directory where the
If it is not found there, or if \verb!filename! is delimited by angle brackets, known directories
Python \verb!import! explicitly brings in names from the referenced modules.
File inclusion simply replaces each \verb!#include! statement with the contents of that file.
There are often several \verb!#include! lines at the beginning of a source file.
These include common \verb!#define! statements and extern declarations, or
\verb!#include! is the preferred way to tie the declarations together for a large program.
Note that when an included file is changed, all files that depend upon the included file must
A macro definition has the form
Subsequent occurrences of \verb!name! in the source file will be replaced by \verb!replacement-text!.
\verb!name! has the same form as a C variable name, while \verb!replacement-text! is arbitrary.
Normally, \verb!replacement-text! is the rest of the macro definition line;
a long definition may be continued onto several lines by placing a \verb!\! at the end of each line
The scope of \verb!name! is from the point of definition to the end of the source file being compiled.
name, there would be no substitution in \verb!printf("YES")! or \verb!YESMAN!.
A name may be defined with absolutely any replacement text; for example, the following is legal and
Each occurrence of a formal parameter to the macro is replaced by the corresponding actual argument.
Therefore,
If an expression causes side effects (e.g., \verb!n++!), macros can give the wrong results; for example,
\verb!x = max(i++, j++);! will yield the wrong results, as the larger of \verb!i! or \verb!j! will be
As you may have noticed in our \verb!max()! example, you must also be extremely generous with parentheses
to make sure that the appropriate order of evaluation is preserved.
Fix the definition of \verb!square()! in order to obtain the correct results.
There are a number of statements that are used to control preprocessing,
thus providing a way to include code selectively, depending upon the value
\verb!#if! evaluates a constant integer expression; the expression may \emph{not}
If the expression is non-zero, subsequent lines until an \verb!#endif! or \verb!#elif! or \verb!#else!
are processed; if the expression is zero:
\item if an \verb!#elif expr1! is found, then \verb!expr1! is evaluated; if non-zero, subsequent lines
\item if an \verb!#else! is found, then subsequent lines until an \verb!#endif! are processed.
The expression \verb!defined(name)! is \verb!1/0! if \verb!name! is defined/not.
If the contents of a header file are included more than once while compiling a source file, it can
To make sure that the contents of a header file (e.g., \verb!hdr.h!) are included only once, \verb!hdr.h!
surrounds the actual contents with a conditional like this:
This allows header files to include all other header files upon which it depends without having
All of the standard header files (e.g., \verb!<stdio.h>!) do this; you should do this with your header
There is nothing special about using \verb!_HDR_H_! as the defined symbol to indicate that the
file has been included; you just need to pick a name that will not collide with other defined constants.
Leading and trailing underscores, replacing the \verb!.! by an underscore, and converting all letters to
The \verb!#elif! construct is to enable a switch-like choice of lines to process, as in
Up to this point, it is not clear why C would be preferred over any other language.
The set of basic data types is sparse, and arrays are the only structured built-in type.
C supports a pointer data type; a pointer is a data variable that contains the address of
(i.e., \textit{points to}) another variable.
in the figure to the right, we are assuming
\verb!7!.\footnote{The linker decides where to place variables when linking the program together.}
Furthermore, we have a pointer to a character, \verb!p!, that is assigned to address \verb!N-6!. The figure assumes that a pointer occupies 4 bytes (a 32-bit architecture); if we were on a 64-bit architecture, it would occupy 8 bytes.
We can make \verb!p! point to \verb!c! with a statement of the form \verb!p = &c;!.
The unary operator \verb!&! gives the address of a variable, it is verbalized as ``address of''.
Once one has a pointer, how do you get at the contents of the variable to which it points?
The unary operator \verb!*! is the indirection or dereferencing operator; when applied to a pointer,
it accesses the object to which the pointer points.
In our previous example, \verb!*p! would yield \verb!'a'!, which is the character stored in \verb!c!.
The following artificial sequence of statements show the use of \verb!&! and \verb!*!.
Note that the declaration for a pointer to an \verb!int! is \verb!int *p;! - i.e., it indicates that
the expression \verb!*p! can be used anywhere that an \verb!int! is legal; it also indicates that \verb!p!
\label{call by value}When you call a C function, the value of the argument is passed to the function.
The function can not only read the values passed, but can modify them; since they are copies, the caller's
copies of those values \emph{are not} changed. Thus, given call by value, there is no direct way for a
function to alter a variable in the calling function.
have the values they had before the call to \verb!swap()!.
This is because the function is swapping copies of the actual arguments, not the arguments themselves.
If a caller now invokes \verb!swap(&a, &b)!, upon return the values in \verb!a! and \verb!b! will truly
since a called function could return a value for the function, modify a mutable data structure, or
By passing pointer parameters to a function, the function can modify the variables to which the pointers point,
Consider the following declaration:
\verb!a[i]! refers to the \verb!i!\textsuperscript{th} element of the array.
The assignment \verb!pa = &a[0];! causes \verb!pa! to point to element zero of \verb!a! - i.e., \verb!pa!
contains the address of \verb!a[0]!.
If \verb!x! is an integer, the assignment \verb!x = *pa;! copies the contents of \verb!a[0]! into
\emph{By definition}, \verb!pa + 1! points to the next element past \verb!pa!; \verb!pa + i! points
The preceding statements are true regardless of the type or size of the variables in the array \verb!a!.
The meaning of ``add 1 to a pointer'', and by extension, all pointer arithmetic, is that \verb!pa + 1!
points to the next object of that type beyond \verb!pa!, and that \verb!pa + i! points to the
The value of a variable of type array is the address of the \verb!0!\textsuperscript{th} element of
the array - i.e., \verb!a == &a[0]!.
Thus, the following are equivalent:
There are several ramifications of this strong relationship between pointers and arrays:
\item when an array name is passed as an argument to a function, what is passed is the address of
the initial element; within the called function, the argument is a local variable; thus, an array
an array name has been passed as the actual argument in a call, the function can believe that it has been
handed either an array or a pointer;
\item a part of an array can be passed to a function by passing a pointer to the beginning of
the sub-array - e.g., \verb!f(&a[2])! or \verb!f(a+2)!.
If \verb!p! is a pointer to some element of an array, then \verb!p++! increments \verb!p! to point to
the next element, and \verb!p += i! increments it to point \verb!i! elements beyond the current element.
There is a distinguished pointer value, \verb!NULL!, which means that the pointer does not point at
anything valid; \verb!NULL! is defined in \verb!<stdio.h>!, \verb!<stdlib.h>! and \verb!<string.h>!.\footnote{It is defined in several places since it is used by functions defined in each of these include files.}
Adding or subtracting an integer from a pointer causes the behavior defined previously.
Subtracting two pointers is also valid; if \verb!p! and \verb!q! point to elements of the same array,
and if \verb!p < q!, then \verb!q - p + 1! is the number of elements from \verb!p! to \verb!q!, inclusive.
\item assignment of pointers of the same type;
\item subtracting or comparing two pointers to members of the same array;
The following operations on pointers are \emph{invalid}:
\item assign a pointer of one type to a pointer of another type.\footnote{It is possible to use an explicit cast to assign pointers of different types. This will be discussed in the following section.}
other classes inherit.
using these in our abstract data types.
One important aspect of \verb!void *! pointers is that you \emph{cannot} dereference them; attempts to do so
The most common initial exposure to \verb!void *! pointers is through the dynamic memory allocation
Many of the data structures used to solve problems grow dynamically - i.e., one cannot know when the
the constructor for any class), memory is allocated from the heap.
Python keeps track of the references to heap-allocated memory; when there are no more references to
a chunk of heap-allocated memory, it can be returned to the heap.
there are no more references.
We will discuss the \verb!valgrind! program later in this chapter which helps you find memory leaks.
The function prototypes for the routines in \verb!<stdlib.h>! are as follows:
\verb! *         NULL if the request cannot be satisfied. The space is uninitialized.!\newline
\verb! *         of size `size' bytes, or NULL if the request cannot be satisfied.!\newline
\verb! *         The space is initialized to zero bytes.!\newline
\verb! * realloc: adjusts the size of the memory block pointed to by `ptr' to `size' bytes,!\newline
\verb! *          returning a pointer to the resized block; the contents will be unchanged!\newline
\verb! *          in the range from the start of the region up to the minimum of the old and!\newline
\verb! *          new sizes; if the new size is larger, the added memory will not be!\newline
These prototypes use a type \verb!size_t!, which is also defined in \verb!<stdlib.h>!.
How do you know the number of bytes that you need to ask for?
We discussed \verb!sizeof! earlier, as this compile-time expression is replaced by the number of
When you invoke \verb!malloc()! to allocate some heap memory, a pointer to the first byte in the block
\verb!    /* other uses of the allocated memory */!\newline
\verb!    free(p);    /* deallocate the memory when done */!\newline
We declare a pointer of the appropriate type.
We then call \verb!malloc()!, using \verb!sizeof()! to specify the number of bytes needed for
We use the cast \verb!(int *)! to explicitly convert from a \verb!void *! pointer (returned by
We check to see if the \verb!malloc()! was successful; if so, we use the allocated memory, then return it to
the heap;
if not, we print an error message.\footnote{One does not usually use the heap to allocate temporary basic or structured data types; for example, for temporary use of an \texttt{int} in your function, you just declare it as an automatic; the compiler allocates storage for it on the stack, and when your function returns, that storage is popped off the stack. We use the heap to allocate data items that must survive a return from the function in which they are allocated, usually arrays and structures.}
There are two important aspects to this example:
\item you should \emph{always} check the return result from \verb!malloc()! (or \verb!calloc()! or
\verb!realloc()!); if the allocation failed, and your code attempts to dereference a \verb!NULL!,
your program will abort with a \emph{segmentation violation}; if the returned value is \verb!NULL!,
\item the line
for any given type \verb!type!, the allocation of an instance of that type will look as follows:
- i.e., \verb!sizeof(type)! is the argument to \verb!malloc()!, the \verb!void *! return from
\verb!malloc()! is cast to \verb!type *!, and the result is assigned to a variable of \verb!type *!.
\item Note that due to the strong association of pointers and arrays,
the pattern to use for an array of \verb!type! of size \verb!N! would be
The following program reads up to the first 100 lines from standard input, stores those lines in
dynamic memory, prints each of the stored lines, and then frees the dynamic memory.
We use two functions from \verb!<string.h>!: \verb!strlen()!, which counts the number of characters in
a character array up to, but not including, the \verb!'\0'! that terminates the string, and
\verb!strcpy()!, which copies the second argument string into the first.
This example program also uses a number of other aspects of the language that we have discussed so far.
\verb!        p = (char *)malloc(strlen(buf) + 1);   /* why the +1? */!\newline
Why did we have to specify the size for the heap buffer as \verb!strlen(buf) + 1!?
The value returned by \verb!strlen()! does not include the \verb!'\0'! that indicates the
If we are going to make a legal copy of a string, we have to allocate enough bytes to hold all of the
characters \emph{and} the \verb!'\0'!; thus, we add one to the number of characters.
Forgetting to account for the terminating 0 byte is an \emph{exceedingly} common error that
In fact, one has to make string copies on the heap so often that \verb!<string.h>! defines a
function, \verb!char *strdup(char *str);!, that allocates the correct number of bytes on the heap,
copies \verb!str! into that block, and returns a \verb!char *! pointer to the heap memory.
thus avoiding the memory errors caused by forgetting to allocate space
for the \verb!'\0'!.
The most common pointers that you will encounter are pointers to characters.
Strings are arrays of characters, with each character in the string occupying one position in the array;
one additional position at the end of the string holds the 0-byte, \verb!'\0'!, to terminate the string.
The literal is stored as an array of characters in \emph{read-only} memory, with the terminating 0-byte.
When a string literal/constant is specified as an argument to a function, a \verb!char *! pointer to the
first character in the literal is passed to the function.
Consider the following two declarations:
\verb!amsg! is an array, just big enough to hold the sequence of characters and the 0-byte; this array
is placed in read-write memory, and the characters in the array can be changed by subsequent logic.
\verb!pmsg! is a pointer, and it points to the first character of an array in read-only memory that
holds the sequence of characters and the 0-byte;
the characters in the array \emph{cannot} be changed, but subsequent logic can cause \verb!pmsg! to
Since pointers are variables themselves, they can be stored in arrays just as other data types can.
In fact, we have seen variables that are arrays of pointers earlier in the chapter: \verb!argv! (the
argument vector that is passed as the second argument in the call to \verb!main!) and \verb!lines! (the array to hold lines in the example program in section \ref{sec:exampleprogram}).
a list/array of strings; since strings are arrays of characters, then each array element is a pointer to
an array of characters - i.e., points to the first character in the array.
Suppose that you are asked to write a program that acts just like the standard \verb!echo! command.
Not exactly what we had in mind; it appears that \verb!argv[0]! contains the command that you
typed to \verb!bash!, and that the standard \verb!echo! command does not print that.
No big problem, we have to make two simple changes to the code: 1)modify the initialization clause of
the \verb!for! loop to \verb!i = 1!, and 2) modify \verb!i > 0! in the first \verb!printf()! invocation
The first \verb!printf()! statement looks a bit weird, since it uses the ternary conditional.
\item the format string is \verb!"%s%s"!, which means that two additional arguments to \verb!printf()!
\item if this is not the first time through the for loop (\verb!i > 1!), we want to put a single space; if
not, we do not want to put a leading character; the ternary argument produces \verb!" "! in the former
case, and \verb!""! in the latter;
\item the appropriate \verb!argv[]! value, which is a character pointer, is the final argument.
For example, you have a simple image display program that supports the commands \verb!up!, \verb!down!,
You can declare and initalize an array of pointers to these keywords with the following code:
Note the addition of \verb!NULL! at the end of the array of pointers; we described earlier how one
can put a \emph{sentinel} value at the end of a compiler-constructed array so you know how big it
By the way, \verb!argv[]! actually is terminated by \verb!NULL! in this way.
C provides rectangular multi-dimensional arrays, although in practice they are much less used than arrays
This indicates that \verb!matrix! has 100 rows, each with 50 elements. The value in \verb!matrix! at the
One can initialize a multi-dimensional array. The following code shows how to do so for a small,
These can be assigned to pointer variables, placed in arrays, passed as arguments to functions, returned
Consider a sort program that sorts strings in files, like the standard \verb!sort! program in Linux.
Sometimes, we want to sort the strings lexicographically (i.e., as character strings); at other
times, there may be a number at the beginning of each line, and we would like the lines to be sorted
numerically according to the leading number.
As with the standard \verb!sort! program, the user should be able to choose the type of sort by
specifying a flag argument when invoking the program.
The pseudocode for our \verb!main()! looks something like the following:
\textit{sort them}\newline
\textit{print them in order}\newline
Assuming that there is a \verb!sort()! function that performs the \textit{sort them} part of the
pseudocode, we need to have some way to inform that function how we want the strings to be compared.
If the function prototype for \verb!sort()! has the following form, we can achieve this flexible
\item \verb!sort()! sorts the array of pointers to strings, \verb!lines[]!;
\item it actually sorts a slice of the array, specified by \verb!left! and \verb!right!; and
\item whenever \verb!sort()! needs to compare two entries in \verb!lines[]!, it will invoke the
function pointed to by \verb!comp!; this function takes two \verb!char *! arguments, and the return
value from the function will be a value \verb!< 0! if \verb!l1 < l2!, the value \verb!0! if \verb!l1 == l2!, or a value \verb!> 0!
The function \verb!strcmp()! in \verb!<string.h>! is exactly such a function, and compares the
To do so, we will have to define a numeric compare function that matches the prototype for
the function pointer argument in \verb!sort()!.
The following will do the trick.
Due to the precedence of C's operators, you have to be careful when defining function pointers.
For example, consider the following function prototype:
In general, when defining a function pointer, you should always surround the name of the pointer
(\verb!*name!) by parentheses to avoid such mistakes.
together under a single name for convenient handling.
The keyword \verb!struct! introduces a structure declaration, which is a list of variable declarations
enclosed in curly braces; the \verb!tag! is an optional name that can be used to refer to this
structure type in the future.
The variables named in the declarations within the braces are called \emph{members}.
there are no member functions.
The right brace that terminates the list of members may be followed by a list of variable names, as in
it merely describes a template or the shape of a structure.
In such a case, a \verb!tag! must be specified in order to define instances of the structure later.
Suppose that we have defined the following \verb!struct!:
then \verb!screen.ll.x! refers to the \verb!x! coordinate of the lower left corner (\verb!ll!) of
\item It may \emph{not} be compared with another structure using \verb!==! or \verb^!=^.
If \verb!pp! points to a point structure, then \verb!*pp! is the structure itself, and
\verb!(*pp).x! and \verb!(*pp).y! are the members.
If \verb!p! is a pointer to a structure, then \verb!p->member-name! is equivalent to
The function \verb!mapKeyword()! maps from one of the string commands to an integer value.
The code that solicited the string command from the user would call this routine, and then
process the return value in a \verb!switch! statement to perform the requested action.
As we shall see later in the text, many data structures that we use for common algorithms require
For a singly-linked list of integers, we would define the following structure type for nodes in the list:
In C, as soon as the compiler has seen \verb!struct tag!, any subsequent code can refer to this tag;
would the recursion end?
makes the name \verb!Length! a synonym for \verb!int!.
The type name \verb!Length! can be used in declarations, casts, etc. in exactly the same way that
The most common use of \verb!typedef! is with respect to structures.
This particular style is extremely common - i.e., the tag for the structure starts with a lower-case
while the synonym starts with an upper-case letter; in this example,
the tag is \verb!point!, while the synonym for \verb!struct point! is \verb!Point!.
With the above definition of \verb!Point!, our definition for a rectangle can become
and we can declare the variable \verb!screen! as \verb!Rectangle screen;!.
Both declarations achieve the same goal, of creating a variable that holds a \verb!struct point! - i.e.,
both \verb!p1! and \verb!p2! have exactly the same properties.
creates the type name \verb!PFI! for ``pointer to function (of two \texttt{char *} arguments) returning
an \texttt{int}''; it could be used as in the following:
\subsection{Structs and the heap}
The \verb!sizeof! compile time operator works with \verb!struct!'s just like it does for built-in
This enables us to create instances of our structures on the heap using \verb!malloc()!.
Consider the following example:
The call to \verb!malloc()! looks just like those we have seen before.
Through the cast, we have a pointer to our structure, and can manipulate the members of
the allocated structure.
This example is for a singly-linked list, which we will see later in the textbook.
sizes, with the compiler keeping track of size and alignment requirements.
Unions enable the manipulation of different kinds of data in a single area of storage,
Consider the symbol table for a compiler; the program could have integer, floating point, or character
The value of a particular literal must be stored in a variable of the appropriate type, but it is
most convenient for table management if the value occupies the same amount of storage and is stored in
the same place, regardless of its type.
The syntax is similar to that for structures. For this symbol table application:
The tag identifier, in this case \verb!literalValue!, is optional.
\verb!u! will be large enough to hold the largest of the three types.
Any one of these types may be assigned to \verb!u! and then used in expressions.
Of course, your program must have some way to keep track of what type of value the \verb!union! currently
keeping track of the type of value in the \verb!union!, and a member which is the union.
Given the definition of \verb!literalValue! above,
Suppose that our program had read the integer constant \verb!42! in its input, and needed to
The following two lines would do the trick:
Given the definition of \verb!sTableEntry! above, the following code would display the
dynamically allocate a union on the heap.
Input and output facilities are not part of the C language itself.
The standard I/O library, defined in \verb!<stdio.h>!, provides the ANSI standard library of I/O functions.
If the program was invoked with I/O redirection in the command line, the associated standard streams
will point to the file or pipe specified.
The simplest input mechanism is to read one character at a time from \verb!stdin!, using \verb!getchar()!:
\verb!getchar()! returns the next input character from \verb!stdin! each time it is called, or \verb!EOF!
when it encounters the end of file.
The function
puts the character \verb!ch! onto \verb!stdout!.
Calls to \verb!putchar()! and \verb!printf()! can be interleaved - output appears in the order in which
the calls were made.
The function \verb!scanf()! is the input analog to \verb!printf()!, providing many of the same
conversion facilities in the opposite direction:
\verb!scanf()! reads characters from standard input, interprets them according to the specification in
\verb!format!, and stores the results in the remaining arguments.
Note that all of the arguments into which \verb!scanf()! stores the results \emph{must} be pointers, as
\verb!scanf()! stops when it reaches the end of the format string, or when some input fails to
match the control specification in the format string.
\verb!scanf()! returns as its value the number of successfully matched and assigned input items.
The next call to \verb!scanf()! resumes scanning standard input immediately after the last character
scanned in the current call.
The \verb!scanf()! format string usually contains conversion specifications, which are used to
\item ordinary characters (not \verb!%!), which are expected to match the next non-white-space character of the input stream;
\item conversion specifications, consisting of the character \verb!%!, an optional assignment suppression
\verb!L! indicating the width of the target, and a conversion character.
The basic \verb!scanf()! conversions are shown in the following table.
\texttt{i} & integer & \texttt{int *} & the integer may be in octal (leading 0) or hexadecimal (leading 0x or 0X); same \texttt{l} and \texttt{L} modifiers as for decimal integer\\
\texttt{c} & character & \texttt{char *} & the next input character is copied; the normal skip over white space is suppressed\\
\texttt{s} & unquoted character string & \texttt{char *} & address of an array of characters large enough for the string and a terminating \texttt{'\textbackslash{0'}}\\
\item Suppose we want to read input lines that contain dates of the form ``dd Month yyyy'':
\verb!    printf("input was not in the form dd Month yyyy\n");!\newline
\item Now suppose that the required format is ``mm/dd/yyyy'':
\verb!    printf("input was not in the form mm/dd/yyyy\n");!\newline
Given the name of a file as a string, one can open it for reading/writing, read from it or write to it,
\verb!<stdio.h>! defines a stream type \verb!FILE *!; a successful file open returns one of these
streams, the I/O routines and the close routine take one of these streams as an argument.
The function prototypes are as follow.
There are also versions of \verb!scanf()! and \verb!printf()! that work with characters buffers instead of
Finally, while functions in the \verb!scanf()! family return the number of conversions that were
successfully completed, the functions in the \verb!printf()! family return the number of characters
written to the stream/buffer; \verb!sprintf()! always writes a terminating 0-byte, but does not include
it in the returned count.
Thus, the following pattern is sometimes seen in code that is constructing a complex string in a
\verb!/* buf contains the concatenated formatted outputs */!\newline
There are a variety of ways for providing information to programs that you
\item A program can indicate that it will obtain the value of an
the value of an environment variable \verb!CFLAGS! if it is defined in its
in the makefile. In this latter case, it will use the value defined in the
makefile.\footnote{You are strongly advised to \emph{NOT} define \texttt{CFLAGS} in the environment, and to \emph{ALWAYS} define \texttt{CFLAGS} at the top of each Makefile. From personal experience, you will forget that you have defined \texttt{CFLAGS} in the environment when you port your code to another system, and spend quite a bit of time figuring out what is wrong.}
flags are specified in the command line. These flags come in two flavors:
\item "short" flags - these are of the form 
the man page for the program will tell you how the program interprets such
to the program that you are selecting a particular way that the program should
\verb!ls! should list the names of the files in the current working directory.
\verb!ls -l!, on the other hand, indicates that \verb!ls! should display a
\emph{long} listing of each file in the current working directory, one per line.
argument - consider \verb!ls -lrt!. The \verb!-l! flag indicates that one should
do a long listing, the \verb!-r! flag indicates that it should reverse the order
of the presentation, and the \verb!-t! flag indicates that the files should be
to 50 columns on the output. The number of columns \verb!50! must follow the
\verb!-w! immediately on the command line as a separate argument to the
other short flags \emph{unless} it is the last short flag, as in
In such cases, the flag text (\verb!width!) and its value (\verb!50!) are a
single string argument as seen by the program.
\item All other arguments are usually names of files; occasionally, for example
for programs like \verb!grep!, the first non-flag argument is considered a
pattern for which \verb!grep! must search in the files named in subsequent
If you do so, you will need to consult online help to rename the file to
remove the leading hyphen.
to provide logic in your \verb!main()! to obtain the arguments that were
For your program to be a good citizen in the Linux environment, you should
adhere to the following rules:
it is strongly recommended that you \emph{not} do that. In other words, all
flags should occur before the first non-flag argument.
\item For a flag, if the next
character is another \verb!'-'!, it is a long flag. The processing of a flag
appears after the leading hyphen.
\item If it is a short flag, and the last character that follows the hyphen
requires additional information, you need to process the next argument for
\item If it is a long flag, and the flag requires additional information, it
will be found in the same argument following the \verb!'='! sign.
\item If the flag is providing the same information as an environment variable,
the value provided by the flag \emph{overrides} any value that was obtained
The GNU debugger, usually called GDB and named \verb!gdb! as an
executable file, is the standard debugger for the Linux operating system.
languages, including C, C++, Objective-C, Fortran, Java, and many others.
GDB was first written by Richard Stallman in 1986 as part of the GNU system.
It is free software, released under the GNU General Public License,
the help of \verb!gdb!.
This section provides a brief introduction into the use of \verb!gdb!.
In order for the \verb!executable file! to be used with \verb!gdb!, one
must add an additional flag, \verb!-g!, to the command line, as in
the following example:
You can now execute \verb!prog! under \verb!gdb!'s control using the
describes how to proceed with actually running the program under \verb!gdb!.
the arrow keys and to auto-complete (most) words using the \verb!TAB! key.
At any time, you may ask \verb!gdb! for help with a command by typing the
following to the \verb!gdb! prompt:
\subsection{Running the program under \texttt{gdb}}
To run your program under \verb!gdb!, you type the following command:
\verb!main()!, you must specify them after the \verb!run! command.
along with the command arguments.
This runs the program - if there are no serious problems, the program
If the program has issues, \verb!gdb! assumes control after the
the program, such as the line number where it terminated, parameters to
the enclosing function, etc.
Consider the following program in a file \verb!test.c!:
The following dialog shows execution of this program using \verb!gdb!:
which caused the program to terminate.
Thus, it is likely that the argument to \verb!strlen()! is a NULL pointer.
\verb!foo_len()!, which then passes \verb!a! on to \verb!strlen()!, we
have found the source of our segmentation fault.
\footnote{Note that if we had simply invoked \texttt{test} in the shell, the
shell would have yielded the relatively unhelpful message of
If we change the declaration for \verb!a! to the following:
the following dialog results:
To exit from \verb!gdb!, one uses the \verb!quit! command.
If, on the other hand, the program has terminated unsuccessfully, \verb!gdb!
\subsection{Other useful commands}
If all \verb!gdb! provided was extra information about the source of the
The real power of a debugger is that it lets you stop the execution of
your program, inspect the contents of memory, and view other aspects of
One useful command to \verb!gdb! is to inspect the sequence
of calls that resulted in the faulty termination of your program.
Let's ask for the backtrace after our faulty program above exits with a
For this simple example, the backtrace corroborates our logic above
regarding the source of the segmentation fault.
the program; this is done with a command of the form:
\verb!run! the program; you may introduce additional breakpoints whenever
\footnote{The boilerplate text from \texttt{gdb} will no longer be shown in
We specified that a breakpoint should be set at the start of \verb!foo_len()!.
Alternatively, since we know that the function starts at line 8 of test.c, we
In fact, you can set a breakpoint at any statement in your source files, they
do not have to coincide with the start of a function.
Since you typically will not know the line numbers for your source files,
setting breakpoints at the start of a function is a very easy way to pause
When we issue the \verb!run! command, the program starts to execute
At the \verb!gdb! prompt, we may then issue other commands.
In this case, we invoked the \verb!print! command to see what the value
is for the argument \verb!s!, which is shown to be \verb!0x0!; note that
the function arguments are provided when the breakpoint is encountered.
Note also that when we asked \verb!gdb! to print the value of \verb!s!, it
printed `\verb!$1 = 0x0!'; we could equally have asked it to print the value
of \verb!$1!, as \verb!gdb! represents the arguments to a function positionally
You can use the \verb!print! command to not only display the values of
\verb!print *p! to \verb!gdb! will cause the contents of the
Any time \verb!gdb! regains control after the program starts running,
we can continue the execution of the program by issuing the
There are two forms of the single step functionality:
\item The next line of code is executed by specifying the \verb!step! command.
This will execute \emph{just} the next line of code.
If the next line of code contains a function invocation, \verb!step!
This enables you to dive deep into a sequence of call frames to get to the
\item You can also execute the next line of code by specifying the \verb!next!
If the next line of code contains a function invocation, using \verb!next!
Thus, \verb!next! simply enables you to step through the current function. 
``re-execute the previous command''.
\verb!RETURN! will eliminate a bit of the tedium.
We can clear a breakpoint by issuing the \verb!clear! command; this command
requires the same argument as used in a \verb!break! command to set the
the breakpoint set upon entry to \verb!foo_len()!.
Another way for \verb!gdb! to regain control is through \emph{watchpoints}.
A watchpoint allows you to monitor the values of variables, pausing the program
To set a watchpoint, you use the \verb!watch! command:
Now, whenever \verb!my_var!'s value is modified, the program is paused and the
\verb!gdb! interprets the scope of the variable name in a \verb!watch! command
based upon the program scope at the time the \verb!watch! command is executed.
This means that you can set watchpoints for global variables before running the
for that variable when the function is entered the first time, and then clear
the breakpoint.
There are a multitude of other features provided by \verb!gdb!.
It comes with many tools; the tool upon which we are focused is the
Memcheck detects and reports the following types of memory errors:
\item Reading/writing off the end of malloc'd blocks.
To test whether `\verb!prog arguments!' correctly allocates and uses
As with \verb!gdb!, the source files must be compiled with the \verb!-g! flag
\verb!valgrind! supports a large number of options; the user manual may be
Consider the following program.
When executed by \verb!valgrind!, the following output results:
As you can see, \verb!valgrind! indicates that there an
to determine when it is returned to the heap.
Consider the following program.
When executed by \verb!valgrind!, the following output results:
Apparently, \verb!strcpy! attempts to access the first and last byte of the
\subsection{Reading/writing off the end of malloc'd blocks}
\verb!valgrind! keeps track of the length of each \verb!malloc()!
allocated block to check for attempted access beyond the allocation.
Consider the following program.
When executed by \verb!valgrind!, the following output results:
This program shows the typical cause of these overrun problems -- forgetting
to allocate space for the 0-byte at the end of a string.
Another common source of this problem is to allocate an array of
memory block, and then attempt to use \emph{n} as an index into that block,
forgetting that the array is indexed by \emph{0 .. n-1}.
to determine when it is returned to the heap.
Attempts to terminate the program when there are still outstanding
Consider the following program.
When executed by \verb!valgrind!, the following output results:
If you wish to see details of leaked memory, use the following invocation:
to determine when it is returned to the heap.
\verb!free()!'ed or is an address that does not reside on the heap)
Consider the following program.
When executed by \verb!valgrind!, the following output results:
Nearly every sophisticated C program makes extensive use of the heap;
The previous sections have demonstrated how different types of memory misuse
manifest themselves in the output from \verb!valgrind!.
The only time you should be satisfied that you have eliminated all problems
with your memory use is if the output from \verb!valgrind! looks like the
