\chapter{A beginner's guide to Linux}
\label{ch:beginnersguide}
\section{Some history}
\label{sec:somehistory}
It is likely that you have been using computers since you were very young.
I recall sitting my 2-year old niece down in front of one of the first Macintosh\textsuperscript{TM}
computers to play a game called ``Lode Runner'' in 1985.
Admittedly a poor baby sitting approach, but it did the trick; she happily punched the keys for nearly an
hour while I was trying to finish up a section of a research paper (using paper and pencil).

\begin{wrapfigure}{L}{0.25\textwidth}
\centering
\includegraphics[width=0.8\linewidth]{linux/model33teletype}
{\small Model 33 teletype}\newline
~\newline
~\newline
~\newline
\includegraphics[width=0.8\linewidth]{linux/adm3a}
{\small adm3a terminal}\newline
\end{wrapfigure}
The very first interactive computers had a single ``console'' upon which output from programs was displayed
and through which input could be provided using the keyboard.
The input and output speeds on such consoles were maddeningly slow,
but one could at least get on with the job.
The console shown in the figure also had a paper tape reader, a very early form
of mass storage for digital information\Smiley{}.

%\begin{wrapfigure}{L}{0.25\textwidth}
%\centering
%\includegraphics[width=0.8\linewidth]{adm3a}
%{\small adm3a terminal}
%\end{wrapfigure}
As processors became more powerful and memory became more plentiful, computers were fitted with
serial line devices that enabled one to connect ``terminals'' to the system.
Such terminals provided a similar interface to the system as the console,
but usually consisted of a cathode ray tube for display and a keyboard;
a window of 80 character lines x 24 lines of fixed-width font characters was provided on the
CRT, and the typical transmission speeds of such devices was \~{}30 times faster than for the earlier
consoles.
Multiple people could be connected to the system at one time, leading to ``time-sharing'' systems; one
particular time-sharing system that was popular in universities and among computer science researchers
was UNIX\textsuperscript{TM}.

UNIX\textsuperscript{TM} was developed by Ken Thompson and Dennis Ritchie at Bell Laboratories,
along with contributions from many of the other researchers at the Bell Labs Murray Hill facility.
It had originally been implemented to ease the withdrawal experienced by Thompson and Ritchie when
they were recalled from the Multics Project\footnote{Elliott I. Organick. 1972. The Multics system: an examination of its structure. MIT Press, Cambridge, MA, USA.}.
UNIX\textsuperscript{TM} was used internally within Bell Labs until Thompson spent a sabbatical
year at Berkeley; as with all good
computer scientists, Thompson took his environment (UNIX\textsuperscript{TM}) with him;
when others at Berkeley discovered the
power and simplicity of the environment, Western Electric (Bell Labs parent company) was persuaded to create
an academic license that enabled Berkeley and other university computer science departments to have access
to the system.

Students that graduated from institutions in which UNIX\textsuperscript{TM} was used found themselves
also experiencing
withdrawal when they went off to employment in industry or the national laboratories - the licensing
of UNIX\textsuperscript{TM} was restricted to universities.
Computer system vendors, such as HP, IBM, and Sun, observed this demand, and negotiated licensing arrangements
with Western Electric to produce vendor-specific versions of UNIX\textsuperscript{TM} for their
workstations and servers (HP/HP-UX, IBM/AIX, Sun/SunOS).
Since these were vendor-specific, they presented slightly different libraries and system calls, complicating
porting of code between the platforms.
To eliminate most of the differences,
the vendors, through the activities of a variety of consortia, worked with the IEEE to create
the POSIX standards to define a standard set of library functions that could be
depended upon when programming on a POSIX-compliant system.

One particularly unique innovation of UNIX\textsuperscript{TM} was how it read commands from a user,
commonly called a command line interpreter (CLI).
Prior operating systems usually provided a privileged program, sometimes embedded in the kernel itself, for
reading and executing commands typed by the user through their terminal.
The UNIX\textsuperscript{TM} kernel provided a complete set of system calls enabling processes to create and
manage other processes; thus, the CLI could simply be another program.
These user-level CLI's have become known as ``shells'', since the very first such CLI was called the
shell, and the command one typed to invoke the shell was \texttt{sh};
\texttt{sh} was written by Steve Bourne.

Beginning in 1991, Linus Torvalds began work to create a new, free operating system kernel.
This kernel, coupled with the applications from the GNU project, has eventually become known
as Linux.
Linux is open source, licensed under the GNU General Public License.
Given its open-source nature, it is now the dominant operating system used in academia, replacing the many
flavors of UNIX\textsuperscript{TM}.

\section{The user interface}
\label{sec:theuserinterface}
The primary interface between a user and Linux is the terminal window - i.e., a window on the screen that emulates the 80x24 terminal windows found on earlier UNIX\textsuperscript{TM} systems.
A command line interpreter, usually \emph{bash}\footnote{The name is an acronym for
\emph{Bourne-again shell}, a pun on the [Bourne] shell that it replaced.},
reads each command line typed by the user in the window,
creates one or more processes needed to execute the command line, and (normally) waits for those
processes to finish execution before prompting the user for another command line.

This is obviously quite different from the point-and-click mechanism with which you are undoubtedly
familiar; Linux systems do provide one or more graphical user interfaces that support the point-and-click mechanism
where it is appropriate - e.g., invocation of your browser, creation of another terminal window.
Program development on Linux systems is nearly always performed using the command line interface provided
by a terminal window in which \texttt{bash} is executing.
We will, therefore, restrict our discussion to this environment.

\section{The command line interpreter - \texttt{bash}}
\label{sec:commandlineinterpreter}
\texttt{bash} reads the commands typed by a user in its terminal window and executes those commands.
\texttt{bash} displays a prompt string, reads the line of input typed, and executes the command.
The prompt string can be customized, as will be shown later; until then, we will use the string ``\$ '' as
the prompt.

Consider the following example:\footnote{You are encouraged to try these commands on your Linux system
as you read along. You should see the same or similar output from the commands.}\footnote{In the examples in this chapter, the text that you type is in {\ttfamily {\bfseries boldface}}, while that displayed by the shell and commands is in \texttt{normalface}.}
\begin{adjustwidth}{1cm}{}
\small
\verb!$ !{\ttfamily {\bfseries date}}\verb!                  !\textit{show today's date}\newline
\verb!Tue Jun 27 15:09:02 PDT 2017!\newline
\verb!$ !{\ttfamily {\bfseries pwd}}\verb!                   !\textit{print the current working directory}\newline
\verb!/home/me!\newline
\verb!$ !{\ttfamily {\bfseries date; pwd}}\verb!             !\textit{a semicolon is a command separator}\newline
\verb!Tue Jun 27 15:09:43 PDF 2017!\newline
\verb!/home/me!
\normalsize
\end{adjustwidth}

From the last example, you see that you can place more than one command on a single command line.
A \verb!;! is a command separator; ``a ; b'' tells the shell to first execute \textit{a}, then
execute \textit{b}.

After \texttt{bash} displays the prompt string, it reads everything you type up to when you press the
\texttt{Enter} key. (On some systems the key is labeled \texttt{Return}; we will refer to it as the
\texttt{Enter} key in this text.)
If you wish to erase a character before pressing \texttt{Enter}, you should press the \texttt{Backspace} key.
If you have made a number of mistakes, and wish to simply erase the entire line and start again, you can
type \emph{ctl-u}\footnote{The expression \emph{ctl-x} means you should press the \texttt{x} key while
holding down the \texttt{Ctrl} key.}; sometimes \emph{ctl-u} is called the \emph{line kill} character.

Both \texttt{date} and \texttt{pwd} are commands that do not require any additional information in
order to do their jobs.\footnote{\texttt{date} \emph{can} take a number of arguments that determine how
to format the date string that it prints. Type ``linux man date'' as a search string in your favorite
browser to see the arguments that \texttt{date} understands.}
Most programs require additional \textit{command arguments} to provide additional information to
the program while it is executing.

Consider the program \texttt{echo} - it has a particularly simple job: print the supplied arguments and exit,
as in the following examples:
\begin{adjustwidth}{1cm}{}
\small
\verb!$ !{\ttfamily {\bfseries echo this}}\verb!             !\textit{print `this' on the output}\newline
\verb!this!\newline
\verb!$ !{\ttfamily {\bfseries echo this and that}}\verb!    !\textit{print `this and that'}\newline
\verb!this and that!\newline
\verb!$ !{\ttfamily {\bfseries echo this\verb!  !and that}}\verb!   !\textit{two spaces between `this' and `and'}\newline
\verb!this and that           !\textit{the extra space has disappeared}\newline
\verb!$ !{\ttfamily {\bfseries echo \verb!'!this\verb!  !and that\verb!'!}}\verb! !\textit{quote the input}\newline
\verb!this  and that          !\textit{the extra space was maintained}\newline
\normalsize
\end{adjustwidth}

These examples demonstrate a number of features of \texttt{bash}.
\begin{itemize}
\item The shell breaks up the line of input that you type into separate words; the words can be separated
by blanks or tabs, or by punctuation like the semicolon.
\item The first word in a command (\texttt{echo} above) is the program to execute; we will discuss
later how the shell looks for the program file that corresponds to that word.
\item The other words in the command are provided to the program as a list of words, for it to do with
as it sees fit.
\texttt{echo} simply prints each of these words, placing a single space between each pair of words.
\item It does not matter how many spaces or tabs separate two words; it does not change the list of words
that the shell gives to the program.
\item If you want to have many words in a single argument, you can quote the phrase using \verb!'! or
\verb!"!.
In the last example above, \texttt{echo} received a list with a single ``word'' in it, consisting of the phrase \verb!'this  and that'! \emph{without} the quote characters. 
\end{itemize}
We saw earlier that \texttt{bash} gives a special meaning to the character \verb!;! --- now we see that it gives special meaning to \verb!'! and \verb!"!, as well.
In fact, \texttt{bash} gives special meanings to most non-alphanumeric characters.
If you want to provide an argument to a program that contains a non-alphanumeric character, the easiest way
to prevent the shell from giving it its special meaning is to quote the argument.
For example:
\begin{adjustwidth}{1cm}{}
\small
\verb!$ !{\ttfamily {\bfseries echo A semi-colon }}\verb!'!{\ttfamily {\bfseries (;)}}\verb!'! {\ttfamily {\bfseries is a command separator.}}\newline
\verb!A semi-colon (;) is a command separator.!\newline
\normalsize
\end{adjustwidth}
A command argument that needs to contain an apostrophe, \verb!'!, can be escaped using a quotation
mark, \verb!"!, and vice versa.

By convention, command arguments that start with \verb!-! are considered flags to a program - i.e., they
change the way the program does its task; these are usually a single letter following the hyphen, and are
called \emph{short flags}.
\index{bash@\textbf{bash}!short flags}
If additional information is required when a short flag is specified, that information must be the next word that immediately
follows the short flag, as in \verb!-n name!.
Finally, if you wish to specify several short flags on a single command line, you can usually collapse them
into a single flag - e.g., \verb!command -a -b -c! can usually be written as
\verb!command -abc!.

A second flag convention, called \emph{long flags}, has a flag starting with \verb!--!, and is usually written out in full; for example, \verb!command -a! might be the same as \verb!command --all!.
\index{bash@\textbf{bash}!long flags}
If additional information is required when a long flag is specified, it is written as
\verb!--name=value! - i.e., the information associated with the flag is part of the same command argument word.
You will note in the previous example that a hyphen, \verb!-!, is not special to \texttt{bash}, nor is
a period, \verb!.!\footnote{This latter assertion is not completely true - if the 1st ``word'' in a command
is \texttt{.}, \texttt{bash} does something special.}.
The equals sign, \verb!=!, is another non-alphanumeric character that has no special meaning to \texttt{bash}.
The non-special nature of these characters enables these two flag conventions.

Let's look at examples of the use of both short and long flags.
The command \texttt{ls} lists the files found in one or more directories; if
\index{commands@\textbf{commands}!ls}
no directories are specified, the files in the current directory are listed.
\texttt{ls} understands a number of flags that dictate how it displays the files in a directory.
The examples below show both the short and long form of some of these flags.
\begin{adjustwidth}{1cm}{}
\small
\verb!$ !{\ttfamily {\bfseries ls}}\verb!                    !\textit{list the contents of the current directory}\newline
\verb!book  calendar.data  Music  Pictures  shopping.list  src!\newline
\verb!$ !{\ttfamily {\bfseries ls -a}}\verb!                 !\textit{list the entire contents of the current directory}\newline
\verb!.   .bashrc   .vimrc  calendar.data  Pictures       src!\newline
\verb!..  .profile  book    Music          shopping.list!\newline
\verb!$ !{\ttfamily {\bfseries ls \verb!--!all}}\verb!              !\textit{long form of -a}\newline
\verb!.   .bashrc   .vimrc  calendar.data  Pictures       src!\newline
\verb!..  .profile  book    Music          shopping.list!\newline
\verb!$ !{\ttfamily {\bfseries ls \verb!--!group-directories-first}}\verb!  !\textit{places directories first, no short version}\newline
\verb!book  Music  Pictures  src  calendar.data  shopping.list!\newline
\verb!$ !{\ttfamily {\bfseries ls -p}}\verb!                 !\textit{append / to indicate directories}\newline
\verb!bin/  calendar.data  Music/  Pictures/  shopping.list  src/!\newline
\verb!$ !{\ttfamily {\bfseries ls \verb!--!indicator-style=slash}}\verb!    !\textit{long version of -p}\newline
\verb!bin/  calendar.data  Music/  Pictures/  shopping.list  src/!\newline
\verb!$ !{\ttfamily {\bfseries ls -t *.*}}\verb!             !\textit{display files ordered by modification time, newest first}\newline
\verb!shopping.list  calendar.data!\newline
\verb!$ !{\ttfamily {\bfseries ls -rt *.*}}\verb!            !\textit{same, but oldest first (reverse sort)}\newline
\verb!calendar.data  shopping.list!\newline
\verb!$ !{\ttfamily {\bfseries ls -w 20 *.*}}\verb!          !\textit{output is 20 characters wide}\newline
\verb!calendar.data!\newline
\verb!shopping.list!\newline
\verb!$ !{\ttfamily {\bfseries ls \verb!--!width=20 *.*}}\verb!     !\textit{the long form of -w 20}\newline
\verb!calendar.data!\newline
\verb!shopping.list!\newline
\normalsize
\end{adjustwidth}

After any flags, what about the other arguments to a command?
Most commands need to work on files, so the non-flag arguments are typically filenames.
There are other sorts of information that a command might need; for example, a program that
searches for textual patterns in a file requires at least one argument indicating the
pattern we wish to find.

In the last four examples above, we provided ``*.*'' as an argument to \texttt{ls}.
What does that mean?

As we mentioned previously, most of the non-alphanumeric characters available on the keyboard have
a special meaning to \texttt{bash}.
When \texttt{bash} breaks up the command into words, it looks for four particular special characters,
(\verb!*!, \verb!?!, \verb![!, and \verb!]!), as these indicate that \texttt{bash} should perform a
pattern match against filenames in the current directory.
In the last four \texttt{ls} examples above, ``*.*'' indicates that \texttt{bash} should replace
that string by all
filenames that consist of 1 or more characters before a \verb!.!, and 0 or more characters after.
In our directory, this pattern matches exactly two files, \texttt{calendar.data} and \texttt{shopping.list}.
\texttt{bash} replaces the single ``word'', ``*.*'', by two words in the list presented to \texttt{ls}.
The wildcard character, \verb!*!, is often used in the shell to select a subset of files to be processed
by the command.

The \verb!?! in a command argument indicates that it matches any single character at that point - e.g.,
``jo?n'' matches \verb!john! or \verb!joan!, but not \verb!johan!.
The square brackets enable the specification of a range of characters to match at a particular location
in the filename - e.g., ``ls a.[ch]'' would match files named \texttt{a.c} and \texttt{a.h} in the current
directory, but would \emph{not} match \texttt{a.x}.
One can also specify a range of characters within the square brackets - e.g., ``ls *.[a-d]'' would match
any files that end in \verb!.a!, \verb!.b!, \verb!.c!, or \verb!.d!.\footnote{Note that the wildcard expansion is done by \texttt{bash}, \emph{not} by the command itself (in this
case, \texttt{ls}).
By performing such substitution in the command line interpreter, it means that all programs benefit from
this feature.}

What should you do if you start a program by mistake?
Most commands can be stopped by typing \emph{ctl-c}, often known as the \texttt{INTERRUPT} character.
Some programs, like text editors, will stop whatever the program is doing when you type the
\texttt{INTERRUPT} character, but enable you to issue another command to the program after it has stopped.
Closing the terminal window will stop most programs, as well.

\section{Simple commands}
\label{sec:simplecommands}
Linux provides you with a number of simple commands to manipulate files and your environment.
This section covers some of the more useful ones.

\subsection{Obtaining help}
\label{sec:obtaininghelp}
Online manual pages for all of the commands in Linux are available over the Internet; it is a good idea to
maintain an open browser window while you are working so that you can access these manual pages.
A search query of the form ``linux man \textit{command}'' will yield several links to online man
pages for \textit{command}.
Additionally,
there is a directory available at \url{http://man7.org/linux/man-pages/dir_all_by_section.html};
you can skim it quickly for commands that might be relevant to what you want to do.
There is also an introduction to the system at
\url{http://www.tldp.org/LDP/intro-linux/intro-linux.pdf} that gives an overview of how things work.

Depending upon how complete a Linux system you have, the man pages for most of your commands may also
\index{commands@\textbf{commands}!man}
be available on your Linux system.  If so, you can display the manual page for \textit{command} by
typing ``man \textit{command}'' to \texttt{bash}.
Thus, to read about the \texttt{ls} command, type
\begin{adjustwidth}{1cm}{}
\small
\verb!$ !{\ttfamily {\bfseries man ls}}\verb!!\newline
\normalsize
\end{adjustwidth}

\subsection{Creating files}
\label{sec:creatingfiles}
Information on Linux systems is stored in files.
In order to enter information into a file, as well as to modify that information, you will need to use
a text editor.
It is likely that you have experience using \emph{document} editors, such as Microsoft\textsuperscript{TM}
Word.
Document editors not only enable you to enter and edit information in a document, it also enables you to
specify how that information should be formatted when it is displayed.
Most files in a Linux system do not require such formatting information - i.e., the content of the file is
a sequence of characters, with the end of line being the only type of formatting needed.

Every Linux system has several screen editors; the one you choose to use is a matter of personal taste.
The Arch Linux image described in Appendix B comes with \texttt{nano}
(\url{https://wiki.archlinux.org/index.php/nano}) and \texttt{vi}
(\url{https://wiki.archlinux.org/index.php/Vim}).
You may also install any of a number of other editors, such as \texttt{emacs} and \texttt{gedit}.
See \url{https://en.wikipedia.org/wiki/List_of_text_editors} for a list of text editors that has been
compiled in Wikipedia.

\begin{exercise}
\small
Choose a screen editor.
If your editor is named ``editor'', it is likely that you can find a tutorial
(or three) available on the web with a search query of the form ``editor tutorial''.
\begin{itemize}[noitemsep]
\item Work your way through your chosen tutorial, creating and editing the example files found therein.
\item Use your editor to create a new file in your home directory
(the directory in which you are placed when you create a new terminal window)
named \verb!Jabberwocky! and containing the following four lines\footnote{This is the first stanza from the poem entitled ``Jabberwocky'' by Lewis Carroll.}:
\begin{adjustwidth}{1cm}{}
\verb!'Twas brillig, and the slithy toves!\newline
\verb!Did gyre and gimble in the wabe;!\newline
\verb!All mimsy were the borogoves,!\newline
\verb!And the mome raths outgrabe.!\newline
\end{adjustwidth}
\item Use your editor to create \verb!Jabberwocky1!, starting with the contents
of \verb!Jabberwocky!, and with line 1 translated into modern English using
the following equivalences:
\begin{itemize}[noitemsep]
\item \verb!'Twas! --> \verb!It was!
\item \verb!brillig! --> \verb!evening!
\item \verb!slithy! --> \verb!smooth, active!
\item \verb!toves! --> \verb!badgers!
\end{itemize}
\item Use your editor to create \verb!Jabberwocky2!, starting with the contents
of \verb!Jabberwocky1!, and with line 2 translated into modern English using
the following equivalences:
\begin{itemize}[noitemsep]
\item \verb!gyre! --> \verb!scratch!
\item \verb!gimble! --> \verb!bore holes!
\item \verb!wabe! --> \verb!hill side!
\end{itemize}
\item Use your editor to create \verb!Jabberwocky3!, starting with the contents
of \verb!Jabberwocky2!, and with line 3 translated into modern English using
the following equivalences:
\begin{itemize}[noitemsep]
\item \verb!mimsy! --> \verb!unhappy!
\item \verb!borogoves! --> \verb!parrots!
\end{itemize}
\item Use your editor to create \verb!Jabberwocky4!, starting with the contents
of \verb!Jabberwocky3!, and with line 4 translated into modern English using
the following equivalences:
\begin{itemize}[noitemsep]
\item \verb!mome! --> \verb!solemn!
\item \verb!raths! --> \verb!turtles!
\item \verb!outgrabe! --> \verb!squeaked out!
\end{itemize}
\end{itemize}
When you have finished, \verb!Jabberwocky4! should read as:
\begin{adjustwidth}{1cm}{}
\verb!It was evening, and the smooth, active badgers!\newline
\verb!Did scratch and bore holes in the hill side;!\newline
\verb!All unhappy were the parrots,!\newline
\verb!And the solemn turtles squeaked out.!\newline
\end{adjustwidth}
$\Box$
\normalsize
\end{exercise}


\subsection{Listing your files}
\label{sec:listingyourfiles}
We have previously encountered \texttt{ls} in section \ref{sec:commandlineinterpreter}.
\index{commands@\textbf{commands}!ls}
In this section, we will provide examples of one other flag to \texttt{ls} that is heavily used.

As we will describe in the next section, Linux stores a number of items of information about each
file in the file system; this information is referred to as \emph{metadata}.
\texttt{ls} can be used to see some of this metadata:
\needspace{8\baselineskip}
\begin{adjustwidth}{1cm}{}
\small
\verb!$ !{\ttfamily {\bfseries ls -l}}\verb!!\newline
\verb!total 24!\newline
\verb!drwxrwxr-x 2 me me 4096 Jul  6 14:59 book!\newline
\verb!-rw-rw-r-- 1 me me  141 Jul  6 14:59 calendar.data!\newline
\verb!drwxrwxr-x 2 me me 4096 Jul  6 14:59 Music!\newline
\verb!drwxrwxr-x 2 me me 4096 Jul  6 14:59 Pictures!\newline
\verb!-rw-rw-r-- 1 me me   86 Jul  6 14:59 shopping.list!\newline
\verb!drwxrwxr-x 2 me me 4096 Jul  6 14:59 src!\newline
\normalsize
\end{adjustwidth}

As you can see, the \texttt{-l} flag gives a ``long''
listing that provides this metadata; the first line indicates the number of blocks of disk space occupied
by the listed files.
Each subsequent line provides information about an
individual file:
\begin{itemize}
\item the first character indicates if the file is
a directory (\texttt{d}) or a normal file (\texttt{-});
\item the next 9 characters indicate permissions to
read, write, or execute the file; the first 3 characters are for the owner of the file (\texttt{me} in
this case); the next 3 characters are for the group with which this file is associated (\texttt{me} is
the associated group); the next 3 characters are for
everyone else;
\item next we have the number of links to the file;
this will be discussed in the next section on the
file system;
\item the owner of the file (\texttt{me}) and the
associated group (\texttt{me}) follow;
\item next we have the size of the file (in bytes);
\item this is followed by the month, day, and time
of last modification;
\item and finally, we have the name of the file.
\end{itemize}

We previously noted that after all of the flags, one can specify one or more file names to \texttt{ls},
which then restricts its activity to those files.
For example,
\begin{adjustwidth}{1cm}{}
\small
\verb!$ !{\ttfamily {\bfseries ls -l calendar.data}}\verb!!\newline
\verb!-rw-rw-r-- 1 me me  141 Jul  6 14:59 calendar.data!\newline
\normalsize
\end{adjustwidth}

\begin{exercise}
\small
Use \verb!ls! to perform a long listing of your \verb!Jabberwocky! files.
How does the size of the file change going from the original to the final
translated version?
Is it as you expected?
\newline$\Box$
\normalsize
\end{exercise}

\subsection{Naming your files}
\label{sec:namingyourfiles}
\index{file system@\textbf{file system}!naming}
Most operating systems, and Linux is no exception, have rules about creating legal filenames.
Firstly, there is usually a limit on the length of a filename; early operating systems had very severe
restrictions; Linux restricts the length of a filename to 255 characters.
It is unusual for anyone to want to type that many characters as an argument to a command, so, in practice,
you will usually use far fewer letters in your filenames.

Secondly, what are the legal characters in a filename?
Linux allows any character in a filename except for \texttt{/} and a null character; this does \emph{not}
mean that you should start putting lots of strange characters in your filenames.
The POSIX specification\footnote{\url{http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html\#tag_03_280}} is quite clear on characters to use in filenames that are portable
across \emph{all} POSIX-conformant systems\footnote{Linux is a POSIX-conformant system}:
\begin{itemize}
\item any upper-case character from the set \texttt{"ABCDEFGHIJKLMNOPQRSTUVWXYZ"};
\item any lower-case character from the set \texttt{"abcdefghijklmnopqrstuvwxyz"};
\item any digit from the set \texttt{"0123456789"}; and
\item any character from the set \texttt{".\_-"}.
\end{itemize}

We have already seen that \texttt{-} is used to introduce flags in bash command lines, so you are \emph{strongly}
recommended to avoid starting your filenames with a \texttt{-}.
We have also seen above that filenames that start with a \texttt{.} are \emph{hidden} - i.e., they are not
displayed by \texttt{ls} unless you specify the \texttt{-a} or \verb!--all! flags; thus, you should avoid
starting your filenames with a \texttt{.} unless you want their existence to be hidden in this way.

\subsection{What's in a file?}
\label{sec:whatsinafile}
We often try to give files descriptive names in order to remember their contents.
When that fails, one often resorts to displaying the contents of the file to jog one's memory.

You could certainly use your favorite editor to display the contents, using whatever
commands it provides.
While this works, it is not the most efficient way to display the contents, since the editor is designed
to enable you to \emph{modify} the file.

Linux provides several commands that can be used to display the contents of a file:
\index{commands@\textbf{commands}!cat}
\begin{itemize}
\item The simplest program is \texttt{cat}, which simply prints the contents of each file argument on
the terminal.
\begin{adjustwidth}{1cm}{}
\small
\verb!$ !{\ttfamily {\bfseries cat shopping.list}}\verb!!\newline
\verb!1 bottle of milk!\newline
\verb!2 granny smith apples!\newline
\verb!10 hot house tomatoes!\newline
\verb!1 six-pack of Coca Cola!\newline
\normalsize
\end{adjustwidth}
\item \texttt{cat} works perfectly well for short files, like \texttt{shopping.list}, but for very long files
the contents will be displayed so rapidly in your terminal window that you will only see
the last screenful of lines (normally 24 lines) in the terminal window.
Linux provides two commands that will show one screenful at a time, waiting for an action from
the user to continue
the display, to search for a pattern, or to perform other tasks.
\begin{itemize}
\item \texttt{more} is an especially primitive program for paging through text one screenful at a time.
\index{commands@\textbf{commands}!more}
Often, this is all that is needed.
\item Counterintuitively, \texttt{less} is a program similar to \texttt{more}, but with more
\index{commands@\textbf{commands}!less}
features, such as backward movement in the file; additionally, \texttt{less} does not have to read
the entire input file before starting, so with large input files it starts up \emph{much} faster than text editors like \texttt{vi}.
\end{itemize}
\end{itemize}

\subsection{Moving, copying, removing files - \texttt{mv}, \texttt{cp}, \texttt{rm}}
\label{sec:movingcopyingremovingfiles}
In your prior experience with computer systems, you will have had the occasional need to rename
a file. On Linux, this is done with the \texttt{mv} command:
\index{commands@\textbf{commands}!mv}
\begin{adjustwidth}{1cm}{}
\small
\verb!$ !{\ttfamily {\bfseries mv shopping.list Shopping.List}}\verb!!\newline
\verb!$ !{\ttfamily {\bfseries ls *.*}}\verb!!\newline
\verb!calendar.data  Shopping.List!\newline
\verb!$ !{\ttfamily {\bfseries cat shopping.list}}\verb!!\newline
\verb!cat: shopping.list: No such file or directory!\newline
\normalsize
\end{adjustwidth}
The file \texttt{shopping.list} has been ``moved'' to a file named \texttt{Shopping.List}.
The old filename has disappeared, as evidenced by the output from \texttt{ls} and \texttt{cat}.
This example also shows that filenames are case-sensitive - i.e., the name \texttt{shopping.list} is
different from \texttt{Shopping.List}.

\faWarning~~~\textbf{If the target filename in an \texttt{mv} command already exists, it is replaced.}

To make a \emph{copy} of a file, one uses the \texttt{cp} command:
\index{commands@\textbf{commands}!cp}
\begin{adjustwidth}{1cm}{}
\small
\verb!$ !{\ttfamily {\bfseries cp Shopping.List 20170706-shopping.list}}\verb!!\newline
\normalsize
\end{adjustwidth}
saves an archive copy of the file \texttt{Shopping.List}.

To remove a file, one uses the \texttt{rm} command:
\index{commands@\textbf{commands}!rm}
\begin{adjustwidth}{1cm}{}
\small
\verb!$ !{\ttfamily {\bfseries rm Shopping.List shopping.list}}\verb!!\newline
\verb!rm: cannot remove 'shopping.list': No such file or directory!\newline
\normalsize
\end{adjustwidth}
As you can see, \texttt{rm} warns you if one of the files specified did not exist.
You can then invoke \texttt{ls} to verify that \texttt{rm} did its job:
\begin{adjustwidth}{1cm}{}
\small
\verb!$ !{\ttfamily {\bfseries ls *.*}}\verb!!\newline
\verb!20170706-shopping.list  calendar.data!\newline
\normalsize
\end{adjustwidth}

\subsection{Other useful programs}
\label{sec:otherusefulprograms}
Let's re-create our shopping list file (recall that we removed it above) for use with the other programs described in this section.
\begin{adjustwidth}{1cm}{}
\small
\verb!$ !{\ttfamily {\bfseries cp 20170706-shopping.list shopping.list}}\verb!!\newline
\verb!$ !{\ttfamily {\bfseries cat shopping.list}}\verb!!\newline
\verb!1 bottle of milk!\newline
\verb!2 granny smith apples!\newline
\verb!10 hot house tomatoes!\newline
\verb!1 six-pack of Coca Cola!\newline
\normalsize
\end{adjustwidth}

\subsubsection{Count lines, words, and characters - \texttt{wc}}
\label{sec:wc}
Suppose we need to know the number of different types of items that are contained in the shopping list.
\index{commands@\textbf{commands}!wc}
We could count the number of lines on the screen after displaying the file using \texttt{cat}; this type
of processing of files happens often enough that the program \texttt{wc} is provided - \texttt{wc} counts
the number of characters, words (each word is a sequence of non-whitespace characters, separated from
other words by whitespace), and lines.
The number of lines in \texttt{shopping.list} is exactly what we need:
\begin{adjustwidth}{1cm}{}
\small
\verb!$ !{\ttfamily {\bfseries wc shopping.list}}\verb!!\newline
\verb! 4 17 85 shopping.list!\newline
\verb!$ !{\ttfamily {\bfseries wc -l shopping.list}}\verb!!\newline
\verb!4 shopping.list!\newline
\verb!$ !{\ttfamily {\bfseries wc -w shopping.list calendar.data}}\verb!!\newline
\verb! 17 shopping.list!\newline
\verb! 19 calendar.data!\newline
\verb! 36 total!\newline
\normalsize
\end{adjustwidth}
If we simply invoke \texttt{wc} without any flags, it will print the number of lines, number of words,
and number of characters for each file specified in the command line.
If we specify \texttt{-l}, \texttt{wc} restricts itself to counting lines; \texttt{-w} or \texttt{-c}
restricts \texttt{wc} to counting words or characters, respectively.
If more than one file is specified in the command line, \texttt{wc} displays the counts for each
file, and provides a total in each category at the end.

\subsubsection{Translate or delete characters - \texttt{tr}}
\label{sec:tr}
\index{commands@\textbf{commands}!tr}
It often happens that you have a need to translate and/or delete characters in
a file.
\verb!tr! copies its standard input to standard output, translating or deleting
characters as described by its arguments.
Let's look at some simple examples.

\begin{adjustwidth}{1cm}{}
\small
\verb!$ !{\ttfamily {\bfseries tr a A}}\verb!!\newline
\verb!!{\ttfamily {\bfseries abacus}}\verb!!\newline
\verb!AbAcus!\newline
\textit{ctl-d}\verb!                !\textit{you type this to indicate end-of-file}\newline
\verb!$ !{\ttfamily {\bfseries tr -d x}}\verb!!\newline
\verb!!{\ttfamily {\bfseries xerxes}}\verb!!\newline
\verb!eres!\newline
\textit{ctl-d}\newline
\verb!$ !{\ttfamily {\bfseries tr '[:upper:]' '[:lower:]'}}\verb!!\newline
\verb!!{\ttfamily {\bfseries This Is A Test}}\verb!!\newline
\verb!this is a test!\newline
\textit{ctl-d}\newline
\verb!$ !{\ttfamily {\bfseries tr -s '[:blank:]' '\textbackslash{n}'}}\verb!!\newline
\verb!!{\ttfamily {\bfseries This~Is~~A~~~Test}}\verb!!\newline
\verb!This!\newline
\verb!Is!\newline
\verb!A!\newline
\verb!Test!\newline
\textit{ctl-d}\newline
\normalsize
\end{adjustwidth}

The first invocation tells \verb!tr! to replace all occurrences of `a' by
`A'.
Since \verb!tr! is a simple filter (only reads standard input and writes to
standard output), it reads \verb!abacus! from the keyboard, and writes
\verb!AbAcus! to the terminal window.
Note the use of \textit{ctl-d} typed to the keyboard to indicate end of file
from the keyboard.

The second invocation indicates that \verb!tr! should delete all occurrences
of the letter `x' found in the standard input.

The third invocation indicates that all upper-case characters on standard
input must be converted to their lower-case equivalents.
\verb!tr! understands a number of character class arguments (such as
\verb![:upper:]!); see the \verb!tr! man entry for a complete list.

The final invocation tells \verb!tr! to translate each horizontal white space
character (blank or tab) to an end of line character.
Sequences of multiple horizontal white space characters are ``squeezed'' into
a single horizontal white space character before the translation is performed.
As you can see, this causes each ``word'' in the file to be placed on a line
of its own.

\subsubsection{Report, omit, or count repeated lines - \texttt{uniq}}
\label{sec:uniq}
\index{commands@\textbf{commands}!uniq}

The default behavior for \verb!uniq! is to copy standard input to
standard output, replacing each sequence of matching lines by a single instance
of that line. If the \verb!-c! flag is specified, it precedes each line
by the number of occurrences in that sequence.

The following show an original file for which there are \emph{no} sequences of
matching lines, and the resulting output when that file is processed using
\verb!uniq -c!.
\small
\begin{adjustwidth}{1cm}{}
\verbatiminput{linux/uniq.out}
\end{adjustwidth}
\normalsize

As one would expect, all of the lines of input are reproduced on the output,
preceded by a count of 1.

Now let's see what happens if we sort the input file (using \verb!sort!) and
the output that results when the sorted file is processed using \verb!uniq -c!.
\small
\begin{adjustwidth}{1cm}{}
\verbatiminput{linux/uniqsorted.out}
\end{adjustwidth}
\normalsize

As expected, \verb!uniq! discovered two successive lines consisting solely of
``the''; it only output one line for ``the'', but preceded by a count of $2$.
Note that \verb!uniq! is case-sensitive, so although the sorted file contained
successive lines of ``this'' followed by ``This'', these were not seen as
a sequence of matching lines, and each was output with a count of $1$.

We will use \verb!uniq! later in this chapter to show the power of pipelines
in \verb!bash!.

\subsubsection{Find occurrence of a pattern - \texttt{grep}}
\label{sec:grep}
Suppose we do not remember whether we added apples to our shopping list.
\index{commands@\textbf{commands}!grep}
The command \texttt{grep}, which stands for \textbf{g}et \textbf{r}egular \textbf{e}xpression and \textbf{p}rint, will search the file arguments for lines that match a pattern.
The following shows us using \texttt{grep} to answer our question about apples.
\begin{adjustwidth}{1cm}{}
\small
\verb!$ !{\ttfamily {\bfseries grep apple shopping.list}}\verb!!\newline
\verb!2 granny smith apples!\newline
\normalsize
\end{adjustwidth}
Thus we see that we did add granny smith apples to the list.

We see that the first non-flag argument to \texttt{grep} is the pattern to search for - in this case, it
is simply the string ``apple''.
\texttt{grep} understands much more powerful patterns, called \emph{regular expressions}; we recommend that
you consult the Linux man entry for \texttt{grep} for more discussion of these more powerful patterns.

Suppose that your friend purchased apples on the way home from class, so that you do not need to
purchase them when you go to the store; the following shows how to print all lines that do \emph{not}
match the pattern.
\begin{adjustwidth}{1cm}{}
\small
\verb!$ !{\ttfamily {\bfseries grep -v apple shopping.list}}\verb!!\newline
\verb!1 bottle of milk!\newline
\verb!10 hot house tomatoes!\newline
\verb!1 six-pack of Coca Cola!\newline
\normalsize
\end{adjustwidth}

If you specify two or more file arguments to \texttt{grep}, it will prefix each matching line
with the name of the file in which it was found.
\begin{adjustwidth}{1cm}{}
\small
\verb!$ !{\ttfamily {\bfseries grep apple shopping.list calendar.data}}\verb!!\newline
\verb!shopping.list:2 granny smith apples!\newline
\normalsize
\end{adjustwidth}
Unsurprisingly, the term ``apple'' is not found in \texttt{calendar.data}; even so, since we
specified two filenames in the \texttt{grep} command, it prefixes the matching line in
\texttt{shopping.list} with the name of the file.

\subsubsection{Sorting files - \texttt{sort}}
\label{sec:sort}
This command sorts its input into alphabetical order, by default.
\index{commands@\textbf{commands}!sort}
The order can be changed using various flags which will be shown below.
Let's sort our shopping list.
\begin{adjustwidth}{1cm}{}
\small
\verb!$ !{\ttfamily {\bfseries sort shopping.list}}\verb!!\newline
\verb!1 bottle of milk!\newline
\verb!1 six-pack of Coca Cola!\newline
\verb!10 hot house tomatoes!\newline
\verb!2 granny smith apples!\newline
\normalsize
\end{adjustwidth}
Note that the default sorting order of characters is blank, then digit, then upper-case letter,
then lower-case letter.
This explains why the ``milk'' line appears before the ``Coke'' line (s in `six' comes after b in `bottle'), why the ``tomatoes'' line appears after the ``Coke'' line (`1 ' comes before `10'), and why the ``apple''
line comes last (`2' comes after `1').

As indicated above, \texttt{sort} has many options to control the sort order - e.g., numerical order, by
field within each line, reverse the order.
Here are some examples, again using \texttt{shopping.list}.
\begin{adjustwidth}{1cm}{}
\small
\verb!$ !{\ttfamily {\bfseries sort -r shopping.list}}\verb!           !\textit{reverse the order of the sort}\newline
\verb!2 granny smith apples!\newline
\verb!10 hot house tomatoes!\newline
\verb!1 six-pack of Coca Cola!\newline
\verb!1 bottle of milk!\newline
\verb!$ !{\ttfamily {\bfseries sort -n shopping.list}}\verb!           !\textit{numeric sort on first field}\newline
\verb!1 bottle of milk!\newline
\verb!1 six-pack of Coca Cola!\newline
\verb!2 granny smith apples!\newline
\verb!10 hot house tomatoes!\newline
\verb!$ !{\ttfamily {\bfseries sort -k 2 shopping.list}}\verb!         !\textit{sort on 2\textsuperscript{nd} field}\newline
\verb!1 bottle of milk!\newline
\verb!2 granny smith apples!\newline
\verb!10 hot house tomatoes!\newline
\verb!1 six-pack of Coca Cola!\newline
\normalsize
\end{adjustwidth}
Note that a field is defined as a sequence of non-whitespace characters separated from other fields by
whitespace characters.
Thus, \textbf{b}ottle \textless{} \textbf{g}ranny \textless{} \textbf{h}ot \textless{}
\textbf{s}ix in the last example above.

\subsubsection{Beginning and end of a file - \texttt{head} and \texttt{tail}}
\label{sec:headtail}
We discussed \texttt{more} and \texttt{less} above for displaying the contents of a file.
A very common occurrence is the need to just see the first few lines, or the last few lines, of a file.
This capability is provided by \texttt{head} and \texttt{tail}, respectively, as shown in the following
examples.
\index{commands@\textbf{commands}!head}
\index{commands@\textbf{commands}!tail}
\begin{adjustwidth}{1cm}{}
\small
\verb!$ !{\ttfamily {\bfseries head shopping.list}}\verb!              !\textit{print the first 10 lines}\newline
\verb!1 bottle of milk!\newline
\verb!2 granny smith apples!\newline
\verb!10 hot house tomatoes!\newline
\verb!1 six-pack of Coca Cola!\newline
\verb!$ !{\ttfamily {\bfseries head -n 1 shopping.list}}\verb!         !\textit{print the first line}\newline
\verb!1 bottle of milk!\newline
\verb!$ !{\ttfamily {\bfseries head \verb!--!lines=1 shopping.list}}\verb!    !\textit{print the first line}\newline
\verb!1 bottle of milk!\newline
\verb!$ !{\ttfamily {\bfseries tail shopping.list}}\verb!              !\textit{print the last 10 lines}\newline
\verb!1 bottle of milk!\newline
\verb!2 granny smith apples!\newline
\verb!10 hot house tomatoes!\newline
\verb!1 six-pack of Coca Cola!\newline
\verb!$ !{\ttfamily {\bfseries tail -n 1 shopping.list}}\verb!         !\textit{print the last line}\newline
\verb!1 six-pack of Coca Cola!\newline
\verb!$ !{\ttfamily {\bfseries tail \verb!--!lines=1 shopping.list}}\verb!    !\textit{print the last line}\newline
\verb!1 six-pack of Coca Cola!\newline
\normalsize
\end{adjustwidth}

\subsubsection{Comparing files - \texttt{cmp} and \texttt{diff}}
\label{sec:cmpdiff}
It is common to need to compare files to understand \emph{if} they are different, and if they are, \emph{how}
they differ.
Earlier in this chapter, we made a copy of \texttt{shopping.list} named \texttt{20170706-shopping.list}.
Perhaps, as part of a dietary regimen, we need to keep the shopping list that we use each day.
\begin{adjustwidth}{1cm}{}
\small
\verb!$ !{\ttfamily {\bfseries cat 20170706-shopping.list}}\verb!!\newline
\verb!1 bottle of milk!\newline
\verb!2 granny smith apples!\newline
\verb!10 hot house tomatoes!\newline
\verb!1 six-pack of Coca Cola!\newline
\normalsize
\end{adjustwidth}
We have discovered that we do not eat enough tomatoes, such that we are building up a tomato mountain in
the kitchen.
Therefore, we change the quantity of tomatoes in \texttt{shopping.list} to 3 instead of 10, as shown below.
\begin{adjustwidth}{1cm}{}
\small
\verb!$ !{\ttfamily {\bfseries cat shopping.list}}\verb!!\newline
\verb!1 bottle of milk!\newline
\verb!2 granny smith apples!\newline
\verb!3 hot house tomatoes!\newline
\verb!1 six-pack of Coca Cola!\newline
\normalsize
\end{adjustwidth}

Just before you go to the store, you cannot remember if you changed the quantity of tomatoes or not.
You could just display the file, and look for the changes, but there may have been many changes, and
we sometimes do not see subtle textual differences.
Therefore, we can rely upon comparison tools to help us out.

The first comparison program, \texttt{cmp}, compares the two files and reports the first difference that it finds.
\index{commands@\textbf{commands}!cmp}
\begin{adjustwidth}{1cm}{}
\small
\verb!$ !{\ttfamily {\bfseries cmp shopping.list 20170706-shopping.list}}\verb!!\newline
\verb!shopping.list 20170706-shopping.list differ: byte 40, line 3!\newline
\normalsize
\end{adjustwidth}
While \texttt{cmp} has indicated we made some change to \texttt{shopping.list}, we want to verify
that we made the correct change, just in case.
This is where \texttt{diff} comes handy.
\index{commands@\textbf{commands}!diff}
\needspace{4\baselineskip}
\begin{adjustwidth}{1cm}{}
\small
\verb!$ !{\ttfamily {\bfseries diff shopping.list 20170706-shopping.list}}\verb!!\newline
\verb!3c3!\newline
\verb!< 3 hot house tomatoes!\newline
\verb!---!\newline
\verb!> 10 hot house tomatoes!\newline
\normalsize
\end{adjustwidth}
The `3c3' line indicates that only line 3 of the two files are different;
lines preceded by \textless~ are lines in the first file (\texttt{shopping.list} in this case), and lines
preceded by \textgreater~ are lines in the second file (\texttt{20170706-shopping.list} in this case).
If there had been more than one difference in the two files, each such difference would have been
shown in this way.

\begin{exercise}
\small
Use \verb!diff! to compare your \verb!Jabberwocky! files.
An easy way to do this is to use the following command to \verb!bash!:
\begin{adjustwidth}{1cm}{}
\verb!$ for n in 1 2 3 4; do!\newline
\verb!> diff Jabberwocky Jabberwocky$n!\newline
\verb!> done!\newline
\end{adjustwidth}
Note how \verb!diff! shows you the smallest number of changes needed to
convert from the first file argument to the second.
Is the output as you expected?
\newline$\Box$
\normalsize
\end{exercise}

\section{The file system}
\label{sec:thefilesystem}
We have introduced the basic notion of a file, and metadata about a file, in the previous section.
Now we need to understand how Linux organizes the file system.

\begin{wrapfigure}{R}{0.4\textwidth}
\centering
\label{CaDS tree}
\includegraphics[width=1.0\linewidth]{linux/DirectoryTree}
{\small Partial directory tree}
\end{wrapfigure}
In your previous computing experience, you have undoubtedly been exposed to folders via a graphical user
interface.
A folder contains files and, often, other folders.
Double clicking on a folder usually causes its contents to be displayed.
Double clicking on a file in a folder usually causes an application associated with that type of
file to execute on that file.
Most systems provide some way to visualize the file tree hierarchy; here is the hierarchy for the
current state of this book.
Note that directories are shown in \textbf{\textcolor{blue}{blue}} and files are shown in \textbf{\textcolor{OliveGreen}{green}}.

Different folders can each contain a file with the same name, such as \texttt{shopping.list}, for example,
although the contents of the files are different.
This means that the unique name for a file is a sequence of directories from the root to the file itself;
for example, in this directory tree, rooted at \texttt{CaDS}, the unique name for \texttt{shopping.list} is the sequence of names
\verb!{ CaDS, ch02, me, shopping.list }!.
This complete sequence of names is termed a \emph{pathname}, as it describes a path from the root to the
\index{file system@\textbf{file system}!pathname}
file that is of interest.

Linux provides a hierarchical file system of this type.
The root of the tree has the name \texttt{/}, and the complete pathname for \texttt{shopping.list}, assuming that
\texttt{CaDS} is a directory in the root, would be
\verb!/CaDS/ch02/me/shopping.list! - i.e., the complete pathname starts with the root, and each subsequent
pair of names in the path are separated by \texttt{/}.
While this overloading of the use of \texttt{/} may seem strange, one quickly becomes accustomed to it.

Given such a hierarchical structure, it is common to use family terms to describe the relationships
between directories.
If a directory \texttt{a} contains a directory \texttt{b}, \texttt{a} is the \emph{parent} of \texttt{b},
and \texttt{b} is the \emph{child} of \texttt{a}.
\texttt{a}'s parent is the \emph{grandparent} of \texttt{b}, and so on.

\subsection{Current working directory and home directory}
\label{sec:cwdandhome}
\index{file system@\textbf{file system}!current working directory}
It would be extremely tedious to have to type the full pathname each time you wanted to refer to a file,
so \texttt{bash} maintains a notion of your \emph{current working directory}.
It also maintains a notion of your \emph{home directory}, which has been assigned to you when your
account was created; 
whenever you start up a terminal window, your current working directory is your home directory.
If you type a file name that does \emph{not} start with a \texttt{/}, it assumes that you are naming
the file relative to the current working directory.
All of the examples in the previous sections of this chapter assume that our current working
directory is \verb!/CaDS/ch02/me!, such that invoking \verb!cat shopping.list! will yield the contents of
\texttt{shopping.list} on the screen.

\index{file system@\textbf{file system}!home directory}
For the purposes of this textbook, your home directory is \verb!/home/me!.
Your home directory never changes, while your current working directory can, as we will now show\footnote{We will no longer show the text you type in \textbf{boldface}. It should be obvious as it follows the
\texttt{bash} prompt, ``\$ ''.}.
\begin{adjustwidth}{1cm}{}
\small
\verb!$ pwd                         !\textit{what is our current working directory}\newline
\verb!/home/me                      !\textit{just started bash, we are in our home directory}\newline
\verb!$ ls -p                       !\textit{what's in our home directory?}\newline
\verb!20170706-shopping.list  calendar.data  Pictures/      src/!\newline
\verb!book/                   Music/         shopping.list!\newline
\verb!$ cd Music                    !\textit{change into the Music directory}\newline
\verb!$ pwd                         !\textit{let's see if we were successful}\newline
\verb!/home/me/Music                !\textit{yes we were}\newline
\verb!$ ls                          !\textit{what's in the Music directory? nothing}\newline
\verb!$ cd ..; pwd                  !\textit{go up one level in the directory hierarchy}\newline
\verb!/home/me                      !\textit{we are back home}\newline
\verb!$ cd src; pwd; cd; pwd        !\textit{cd into src; what does cd without a directory do?}\newline 
\verb!/home/me/src!\newline
\verb!/home/me                      !\textit{ok, cd without a directory takes us home}\newline
\verb!$ cd /home/me/Pictures; pwd   !\textit{we can specify a full pathname to cd, as well}\newline
\verb!/home/me/Pictures!\newline
\verb!$ cd ~; pwd                   !\textit{what does `\textasciitilde' mean?}\newline
\verb!/home/me                      !\textit{ok, it's shorthand for home}\newline
\normalsize
\end{adjustwidth}

You may wonder why we need the \verb!'~'! shorthand for the home directory; it can be used as the first
character of a pathname, as in \verb!~/shopping.list!, to access files that are in your home
directory.
Thus, no matter where your current working directory is in the hierarchy, you can easily access files
that are directly reachable from your home directory.

The use of \verb!'..'! seems a little strange for referring to the parent of our current working
directory. Why is this the case? Remember when we used the \texttt{-a} flag to \texttt{ls} earlier:
\begin{adjustwidth}{1cm}{}
\small
\verb!$ pwd!\newline
\verb!/home/me!\newline
\verb!$ ls -a!\newline
\verb!.   .bashrc   .vimrc  calendar.data  Pictures       src!\newline
\verb!..  .profile  book    Music          shopping.list!\newline
\normalsize
\end{adjustwidth}
Notice that there are two entries in the directory named \verb!'.'! and \verb!'..'!.
These entries were placed in the directory when the directory was created.
\verb!'..'! points to the parent of this directory (here it points to \texttt{/home});
\verb!'.'! points to the directory itself (here it points to \texttt{/home/me}.
\index{file system@\textbf{file system}!.}
\index{file system@\textbf{file system}!..}

Let's navigate up the tree to see what happens.
\begin{adjustwidth}{1cm}{}
\small
\verb!$ cd Music; pwd               !\textit{let's start somewhere interesting}\newline
\verb!/home/me/Music!\newline
\verb!$ cd ..; pwd                  !\textit{go up one level}\newline
\verb!/home/me!\newline
\verb!$ cd ..; pwd                  !\textit{again}\newline
\verb!/home!\newline
\verb!$ cd ..; pwd                  !\textit{and again}\newline
\verb!/!\newline
\verb!$ cd ..; pwd                  !\textit{will this work?}\newline
\verb!/!\newline
\normalsize
\end{adjustwidth}
We see from this little experiment that the root is its own parent; we can ask to change our
working directory to root's parent, but we stay in the same place.

Just as we can use \verb!'~'! as shorthand for our home directory, we can use use \verb!'.'! as shorthand
for our current directory and \verb!'..'! as shorthand for the parent of our current directory.
Consider the following commands; the examples refer to the file system shown on page \pageref{CaDS tree}.
\begin{adjustwidth}{1cm}{}
\small
\verb!$ pwd!\newline
\verb!/CaDS/ch02/me!\newline
\verb!$ ls -p ..!\newline
\verb!adm3a.jpg  ch02.synctex.gz  DirectoryTree.pdf  me.tgz!\newline
\verb!ch02.pdf   ch02.tex         me/                model33teletype.jpg!\newline
\verb!$ cd Music; pwd!\newline
\verb!/CaDS/ch02/me/Music!\newline
\verb!$ cat ../shopping.list                !\textit{Need to look at shopping list again}\newline
\verb!1 bottle of milk!\newline
\verb!2 granny smith apples!\newline
\verb!3 hot house tomatoes!\newline
\verb!1 six-pack of Coca Cola!\newline
\verb!$ head -n 1 ../../me/shopping.list    !\textit{Admittedly unusual, but works}\newline
\verb!1 bottle of milk!\newline
\verb!$ cd ..; tail -n 1 ./shopping.list    !\textit{./name treated identically to name}\newline
\verb!1 six-pack of Coca Cola!\newline
\normalsize
\end{adjustwidth}

\label{sec:dotanddotdot}
The last two examples are meant to show that you can introduce \verb!'.'! and \verb!'..'! as elements of a
pathname. The last example may seem strange, but later you will see a situation where using \verb!'./'!
comes in handy.

\subsection{Creating a new directory - \texttt{mkdir}}
\label{sec:mkdir}
\index{commands@\textbf{commands}!mkdir}
Let's suppose that we want to create a directory to hold all of our archival shopping lists.
\begin{adjustwidth}{1cm}{}
\small
\verb!$ cd                          !\textit{go home}\newline
\verb!$ mkdir ShoppingLists         !\textit{create our directory}\newline
\verb!$ cd ShoppingLists            !\textit{make it our working directory}\newline
\verb!$ ls -a                       !\textit{what's in a newly-created directory?}\newline
\verb!.  ..                         !\textit{only the link to our parent and ourselves}\newline
\verb!$ cd ..                       !\textit{up to our parent}\newline
\verb!$ ls -l ShoppingLists         !\textit{it's empty, so no output from ls}\newline
\verb!$ ls -dl ShoppingLists        !\textit{-d flag says describe the directory}\newline
\verb!drwxrwxr-x 2 me me 4096 Jul 11 16:00 ShoppingLists!\newline
\normalsize
\end{adjustwidth}
There is also an \texttt{rmdir} command that can be used to remove a directory; this will only work \emph{if}
\index{commands@\textbf{commands}!rmdir}
the directory is empty - i.e., the only entries in the directory are \verb!'.'! and \verb!'..'!.

\subsection{The Linux hierarchical file system structure}
\label{sec:Linuxfilesystem}
\index{Linux file system}

Linux organizes all of the files in the system into a single hierarchy.
There can be millions of files in the file system of a single Linux system; for the
Arch Linux system used in this book, there are \textgreater{160,000} files and \textgreater{13,000} directories.
%\newpage
\begin{wrapfigure}{R}{0.25\textwidth}
\includegraphics[scale=0.55]{linux/root-tree}
\end{wrapfigure}

For typical use of a Linux system, the most important directories are:
\begin{itemize}[noitemsep]
\item \texttt{/bin} - contains basic progams (like \texttt{bash}) that are required during the boot process;
\item \texttt{/sbin} - contains programs that must be accessed by the system administrator;
\item \texttt{/lib} - contains dynamic libraries and static support files needed in the boot process;
\item \texttt{/etc} - contains configuration files for the system;
\item \texttt{/home} - contains the home director for each user (\texttt{/home/me} in our case);
\item \texttt{/usr} - has several important sub-directories:
\begin{itemize}[noitemsep]
\item \texttt{/usr/bin} - contains programs that are accessed by all users,
\item \texttt{/usr/sbin} - contains programs that must be accessed by the system administrator,
\item \texttt{/usr/lib} - contains dynamic libraries and static support files for the programs in \texttt{/usr/bin} and \texttt{/usr/sbin},
\item \texttt{/usr/include} - contains include files needed by C and C++ programs,
\item \texttt{/usr/share/doc} and \texttt{/usr/share/man} - contain manuals, documentation, examples, etc.,
\item \texttt{/usr/local} - has \texttt{bin}, \texttt{include}, \texttt{lib}, \texttt{etc}, etc. directories for locally added software.
\end{itemize}
\end{itemize}

\section{Back to the shell}
\label{sec:backtotheshell}
\subsection{Environment variables}
\label{sec:environmentvariables}
We have already discussed how the shell breaks up the command you typed into words, uses the 1\textsuperscript{st} word in that
sequence to find the program to run, and passes all of the other words to the program for it to interpret.
Besides passing these arguments to a program, it also maintains a set of (name, value) pairs that it provides
to the program for it to use if it wishes - this set of (name, value) pairs is known as the \emph{environment}.
\index{bash@\textbf{bash}!environment}

The command to type to see what is currently in the environment is \texttt{env}:
\begin{adjustwidth}{1cm}{}
\small
\verb!$ env                    !\textit{display the environment}\newline
\verb! * * *                   !\textit{several variables specific to particular programs}\newline
\verb!XTERM_SHELL=/bin/bash    !\textit{the shell reading a new terminal window}\newline
\verb!USER=me                  !\textit{my identity}\newline
\verb!PWD=/home/me             !\textit{my current working directory}\newline
\verb!HOME=/home/me            !\textit{my home directory}\newline
\verb! * * *                   !\textit{many other variables specific to particular programs}\newline
\verb!PATH=/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/bin/site_perl:!\newline
\verb!/usr/bin/vendor_perl:/usr/bin/core_perl!\newline
\verb! * * *                   !\textit{many other variables specific to particular programs}\newline
\normalsize
\end{adjustwidth}
\index{bash@\textbf{bash}!environment variable}
Each environment variable has a name consisting of upper-case letters, digits, and underscores (\verb!'_'!).
Each is displayed in the form ``NAME=value''.
We can use our friend \texttt{echo} to see the current value of a particular environment variable as follows:
\begin{adjustwidth}{1cm}{}
\small
\verb!$ echo $USER             !\textit{what is the current value of USER?}\newline
\verb!me                       !\textit{as we expected}\newline
\normalsize
\end{adjustwidth}
When \texttt{bash} encounters \verb!$ENVIRONMENT_VARIABLE_NAME! in a command line, it replaces it with the current value of that variable.
Thus, in the example above, \texttt{bash} replaces \verb!$USER! with \verb!me!, sending that as the command
argument to \texttt{echo}, which dutifully prints \verb!me! on the terminal.

Environment variables are just a specific case of shell variables, which enable the user to assign values to
names and refer to those values using the \verb!$name! syntax.
\index{bash@\textbf{bash}!shell variable}

How does one establish the value of a variable?
How does one remove a variable?
How does one make that variable part of the environment?
The easiest way to answer these questions is to show a number of examples.
\begin{adjustwidth}{1cm}{}
\small
\verb!$ ID=/usr/local/include  !\textit{`ID' has a very long value}\newline
\verb!$ echo $ID               !\textit{did it work?}\newline
\verb!/usr/local/include       !\textit{yes}\newline
\verb!$ bash                   !\textit{create a child process running bash}\newline
\verb!$ echo $ID               !\textit{see if the child process knows the value of `ID'}\newline
\verb!                         !\textit{no, it is not part of the environment}\newline
\verb!$ exit                   !\textit{exit the child \texttt{bash} process}\newline
\verb!$ export ID              !\textit{make this variable part of the environment}\newline
\verb!$ bash                   !\textit{create a child process running bash}\newline
\verb!$ echo $ID               !\textit{see if the child process knows the value of `ID'}\newline
\verb!/usr/local/include       !\textit{yes}\newline
\verb!$ exit                   !\textit{exit the child \texttt{bash} process}\newline
\verb!$ unset ID               !\textit{remove `ID' from the set of variables}\newline
\verb!$ echo $ID               !\textit{make sure it has been removed}\newline
\verb!                         !\textit{yes, it has no value}\newline
\normalsize
\end{adjustwidth}
\texttt{bash} makes the environment available to the process that it creates to run your program; the
program can access the value associated with an environment variable through a library call (\texttt{getenv()}) provided by the system.
\index{bash@\textbf{bash}!search path}

A particular environment variable, \texttt{PATH}, is of particular importance to \texttt{bash}, as it tells
\index{bash@\textbf{bash}!shell variable!PATH}
\texttt{bash} where to look for the program that you have requested.
\texttt{PATH} consists of a sequence of directory names separated by colons (\verb!:!).
After \texttt{bash} has broken up your command into words, it then proceeds to search for an executable file
with the name you have specified in each component of \texttt{PATH} until it either finds such a file, or
it has exhausted the \texttt{PATH}.
In the former case, it then runs the program in a process, giving it the remaining arguments for it to
process.

A standard program is provided which will perform this search \emph{without} starting up the program -
\texttt{which}. Let's look at it in action.
\begin{adjustwidth}{1cm}{}
\small
\verb!$ which bash             !\textit{where is bash stored?}\newline
\verb!/usr/bin/bash!\newline
\verb!$ which wc               !\textit{where is wc stored?}\newline
\verb!/usr/bin/wc!\newline
\verb!$ which pyhton3          !\textit{look for python3, but a typo}\newline
\verb!which: no pyhton3 in (/usr/local/sbin:/usr/local/bin:/usr/bin:!\newline
\verb!/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perl)!\newline
\verb!$ pyhton3                !\textit{let's see what bash says}\newline
\verb!bash: pyhton3: command not found!\newline
\normalsize
\end{adjustwidth}
From these examples, we can deduce a couple of things:
\begin{itemize}[noitemsep]
\item most of the standard programs are in \texttt{/usr/bin}; and
\item if the command you have typed cannot be found using \texttt{PATH}, \texttt{bash} will report it, and
\texttt{which} will also report the search path used.
\end{itemize}

While this is interesting, if the search path was fixed, then there would not be much point in discussing
it.
Fortunately, since \texttt{PATH} is an environment variable, you can change it, and \texttt{bash} will begin
to use the new version of \texttt{PATH} on the very next command you type.
Before showing you how this is done, why might we want to change \texttt{PATH}?

We've previously discussed the \texttt{/usr/local} branch of the file system as a place where
site-specific programs are typically installed on your system. You really wouldn't want to put these
programs in \texttt{/usr/bin}, since the next release of the operating system would require you to remember
all of the non-standard programs that you placed in \texttt{/usr/bin} so that you could reinstall them.
Sometimes you want a site-specific version of one of the standard programs, and whenever that program is
invoked, you want the site-specific version to be found instead of the standard one.
And, finally, you might want to have a number of your own programs (it is very easy to do) that you use
regularly, and you want \texttt{bash} to be able to find them in the same way.

Note that the search performed by \texttt{bash} goes from left to right in the sequence of directories that
make up \texttt{PATH}.
Thus, if you want to find your version of \texttt{ls} instead of the one stored in \texttt{/usr/bin}, then
your version will have to be in a directory that is earlier in \texttt{PATH} than \texttt{/usr/bin}.
Let's experiment with this a bit.
\begin{adjustwidth}{1cm}{}
\small
\verb!$ mkdir ~/bin            !\textit{let's create a personal bin directory}\newline
\verb!$ cp /usr/bin/ls ~/bin   !\textit{make a copy of ls in that directory}\newline
\verb!$ sudo cp /usr/bin/ls /usr/local/bin  !\textit{make a copy in /usr/local/bin}\newline
\verb![sudo] password for me:  !\textit{type your password, followed by Enter; no echo}\newline
\verb!$ ls -l ~/bin/ls /usr/local/bin/ls /usr/bin/ls!\newline
\verb!-rwxr-xr-x 1 me   me   130552 Jul 12 15:11 /home/me/bin/ls!\newline
\verb!-rwxr-xr-x 1 root root 130552 Mar 12 07:09 /usr/bin/ls!\newline
\verb!-rwxr-xr-x 1 root root 130552 Jul 12 15:10 /usr/local/bin/ls!\newline
\verb!$ PATH=/usr/bin:/bin     !\textit{set path to just /usr/bin and /bin}\newline
\verb!$ which ls!\newline
\verb!/usr/bin/ls              !\textit{found it in /usr/bin}\newline
\verb!$ PATH=/usr/local/bin:$PATH           !\textit{insert /usr/local/bin at the front}\newline
\verb!$ which ls!\newline
\verb!/usr/local/bin/ls        !\textit{found it in /usr/local/bin}\newline
\verb!$ PATH=~/bin:$PATH       !\textit{insert \textasciitilde/bin at the front}\newline
\verb!$ which ls!\newline
\verb!/home/me/bin/ls          !\textit{found it in \textasciitilde/bin}\newline
\verb!$ rm ~/bin/ls            !\textit{remove copy from \textasciitilde/bin}\newline
\verb!$ which ls!\newline
\verb!/usr/local/bin/ls        !\textit{found it in /usr/local/bin}\newline
\verb!$ sudo rm /usr/local/bin/ls           !\textit{remove copy from /usr/local/bin}\newline
\verb![sudo] password for me:!\newline
\verb!$ which ls!\newline
\verb!/usr/bin/ls              !\textit{found it in /usr/bin}\newline
\verb!$ echo $PATH!\newline
\verb!/home/me/bin:/usr/local/bin:/usr/bin:/bin!\newline
\normalsize
\end{adjustwidth}
Only two tricky things in this exercise:
\begin{itemize}[noitemsep]
\item as can be done in most programming languages, we can define a new value for a variable in terms
of its previous value; thus, the expression \verb!PATH=/usr/local/bin:$PATH! causes the shell to append
the current value of \texttt{PATH} (\verb!$PATH!) to the string \texttt{/usr/local/bin:}, and to assign the
concatenated string as the new value of \texttt{PATH}; and
\index{commands@\textbf{commands}!sudo}
\item there is a command available in Linux, \texttt{sudo}, that allows you to become the root user to
exercise one command; if you perform \verb!ls -dl /usr/local/bin!, you will see that it is owned by the
\texttt{root} user, and you do not have write permission to that directory; by using the \texttt{sudo}
command, you can perform the requested command (first \texttt{cp} to create the copy there, and later
\texttt{rm} to remove the copy) as if you were the root user; the Arch Linux virtual machine knows that
your account (\texttt{me}) is permitted to use \texttt{sudo}, all you need to do is type your password
to be able to perform the command.
\end{itemize}

\subsection{Input, output, error output}
\label{sec:inputoutputerror}
So far, we have focused on typing commands on the keyboard to the shell, the shell parses each command
to determine which program to run, it creates a process to run that program, and the shell makes the
arguments and the environment available to that program.
The shell then waits for that program to finish before prompting the user for another command.
All of our examples so far take some action and output the results to the screen; if a program detects
something wrong, it displays an error message on the screen.
Computers would be not nearly as useful to us if this was all that could be done.
\index{bash@\textbf{bash}!standard input}
\index{bash@\textbf{bash}!standard output}
\index{bash@\textbf{bash}!standard error output}

When a program comes to life, three data channels are defined:
\begin{itemize}[noitemsep]
\item standard input - this is the default channel from which the program can read data; it is normally
the keyboard;
\item standard output - this is the default channel to which the program can write results of its
processing; it is normally the terminal window; and
\item standard error output - this is the default channel to which the program can write error messages; it is normally the terminal window.
\end{itemize}

The shell sets up these standard channels for a program when it starts it in a process.
Thus, the shell is in a position to \emph{redirect} these channels to files or other objects in the
system.
\index{bash@\textbf{bash}!IO redirection}
\subsubsection{Input redirection}
\label{sec:inputredirection}
First, let's focus on taking our input from a file instead of the keyboard;
\index{bash@\textbf{bash}!standard input redirection}
consider the following example.
\begin{adjustwidth}{1cm}{}
\small
\verb!$ cd                     !\textit{make sure we are home}\newline
\verb!$ cat shopping.list      !\textit{reacquaint ourselves with shopping.list}\newline
\verb!1 bottle of milk!\newline
\verb!2 granny smith apples!\newline
\verb!3 hot house tomatoes!\newline
\verb!1 six-pack of Coca Cola!\newline
\verb!$ cat                    !\textit{invoke without a filename}\newline
\verb!line 1                   !\textit{you type this}\newline
\verb!line 1                   !\textit{cat echoes the line}\newline
\textit{ctl-d}\verb!                     !\textit{you type this to indicate end-of-file}\newline
\verb!$ cat <shopping.list     !\textit{what is this?}\newline
\verb!1 bottle of milk         !\textit{we obtain the same results as before}\newline
\verb!2 granny smith apples!\newline
\verb!3 hot house tomatoes!\newline
\verb!1 six-pack of Coca Cola!\newline
\normalsize
\end{adjustwidth}
There are several things going on here that make this work:
\begin{itemize}[noitemsep]
\item when \texttt{cat} is invoked, if any arguments are supplied, it copies the contents of those files to the terminal window;
\item if invoked without any arguments, it copies the standard input to the terminal window;
\item in the first case above where \texttt{cat} was invoked without arguments, the standard input was
the keyboard; thus, you had to type on the keyboard to provide \texttt{cat} with characters that it could
write to the terminal window; note that \textit{ctl-d} is the character to type at the keyboard to
indicate an end of file;
\item in the second case above, the shell interpreted \verb!<shopping.list! to
mean that standard input for \texttt{cat} should come from \texttt{shopping.list}, not from the keyboard;
it resets standard input for \texttt{cat} to be from the file \emph{and} removes \verb!<shopping.list!
from the set of arguments made available to \texttt{cat};
\item \texttt{cat} doesn't care, as it has been invoked without any arguments, so it simply reads from
standard input until an end of file is detected.
\end{itemize}

Thus we see that \texttt{bash} interprets yet another special character, \texttt{\textless}, to indicate
that the standard input for the program should come from a file rather than from the keyboard.
This redirection occurs without \emph{any} knowledge on the part of the program (\texttt{cat} in this case).
Correct behavior does demand that the program read from standard input if it has not received any file
arguments.\footnote{Some programs, such as \texttt{cat}, understand an argument consisting solely of a
hyphen (\texttt{-}) to mean that it should also read from the standard input, as in
\texttt{cat file1 - file2} - i.e., copy contents of \texttt{file1} to the terminal window, then copy the
contents from standard input to the terminal window, and finally copy contents of \texttt{file2} to the
terminal window. The man page for a particular command will indicated if a particular program interprets a bare '-' in this way.}

\subsubsection{Output redirection}
\label{sec:outputredirection}
Often one would like to capture the output of a program into a file, not have it displayed in the
\index{bash@\textbf{bash}!standard output redirection}
terminal window; in fact, in creating this textbook, a large number of files have been generated in this
way in order to show you the actual interaction dialogs that occur on the system.
Let's consider the following example:
\begin{adjustwidth}{1cm}{}
\small
\verb!$ echo '$ ls -l'; ls -l  !\textit{show command and output}\newline
\verb!$ ls -l!\newline
\verb!total 24!\newline
\verb!drwxrwxr-x 2 me me 4096 Jul  6 14:59 book!\newline
\verb!-rw-rw-r-- 1 me me  141 Jul  6 14:59 calendar.data!\newline
\verb!drwxrwxr-x 2 me me 4096 Jul  6 14:59 Music!\newline
\verb!drwxrwxr-x 2 me me 4096 Jul  6 14:59 Pictures!\newline
\verb!-rw-rw-r-- 1 me me   86 Jul  6 14:59 shopping.list!\newline
\verb!drwxrwxr-x 2 me me 4096 Jul  6 14:59 src!\newline
\verb!$ echo '$ ls -l' >tmp.out !\textit{where is the output?}\newline
\verb!$ ls -l >>tmp.out         !\textit{and this output?}\newline
\verb!$ cat tmp.out             !\textit{maybe it's in here?}\newline
\verb!$ ls -l                   !\textit{yes, it is}\newline
\verb!total 24!\newline
\verb!drwxrwxr-x 2 me me 4096 Jul  6 14:59 book!\newline
\verb!-rw-rw-r-- 1 me me  141 Jul  6 14:59 calendar.data!\newline
\verb!drwxrwxr-x 2 me me 4096 Jul  6 14:59 Music!\newline
\verb!drwxrwxr-x 2 me me 4096 Jul  6 14:59 Pictures!\newline
\verb!-rw-rw-r-- 1 me me   86 Jul  6 14:59 shopping.list!\newline
\verb!drwxrwxr-x 2 me me 4096 Jul  6 14:59 src!\newline
\normalsize
\end{adjustwidth}

Thus, we see that there is yet another special character understood by the shell.
If it detects an argument of the form \verb!>filename!, it redirects the program's standard output to
that file. If it detects an argument of the form \verb!>>filename!, it redirects the program's standard output to the end of that file (i.e., its output is appended to the current contents of the file).

The ability to perform such redirection \emph{again} depends upon each program writing to standard
output by default.

It's a bit clunky having to break up our original command line (\verb!echo '$ ls -l'; ls -l!) into
separate commands, and appending the output of all but the first command to the file.
The shell also understands grouping commands to act as a single ``command'', such that you can redirect
the input or output for the ``command'' in one go, as in:
\begin{adjustwidth}{1cm}{}
\small
\verb!$ (echo '$ ls -l'; ls -l) >tmp.out !\textit{group the enclosed commands}\newline
\verb!$ cat tmp.out!\newline
\verb!$ ls -l!\newline
\verb!total 24!\newline
\verb!drwxrwxr-x 2 me me 4096 Jul  6 14:59 book!\newline
\verb!-rw-rw-r-- 1 me me  141 Jul  6 14:59 calendar.data!\newline
\verb!drwxrwxr-x 2 me me 4096 Jul  6 14:59 Music!\newline
\verb!drwxrwxr-x 2 me me 4096 Jul  6 14:59 Pictures!\newline
\verb!-rw-rw-r-- 1 me me   86 Jul  6 14:59 shopping.list!\newline
\verb!drwxrwxr-x 2 me me 4096 Jul  6 14:59 src!\newline
\normalsize
\end{adjustwidth}
Parentheses (more special characters) can be used to group the enclosed commands into a single ``command'', and all of the output,
appropriately serialized, can be directed to a file.
The way that this is done is that the shell acts as if you had typed the following command:
\begin{adjustwidth}{1cm}{}
\small
\verb!$ bash -c "echo '$ ls -l'; ls -l" >tmp.out!\newline
\normalsize
\end{adjustwidth}
i.e., it creates a subshell executing the enclosed commands, with the standard output of that subshell
redirected to \texttt{tmp.out}.
This also shows you that the standard input and standard output of commands executed by a shell in the
absence of redirection are the standard input and standard output of the shell, itself.

\subsubsection{Error redirection}
\label{sec:errorredirection}
It stands to reason that since we can redirect standard input and standard output, it is likely that we can redirect standard error output, as well.
\index{bash@\textbf{bash}!standard error output redirection}
You might think that the right way to do this would be to select another special character, say \Frowny{}, and for \texttt{bash} to interpret \Frowny{}\texttt{filename} to mean redirect standard error output to
\texttt{filename}, and to interpret \Frowny{}\Frowny{}\texttt{filename} to mean to redirect standard
error output to the end of \texttt{filename}.
Unfortunately, \texttt{bash} has used up all of the special characters (we have not introduced all of them,
yet).
Instead, \texttt{bash} interprets \texttt{2\textgreater{filename}} and \texttt{2\textgreater{\textgreater}{filename}} to mean that standard error output should be redirected.

Let's look at some examples of standard error output redirection:
\begin{adjustwidth}{1cm}{}
\small
\verb!$ cat Shoping.list           !\textit{typo in filename}\newline
\verb!cat: Shoping.list: No such file or directory!\newline
\verb!$ cat Shoping.list 2>tmp.err !\textit{capture the error message in a file}\newline
\verb!$ cat tmp.err                !\textit{see if it is there}\newline
\verb!cat: Shoping.list: No such file or directory!\newline
\verb!$ cat readme.1st 2>>tmp.err  !\textit{try another non-existent file}\newline
\verb!$ cat tmp.err                !\textit{see if it is there}\newline
\verb!cat: Shoping.list: No such file or directory!\newline
\verb!cat: readme.1st: No such file or directory!\newline
\normalsize
\end{adjustwidth}

Usually one does not redirect standard error output to a file; instead, we want the error messages
to be displayed on the screen so that we can see the error messages as our programs run.
Occasionally, especially if a set of commands are all being executed by the shell with the output of
the commands redirected to a file, we would also like to see the error messages embedded in the same
file so we can see the context in which the errors occur, much as we would (on the screen)
if neither output nor error output were redirected.
\texttt{bash} has a syntax for specifying this, shown below.
\begin{adjustwidth}{1cm}{}
\small
\verb!$ cat shopping.list Shoping.list >tmp.out 2>&1!\newline
\verb!$ cat tmp.out!\newline
\verb!1 bottle of milk!\newline
\verb!2 granny smith apples!\newline
\verb!3 hot house tomatoes!\newline
\verb!1 six-pack of Coca Cola!\newline
\verb!cat: Shoping.list: No such file or directory!\newline
\normalsize
\end{adjustwidth}

The non-intuitive expression \verb!2>&1! means redirect standard error output onto the same stream
as the standard output (the \texttt{1} at the end of the expression).\footnote{The order of the two redirections is important here, as \texttt{bash} will process them from left to right; thus, in this case, it redirects standard output to
\texttt{tmp.out}, then redirects standard error output to wherever standard output
is being sent. If you did them in the other order, standard error output would
be set to \texttt{bash}'s standard output, and then \texttt{cat}'s standard output is set to \texttt{tmp.out}, not what you wanted at all.}
In the same way that standard error output is represented by \texttt{2}, standard output is represented
by \texttt{1}.
In fact, we could redirect standard output in the following way:
\begin{adjustwidth}{1cm}{}
\small
\verb!$ cat shopping.list 1>tmp.out!\newline
\verb!$ cat tmp.out!\newline
\verb!1 bottle of milk!\newline
\verb!2 granny smith apples!\newline
\verb!3 hot house tomatoes!\newline
\verb!1 six-pack of Coca Cola!\newline
\normalsize
\end{adjustwidth}
That is, \texttt{digit\textgreater} works for each output stream known to \texttt{bash}.
In this book, we restrict ourselves to standard output (\texttt{1}) and standard error output
(\texttt{2}).

\subsection{Pipes and multiple processes}
\label{sec:pipes}
In the previous section we described how \texttt{bash} performs input, output, and error output redirection.
\index{bash@\textbf{bash}!pipes}
Being able to do so would be pretty useless if commands did not read from standard input by default,
write results to standard output by default, and write error messages to standard error output by default.
Given that programs do conform to this standard, \texttt{bash} can now provide significant expressive
and computational power by managing multiple processes and enabling these processes to talk to each
other \emph{without knowing that they are doing so}.
This is done through an abstraction known as \emph{pipelines}.

Suppose you wanted to know the number of files in a particular directory.
How would you do so?
One has to invoke \texttt{ls} on the directory to access its contents.
We could make a special version of \texttt{ls} that understood a flag \verb!--count!, which would indicate
that it would simply print the number of files found in each directory specified on the command line.
\verb!--all! could also be specified with this new flag, indicating that hidden files that start with a
period (\verb!.!) would also be counted. Seems reasonable so far.

But we already have \texttt{wc} which will count lines, words, and characters in a file.
If there was some easy way to put the output of \texttt{ls} into a file, and then have \texttt{wc}
take its input from that file, we would have a solution without having to modify \texttt{ls}.
But we just discussed redirection in the last section, so we can already do this!
Let's try it out on the current directory.
\begin{adjustwidth}{1cm}{}
\small
\verb!$ ls .!\newline
\verb!book  calendar.data  Music  Pictures  Shopping.List  src  tmp.err  tmp.out!\newline
\verb!$ ls . >tmp.out!\newline
\verb!$ wc -w <tmp.out         !\textit{count the words in tmp.out}\newline
\verb!8!\newline
\verb!$ rm tmp.out!\newline
\normalsize
\end{adjustwidth}
It is clear that this works.
There's the problem that we have to choose a temporary
filename for the output that does not collide with one of the files already in the directory (which we did \emph{not} do), that the temporary file will be listed by \texttt{ls} (and, thus, be counted by \texttt{wc}),
and that we have to remember to remove the temporary
file after we are done.

Operating systems have long supported the ability
for processes running programs to communicate with
each other (called \emph{interprocess communication (IPC)}, oddly enough\Smiley{}).
Linux supports several different types of IPC that
enable different styles of interaction.
In this case, we would like to have a way for two
child processes\footnote{In the same way that we
discussed parent/child relationships between directories
and files, when \texttt{bash} creates a process to
run your command, it is the process's parent, and
the process is \texttt{bash}'s child.} to interact,
with one process writing data as if to a file and the other process
reading that data, as if coming from a file.
Linux provides an abstraction in the operating system
called a \emph{pipe} which provides this ability; each
pipe has a write end and a read end; if one process
is given the write end, and another the read end,
the two processes interact without knowing that
a process is on the other end.

\texttt{bash} is already able to redirect input, output,
and error output.
So, if it knows you wanted to plumb your two processes together, it could ask the operating system for a pipe, redirect one process's standard output to the pipe,
and the redirect the other process's standard input to
the pipe.
As you might have guessed, \texttt{bash} has another
special character that indicates the need for
plumbing two processes together.
\begin{adjustwidth}{1cm}{}
\small
\verb!$ ls .!\newline
\verb!book  calendar.data  Music  Pictures  Shopping.List  src  tmp.err!\newline
\verb!$ ls . | wc -w!\newline
\verb!7!\newline
\normalsize
\end{adjustwidth}
This works exactly as intended.
Note that we removed \texttt{tmp.out} in our previous
example, so there are only \texttt{7} files in the
directory.

A vertical bar (\verb!|!) is the special character
that separates the communicating programs.
\texttt{bash} reads everything up to a semicolon or
the end of line, then breaks that line up into
individual commands separated by \verb!|! characters.
It then creates a pipe for each \verb!|! symbol,
and redirects standard output for the command to the
left of the \verb!|! to the pipe, and the standard
input for the command to right of the \verb!|! to
the pipe.
After starting each of these processes, it waits
for each of them to complete.

Note that pipelines are only concerned with standard
output and input; they do not affect standard error
output.
If you need to have both the output and error messages
go through a pipe, the previous syntax continues to
work:
\begin{adjustwidth}{1cm}{}
\small
\verb!$ cat shopping.list Shoping.list 2>&1 | more!\newline
\verb!1 bottle of milk!\newline
\verb!2 granny smith apples!\newline
\verb!3 hot house tomatoes!\newline
\verb!1 six-pack of Coca Cola!\newline
\verb!cat: Shoping.list: No such file or directory!\newline
\normalsize
\end{adjustwidth}
As described above, \verb!bash! first looks for pipe symbols (\verb!|!) in
each line that it reads, redirecting the left process's standard output to
the pipe, and redirecting the right process's standard input to the pipe.
It then processes any other IO redirection for each command.
Thus, in the above example, \verb!cat!'s standard output is already set to the
pipe, and the \verb!2>&1! is interpreted to mean that \verb!cat!'s standard
error output is to be redirected to the same place as standard output - in this
case, to the pipe.

A common use of this mixing of output and error messages
on a pipe is when you wish to observe the programs
in action \emph{and} you want to capture the
blended output in a file.
The program \texttt{tee} copies its standard input
\index{commands@\textbf{commands}!tee}
to its standard output, as well as to each of the files
in its argument list.
\begin{adjustwidth}{1cm}{}
\small
\verb!$ command [arguments, if any] 2>&1 | tee log!\newline
\normalsize
\end{adjustwidth}
will cause \verb!command! to run and display
its output and error output in the terminal window, as if it was not being
piped into \texttt{tee}.
When the command is finished, \texttt{log} will have
an exact copy of the output and error messages, in
context, as well.
This is often used when marking programming projects,
as it enables the marker to observe the student's
program under test as well as to capture a log to give
to the student as part of the assessment.

\begin{exercise}
\label{ex:wordfreqpipeline}
\small
Suppose that you have been asked to determine the frequency of words used
in a file.
We could write a program, say in Python or C, to perform this task.
Fortunately, with the standard programs available in Linux and with
\verb!bash!'s support of pipes, all one has to type is a single pipeline
command to \verb!bash!.

We know from Section \ref{sec:tr} that we can use \verb!tr! to break up a file
into one word per line.
We also know from Section \ref{sec:sort} that we can use \verb!sort! to sort
a file.
We also know from Section \ref{sec:uniq} that we can use \verb!uniq! to count
the number of successive matching lines in a file.  This is all we need for our pipeline.

Recall that the following command places each word in the standard input 
on its own line.\footnote{In this case, a ``word'' is a sequence of non-whitespace characters, separated from other words by a blank, tab, or end of line.}
\begin{adjustwidth}{1cm}{}
\verb!$ tr -s '[:blank:]' '\n'!\newline
\end{adjustwidth}

If \verb!sort! is invoked without filename arguments, it sorts the standard
input lexicographically (as characters).

Finally, if presented with a sorted file on standard input, \verb!uniq!
replaces each sequence of identical lines by a single copy of that line on
standard output; if the \verb!-c! flag has been specified, it preceds that
line by the number of identical lines in that sequence.

Therefore, given a file \verb!document!, the following pipeline will produce
the frequency of each word in the document.
\begin{adjustwidth}{1cm}{}
\verb!$ tr -s '[:blank:]' '\n' <document | sort | uniq -c!\newline
\end{adjustwidth}
\begin{itemize}[noitemsep]
\item As discussed in Section \ref{sec:uniq}, \verb!uniq! is case sensitive,
such that ``this'' and ``This'' would be considered separate words.
Add another invocation of \verb!tr! to the pipeline above to eliminate this
artefact.
\item The pipeline above outputs the results according to the sort order of
the words. It is more likely that you wish to see the words by frequency,
from high to low. Add another invocation of \verb!sort! to the pipeline above
to present the output by frequency, from highest to lowest.
\item Our definition of a ``word'' means that punctuation is included in a
word - e.g., the last word in ``I must go to the store.'' is ``store.''.
Add another invocation of \verb!tr! to the pipeline above to remove punctuation
characters from words.
\end{itemize}
$\Box$
\normalsize
\end{exercise}

\section{Compression and file packaging}
\label{sec:compressionfilepackaging}
It is not uncommon to need to share an entire directory of files with another user, on a different machine.  The mechanism by which such inter-machine sharing is achieved is beyond the scope of this book.  The mechanism by which you package such files before you share them is an important aspect of Linux use, so we will cover the basics here.
\index{file archives}

Consider the directory tree shown on page \pageref{CaDS tree}. Here, we will use another standard program,
\texttt{find}, which will perform commands on all files in a directory tree; the
\index{commands@\textbf{commands}!find}
following will print the name of each file found in the tree rooted at
\verb!CaDS!:
\begin{adjustwidth}{1cm}{}
\small
\verb!$ find CaDS -print!\newline
\verb!CaDS!\newline
\verb!CaDS/book.tex!\newline
\verb!CaDS/ch00!\newline
\verb!CaDS/ch00/Preface.pdf!\newline
\verb!CaDS/ch00/Preface.synctex.gz!\newline
\verb!CaDS/ch00/Preface.tex!\newline
\verb!CaDS/ch01!\newline
\verb!CaDS/ch01/ch01.pdf!\newline
\verb!CaDS/ch01/ch01.synctex.gz!\newline
\verb!CaDS/ch01/ch01.tex!\newline
\verb!CaDS/ch02!\newline
\verb!CaDS/ch02/adm3a.jpg!\newline
\verb!CaDS/ch02/ch02.pdf!\newline
\verb!CaDS/ch02/ch02.synctex.gz!\newline
\verb!CaDS/ch02/ch02.tex!\newline
\verb!CaDS/ch02/dir.out!\newline
\verb!CaDS/ch02/me!\newline
\verb!CaDS/ch02/me/20170706-shopping.list!\newline
\verb!CaDS/ch02/me/book!\newline
\verb!CaDS/ch02/me/calendar.data!\newline
\verb!CaDS/ch02/me/Music!\newline
\verb!CaDS/ch02/me/Pictures!\newline
\verb!CaDS/ch02/me/shopping.list!\newline
\verb!CaDS/ch02/me/src!\newline
\verb!CaDS/ch02/me.tgz!\newline
\verb!CaDS/ch02/model33teletype.jpg!\newline
\verb!CaDS/Outline.pdf!\newline
\verb!CaDS/Outline.synctex.gz!\newline
\verb!CaDS/Outline.tex!\newline
\normalsize
\end{adjustwidth}
Definitely a less informative representation than the figure on page \pageref{CaDS tree} \Smiley{}.

There are a number of ways that we could share each of these files with
other individuals (or ourselves) on another machine that does not share
this file system:
by attaching each file to an email message,
by using a network file transfer program (such as \verb!scp! or \verb!ftp!),
or by copying each file to a cloud storage provider
(such as DropBox, Apple's iCloud, or Microsoft's OneDrive).
While this one-file-at-a-time approach would work,
it does not make it easy to share all the files at once in an easy
and consistent way.
The better way would be to make a new file that contains the contents
of all of the other files along with meta-information about each
contained file so that the individual files can be extracted at the other end.
You have probably used ZIP files for such things in
your previous computer experience.

\subsection{\texttt{tar}}
\label{sec:tar}
The \verb!tar! program packages many files together into a single disk file (often called an \emph{archive}), and can restore individual files from the archive.  \verb!tar! is named after \textbf{t}ape \textbf{ar}chive, as it was initially created to move files to/from magnetic tapes.
\index{commands@\textbf{commands}!tar}

Let's create an archive of the files in the \verb!CaDS! directory:
\begin{adjustwidth}{1cm}{}
\small
\verb!$ tar -cvf CaDS.tar CaDS | column!\newline
\verb!CaDS/                                   CaDS/ch02/dir.out!\newline
\verb!CaDS/book.tex                           CaDS/ch02/me/!\newline
\verb!CaDS/ch00/                              CaDS/ch02/me/20170706-shopping.list!\newline
\verb!CaDS/ch00/Preface.pdf                   CaDS/ch02/me/book/!\newline
\verb!CaDS/ch00/Preface.synctex.gz            CaDS/ch02/me/calendar.data!\newline
\verb!CaDS/ch00/Preface.tex                   CaDS/ch02/me/Music/!\newline
\verb!CaDS/ch01/                              CaDS/ch02/me/Pictures/!\newline
\verb!CaDS/ch01/ch01.pdf                      CaDS/ch02/me/shopping.list!\newline
\verb!CaDS/ch01/ch01.synctex.gz               CaDS/ch02/me/src/!\newline
\verb!CaDS/ch01/ch01.tex                      CaDS/ch02/me.tgz!\newline
\verb!CaDS/ch02/                              CaDS/ch02/model33teletype.jpg!\newline
\verb!CaDS/ch02/adm3a.jpg                     CaDS/Outline.pdf!\newline
\verb!CaDS/ch02/ch02.pdf                      CaDS/Outline.synctex.gz!\newline
\verb!CaDS/ch02/ch02.synctex.gz               CaDS/Outline.tex!\newline
\verb!CaDS/ch02/ch02.tex!\newline
\normalsize
\end{adjustwidth}
The flags to \verb!tar! that we have used have the following meanings: \verb!-c! means create an archive, \verb!-v! means write the name of each file as it is added, and \verb!-f filename! means to create the archive in \verb!filename!.  As you can see, \verb!tar! allows you to collect all flags into a single argument; since \verb!f! is included in the flag argument, the name of the archive file to be created must immediately follow \verb!-cvf!. The filename arguments for inclusion can either be regular files, or the name of a directory; in the latter case, all files contained in the directory are included in the archive; if an included file is a directory, then its contents are also included in the archive.
Note that we have used another Linux command, \texttt{column}, to pack the list of file and
\index{commands@\textbf{commands}!column}
directory names into columns across the screen to more efficiently use the vertical space in the
book; if we had not piped the output of \texttt{tar} into \texttt{column}, each filename would have appeared on a single line.

Suppose I have received \verb!CaDS.tar! from someone, and it is currently stored in \texttt{/home/jsven}.  To check the contents of the archive, I can say
\begin{adjustwidth}{1cm}{}
\small
\verb!$ tar -tf CaDS.tar | column!\newline
\verb!CaDS/                                   CaDS/ch02/dir.out!\newline
\verb!CaDS/book.tex                           CaDS/ch02/me/!\newline
\verb!CaDS/ch00/                              CaDS/ch02/me/20170706-shopping.list!\newline
\verb!CaDS/ch00/Preface.pdf                   CaDS/ch02/me/book/!\newline
\verb!CaDS/ch00/Preface.synctex.gz            CaDS/ch02/me/calendar.data!\newline
\verb!CaDS/ch00/Preface.tex                   CaDS/ch02/me/Music/!\newline
\verb!CaDS/ch01/                              CaDS/ch02/me/Pictures/!\newline
\verb!CaDS/ch01/ch01.pdf                      CaDS/ch02/me/shopping.list!\newline
\verb!CaDS/ch01/ch01.synctex.gz               CaDS/ch02/me/src/!\newline
\verb!CaDS/ch01/ch01.tex                      CaDS/ch02/me.tgz!\newline
\verb!CaDS/ch02/                              CaDS/ch02/model33teletype.jpg!\newline
\verb!CaDS/ch02/adm3a.jpg                     CaDS/Outline.pdf!\newline
\verb!CaDS/ch02/ch02.pdf                      CaDS/Outline.synctex.gz!\newline
\verb!CaDS/ch02/ch02.synctex.gz               CaDS/Outline.tex!\newline
\verb!CaDS/ch02/ch02.tex!\newline
\normalsize
\end{adjustwidth}
The \verb!-t! command to \verb!tar! indicates that I want to see a table of contents. Again, we have
used \texttt{column} to pack the output into columns.

If I execute the following:
\begin{adjustwidth}{1cm}{}
\small
\verb!$ tar -tvf CaDS.tar CaDS/ch02/ch02.tex!\newline
\verb!-rw-r--r-- me/me   94095 2017-07-14 11:28 CaDS/ch02/ch02.tex!\newline
\normalsize
\end{adjustwidth}
I see a verbose listing about \verb!CaDS/ch02/ch02.tex!.  It looks very similar to the output of \verb!ls -l!, in that it shows each file's protections, owner/group, size, modification date, and its name.

If I want to extract all of the files into my home directory, I would say the following:
\begin{adjustwidth}{1cm}{}
\small
\verb!$ tar -xf book.tar!\newline
\normalsize
\end{adjustwidth}
I can check to see that it has worked by executing
\begin{adjustwidth}{1cm}{}
\small
\verb!$ ls CaDS!\newline
\verb!book.tex  ch00  ch01  ch02  Outline.pdf  Outline.synctex.gz  Outline.tex!\newline
\normalsize
\end{adjustwidth}

Sometimes you want to extract a particular file onto the standard output.  This can be achieved using the following command:
\begin{adjustwidth}{1cm}{}
\small
\verb!$ tar -xOf CaDS.tar CaDS/ch01/ch01.tex >chapter1.tex!\newline
\normalsize
\end{adjustwidth}

There are many other options supported by \verb!tar!.  See \verb!tar(1)! for more information.\footnote{This indicates that you should look at the man page for \texttt{tar} in section 1 of the Linux users manual. This can be achieved using a browser, as indicated earlier in the chapter, or by typing
\texttt{man 1 tar} to the shell.}

\subsection{Compression}
\label{sec:compression}

Files on a computer system often have a significant amount of redundancy in them, such that they occupy more space than is theoretically required to represent the contained information.  Linux provides tools for performing two styles of compression/inflation:
\index{file compression}
\begin{itemize}[noitemsep]
\item The tools \verb!compress!, \verb!uncompress!, and \verb!zcat! use an adaptive Lempel-Ziv coding to remove the redundancy.  \verb!compress! encodes the content of a file using adaptive Lempel-Ziv coding; \verb!uncompress! and \verb!zcat! decode an encoded file, producing the original file.
\item The tools \verb!gzip!, \verb!gunzip!, and \verb!gzcat! use Lempel-Ziv coding (LZ77) to remove the redundancy.  \verb!gzip! encodes the content of a file using Lempel-Ziv coding; \verb!gunzip! and \verb!gzcat! decode an encoded file, producing the original file.
\end{itemize} 
\index{commands@\textbf{commands}!compress}
\index{commands@\textbf{commands}!uncompress}
\index{commands@\textbf{commands}!zcat}
\index{commands@\textbf{commands}!gzip}
\index{commands@\textbf{commands}!gunzip}
\index{commands@\textbf{commands}!gzcat}

The default behavior of \verb!compress! and \verb!gzip! is to replace each file argument by an encoded file with an extension of \verb!.Z! or \verb!.gz!, respectively, while keeping the same ownership modes, access, and modification times.  For example,
\begin{adjustwidth}{1cm}{}
\small
\verb!$ cp shopping.list sl.1     !\textit{make a couple of files to compress}\newline
\verb!$ cp shopping.list sl.2!\newline
\verb!$ gzip sl.1                 !\textit{Encode sl.1 to sl.1.gz, remove sl.1}\newline
\verb!$ compress sl.2             !\textit{Encode sl.2 to sl.2.Z, remove sl.2}\newline
\normalsize
\end{adjustwidth}

The default behavior of \verb!uncompress! and \verb!gunzip! is to replace each file argument with an extension of \verb!.Z! or \verb!.gz!, respectively, by an unencoded file with the \verb!.Z! or \verb!.gz!
removed from the name while keeping the same ownership modes, access, and modification times.  For example,
\begin{adjustwidth}{1cm}{}
\small
\verb!$ gunzip sl.1.gz            !\textit{Unencode sl.1.gz to sl.1, remove sl.1.gz}\newline
\verb!$ uncompress sl.2.Z         !\textit{Unencode sl.2.Z to sl.2, remove sl.2.Z}\newline
\normalsize
\end{adjustwidth}

The default behavior of \verb!zcat! and \verb!gzcat! unencode each file argument with an extension of \verb!.Z! or \verb!.gz!, respectively, and write the unencoded content to standard output.  For example,
\begin{adjustwidth}{1cm}{}
\small
\verb!$ gzcat sl.1.gz             !\textit{Unencode sl.1.gz, writing contents to standard output}\newline
\verb!$ zcat sl.2.Z               !\textit{Unencode sl.2.Z, writing contents to standard output}\newline
\normalsize
\end{adjustwidth}

The most common use of these types of tools are for very large data files.  The principle use of compression technologies is in conjunction with file packaging tools for files that are to be exchanged.  These are described in the next section

\subsection{Compression and File Packaging}
\label{sec:compressionplusfilepackaging}
\subsubsection{\texttt{gzip} and \texttt{tar}}
\label{sec:gzipplustar}
We described the use of \verb!tar! in section \ref{sec:tar} to create \verb!tar! archives and to extract files from \verb!tar! archives.  We also described in section \ref{sec:compression} the use of \verb!gzip! to compress files.
Therefore, you can easily create a compressed \verb!tar! archive by using \verb!tar! and \verb!gzip! as follows:
\begin{adjustwidth}{1cm}{}
\small
\verb!$ tar -cf CaDS.tar CaDS; gzip CaDS.tar!\newline
\normalsize
\end{adjustwidth}
After completing these commands, you will be left with a file \verb!CaDS.tar.gz!, and \verb!CaDS.tar! will have been deleted.  To access the files in the compressed archive, you will need to execute
\begin{adjustwidth}{1cm}{}
\small
\verb!$ gunzip CaDS.tar.gz; tar -tf CaDS.tar!\newline
\normalsize
\end{adjustwidth}
Remember that the \verb!gunzip! invocation deletes the \verb!CaDS.tar.gz! file.
\needspace{8\baselineskip}
While this approach works, it suffers from several deficiencies:
\begin{itemize}[noitemsep]
\item The constant conversion from uncompressed to compressed and back again represents significant wasted computational resources.
\item During \verb!gzip! and \verb!gunzip! processing, both uncompressed and compressed versions of the \verb!tar! archive are resident on the disk.
\item If the long-term stored form of the \verb!tar! archive is the compressed form, having to convert back to uncompressed for \emph{any} access is unintuitive, at best.
\end{itemize}

Fortunately, \verb!tar! can compress and uncompress as part of its processing.  The \verb!-z! flag tells \verb!tar! to create a compressed archive during creation and file addition, and to uncompress the data in a compressed archive when extracting files or listing its contents.
\index{gzipped tar archives}

The commands:
\begin{adjustwidth}{1cm}{}
\small
\verb!$ tar -zcf CaDS.tar.gz CaDS!\newline
\verb!$ tar -ztf CaDS.tar.gz!\newline
\verb!$ tar -zxf CaDS.tar.gz CaDS/ch01/ch01.tex!\newline
\verb!$ tar -zxOf CaDS.tar.gz CaDS/ch01/ch01.tex >chapter1.tex!\newline
\normalsize
\end{adjustwidth}
creates a gzipped \verb!tar! archive containing the files in the \verb!CaDS! directory, lists the table of contents of the archive, extracts a particular file from the archive into the current working directory, and extracts a particular file from the archive onto standard output, respectively.

Gzipped \verb!tar! archives are so prevalent in Linux systems that such an archive is usually named with
a \verb!.tgz! extension, as in
\begin{adjustwidth}{1cm}{}
\small
\verb!$ tar -zcf CaDS.tgz CaDS!\newline
\normalsize
\end{adjustwidth}
We will use the \verb!.tgz! extension in the rest of the book when we have need for a gzip'ed \verb!tar! archive.

\subsubsection{\texttt{zip} and \texttt{unzip}}
\label{zipplusunzip}
While use of \verb!tar! to create compressed archives is the predominant method on Linux for creating compressed packages of files, there is another method which you may find useful, especially if you are exchanging packages with non-Linux systems.
\index{commands@\textbf{commands}!zip}
\index{commands@\textbf{commands}!unzip}
If you have encountered ZIP files in your previous computer use, you will know that a ZIP archive is similar to a compressed \verb!tar! archive; the contents have been compressed such that some of the redundancy in the contained files has been \emph{squeezed} out in the archive.  To extract one or more files from the ZIP archive, you need a program that can also uncompress the data as it is extracted.

Linux provides the \verb!zip! and \verb!unzip! commands\footnote{The Arch Linux image described in the appendices does not have \texttt{zip} or \texttt{unzip} installed. If you need to use it, you need to execute \texttt{sudo pacman -S zip} and answer the question posed in the affirmative.} for creating ZIP archive files and extracting files from a ZIP archive, respectively.  The following dialog shows use of \verb!zip! and \verb!unzip! to create, list, extract to standard output, and extract the contents of an archive \verb!example.zip!.  It assumes that we have a directory named \verb!tmp! in the current working directory.
\begin{adjustwidth}{1cm}{}
\small
\verb!$ ls tmp!\newline
\verb!cat   cat.c   tento6.txt!\newline
\verb!$ zip example.zip tmp/*!\newline
\verb!  adding: tmp/cat (deflated 70%)!\newline
\verb!  adding: tmp/cat.c (deflated 36%)!\newline
\verb!  adding: tmp/tento6.txt (deflated 80%)!\newline
\verb!$ unzip -l example.zip!\newline
\verb!Archive:  example.zip!\newline
\verb!  Length      Date    Time    Name!\newline
\verb!---------  ---------- -----   ----!\newline
\verb!     8710  2016-08-30 12:44   tmp/cat!\newline
\verb!      327  2016-08-30 12:43   tmp/cat.c!\newline
\verb! 46301948  2016-08-30 12:44   tmp/tento6.txt!\newline
\verb!---------                     -------!\newline
\verb! 46310985                     3 files!\newline
\verb!$ unzip -p example.zip tmp/cat.c >mycat.c!\newline
\verb!$ unzip -o example.zip!\newline
\verb!Archive:  example.zip!\newline
\verb!  inflating: tmp/cat                 !\newline
\verb!  inflating: tmp/cat.c               !\newline
\verb!  inflating: tmp/tento6.txt          !\newline
\normalsize
\end{adjustwidth}

This creates \verb!example.zip! containing all of the files in \verb!tmp! using the adaptive Lempel-Ziv encoding as used in \verb!compress!.  As each file is added, \verb!zip! prints the size of the file, the compressed size, and the percentage of compression on standard output.
The \verb!unzip -l! command enables you to determine the contents of an archive.
The \verb!unzip -p! command enables you to extract a member of the archive to standard output; in this case, we redirect standard output to \verb!mycat.c!.  Finally, to extract the entire contents of an archive, you invoke \verb!unzip archive-name!; the files are extracted into the current working directory; if a filename includes a directory name (e.g., \verb!tmp/cat.c!), the file will be extracted into that directory; the directory will be created if it does not exist.  If a file already exists, \verb!unzip! will prompt you about each file unless you have specified the \verb!-o! flag, which indicates overwrite existing files without prompting.

\section{Summary}
\label{sec:ch2summary}
This chapter has introduced you to the Linux system
as experienced by a user.

It started off discussing the basic features of the shell,
how commands are initiated and provided arguments,
and presented a number of basic commands that will
enable you to get started using the system.
As we discuss C programming in a later chapter,
we will introduce additional programs that are needed
to develop software written in C for use on Linux
(and other Posix-compliant systems).

We then moved on to discuss the major aspects of the
file system, and the most important directories in the
file system for a software developer.

Armed with knowledge of the file system, we then
returned to additional features of the shell that
enable sophisticated use of the shell.

Finally, we described how to create files (archives) that contain other files for sharing with other
users, both in uncompressed and compressed formats.
